<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Kubewarden Kubernetes Policy Engine</title>
        
        <meta name="robots" content="noindex" />
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="Documentation of Kubewarden project">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        
        <link rel="icon" href="favicon.svg">
        
        
        <link rel="shortcut icon" href="favicon.png">
        
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="introduction.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="quick-start.html"><strong aria-hidden="true">2.</strong> Quick Start</a></li><li class="chapter-item expanded "><a href="testing-policies.html"><strong aria-hidden="true">3.</strong> Testing Policies</a></li><li class="chapter-item expanded "><a href="writing-policies/index.html"><strong aria-hidden="true">4.</strong> Writing Policies</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="writing-policies/rust.html"><strong aria-hidden="true">4.1.</strong> Rust</a></li></ol></li><li class="chapter-item expanded "><a href="distributing-policies.html"><strong aria-hidden="true">5.</strong> Distributing Policies</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">Kubewarden Kubernetes Policy Engine</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                        <a href="https://github.com/kubewarden/docs" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <blockquote>
<p><strong>WARNING:</strong> Kubewarden is in early development stage, it's not production ready.</p>
<p>Feedback is highly appreciated.</p>
</blockquote>
<h1><a class="header" href="#introduction" id="introduction">Introduction</a></h1>
<p>Kubewarden is a <a href="https://kubernetes.io/docs/reference/access-authn-authz/extensible-admission-controllers/">Kubernetes Dynamic Admission
Controller</a>
that validates incoming requests using policies written in
WebAssembly.</p>
<h2><a class="header" href="#what-is-webassembly" id="what-is-webassembly">What is WebAssembly?</a></h2>
<p>As stated on <a href="https://webassembly.org/">WebAssembly's official
website</a>:</p>
<blockquote>
<p>WebAssembly (abbreviated Wasm) is a binary instruction format for a
stack-based virtual machine. Wasm is designed as a portable
compilation target for programming languages, enabling deployment on
the web for client and server applications.</p>
</blockquote>
<p>WebAssembly has been originally conceived as an &quot;extension&quot; of
browsers. However, recent efforts have been made by the WebAssembly
community to allow the execution of WebAssembly code outside of
browsers.</p>
<h2><a class="header" href="#why-use-webassembly" id="why-use-webassembly">Why use WebAssembly?</a></h2>
<p>By using WebAssembly, users can write Kubernetes policies using their
favorite programming language, as long as the language can produce
Wasm binaries.</p>
<p>Policy authors can reuse their skills, tools and best
practices. Policies are &quot;traditional&quot; programs that can have reusable
blocks (regular libraries), can be tested, can be linted, can be
plugged into their current CI and CD workflows,...</p>
<p>Wasm modules are portable, once built they can run on any kind of
processor architecture and Operating System. A policy built on a Apple
Silicon machine can be run on a x86_64 Linux server without any
conversion.</p>
<h2><a class="header" href="#policy-distribution" id="policy-distribution">Policy distribution</a></h2>
<p>Kubewarden Policies can be served by a regular web server or, even
better, can be published inside of an OCI compliant registry.</p>
<p>Kubewarden Policies can be stored inside of an OCI compliant registry as
<a href="https://github.com/opencontainers/artifacts">OCI artifacts</a>.</p>
<h1><a class="header" href="#quick-start" id="quick-start">Quick Start</a></h1>
<p>The Kubewarden stack is made of the following components:</p>
<ul>
<li>An arbitrary number of <code>ClusterAdmissionPolicy</code> resources: this is how policies
are defined inside of Kubernetes</li>
<li>A Deployment of Kubewarden <code>policy-server</code>: this component loads all the
policies defined by the administrators and evaluates them</li>
<li>A Deployment of <code>kubewarden-controller</code>: this is the controller that monitors
the <code>AdmissionPolicy</code> resources and interacts with the Kubewarden <code>policy-server</code></li>
</ul>
<h2><a class="header" href="#install" id="install">Install</a></h2>
<p>The Kubewarden stack can be deployed using a helm chart:</p>
<pre><code class="language-console">helm repo add kubewarden https://charts.kubewarden.io
helm install --namespace kubewarden --create-namespace kubewarden-controller kubewarden/kubewarden-controller
</code></pre>
<p>This will install <code>kubewarden-controller</code> on the Kubernetes cluster in the default
configuration and will register the <code>AdmissionPolicy</code> Custom Resource. The
components of the Kubewarden stack will be deployed inside of a Kubernetes
Namespace called <code>kubewarden</code>.</p>
<p>The default configuration values should be good enough for the majority of
deployments, all the options are documented <a href="https://charts.kubewarden.io/#configuration">here</a>.</p>
<p>The Kubewarden Policy Server is completely managed by the kubewarden-controller.</p>
<h2><a class="header" href="#kubewarden-policies" id="kubewarden-policies">Kubewarden Policies</a></h2>
<p>Enforcing policies is by far the most common operation a Kubernetes
administrator will perform. You can declare as many policies as you want,
targeting any kind of Kubernetes resource and type of operation that can be
done against them.</p>
<p>The <code>ClusterAdmissionPolicy</code> resource is the core of the Kubewarden stack: this is
how validating policies are defined.</p>
<pre><code class="language-yaml">apiVersion: policies.kubewarden.io/v1alpha1
kind: ClusterAdmissionPolicy
metadata:
  name: psp-capabilities
spec:
  module: registry://ghcr.io/kubewarden/policies/psp-capabilities:v0.1.1
  resources:
  - pods
  operations:
  - CREATE
  - UPDATE
  mutating: true
  settings:
    allowed_capabilities:
    - CHOWN
    required_drop_capabilities:
    - NET_ADMIN
</code></pre>
<p>This is a quick overview of the attributes of the <code>ClusterAdmissionPolicy</code> resource:</p>
<ul>
<li><code>module</code>: this is the location of the Kubewarden policy, several schemas are
supported.
<ul>
<li><code>registry</code>: download from an <a href="https://github.com/opencontainers/artifacts">OCI artifacts</a>
compliant container registry</li>
<li><code>http</code>, <code>https</code>: download from a regular HTTP(s) server</li>
<li><code>file</code>: load the module from the local filesystem</li>
</ul>
</li>
<li><code>resources</code>: types of resources evaluated by the policy</li>
<li><code>operations</code>: what operations for the previously given types should
be forwarded to this admission policy by the API server for
evaluation.</li>
<li><code>mutating</code>: a boolean value that must be set to <code>true</code> for policies that can
mutate incoming requests.</li>
<li><code>settings</code> (optional): a free-form object that contains the policy
configuration values.</li>
<li><code>failurePolicy</code> (optional): how unrecognized errors and timeout errors from
the policy are handled. Allowed values are <code>Ignore</code> or <code>Fail</code>. <code>Ignore</code> means
that an error calling the webhook is ignored and the API request is allowed
to continue. <code>Fail</code> means that an error calling the webhook causes the
admission to fail and the API request to be rejected.
The default behaviour is <code>Fail</code>.</li>
</ul>
<p>The complete documentation of this Custom Resource can be found
<a href="https://github.com/kubewarden/kubewarden-controller/blob/main/docs/crds/README.asciidoc">here</a>
or on
<a href="https://doc.crds.dev/github.com/kubewarden/kubewarden-controller">docs.crds.dev</a>.</p>
<blockquote>
<p><strong>NOTE:</strong> ClusterAdmissionPolicy resources are registered with a <code>*</code> webhook
<code>scope</code>, which means that registered webhooks will be forwarded all
requests matching the given <code>resources</code> and <code>operations</code> -- either
namespaced (in any namespace), or cluster-wide resources.</p>
</blockquote>
<blockquote>
<p><strong>NOTE:</strong> The <code>ClusterAdmissionPolicy</code> resource is cluster-wide. There are
plans to also provide a namespaced version that will only impact
registered namespaced resources on its own namespace.</p>
</blockquote>
<h2><a class="header" href="#enforce-your-first-policy" id="enforce-your-first-policy">Enforce your first policy</a></h2>
<p>We will use the <a href="https://github.com/kubewarden/pod-privileged-policy"><code>pod-privileged</code> policy</a>.
This policy prevents the creation of privileged containers inside of a Kubernetes cluster.</p>
<p>Let's define a <code>ClusterAdmissionPolicy</code> for that:</p>
<pre><code class="language-console">kubectl apply -f - &lt;&lt;EOF
apiVersion: policies.kubewarden.io/v1alpha1
kind: ClusterAdmissionPolicy
metadata:
  name: privileged-pods
spec:
  module: registry://ghcr.io/kubewarden/policies/pod-privileged:v0.1.4
  resources:
  - pods
  operations:
  - CREATE
  - UPDATE
  mutating: false
EOF
</code></pre>
<p>This will produce the following output:</p>
<pre><code class="language-console">clusteradmissionpolicy.policies.kubewarden.io/privileged-pods created
</code></pre>
<p>Defining the <code>ClusterAdmissionPolicy</code> will lead to a rollout of the Kubewarden Policy
Server Deployment. Once the new policy is ready to be served, the <code>kubewarden-controller</code>
will register a <a href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.20/#validatingwebhookconfiguration-v1-admissionregistration-k8s-io">ValidatingWebhookConfiguration</a>
object.</p>
<p>Once all the instances of <code>policy-server</code> are ready, the
<code>ValidatingWebhookConfiguration</code> will be visible:</p>
<pre><code class="language-console">$ kubectl get validatingwebhookconfigurations.admissionregistration.k8s.io -l kubewarden
NAME              WEBHOOKS   AGE
privileged-pods   1          9s
</code></pre>
<p>Let's try to create a Pod with no privileged containers:</p>
<pre><code class="language-console">kubectl apply -f - &lt;&lt;EOF
apiVersion: v1
kind: Pod
metadata:
  name: unprivileged-pod
spec:
  containers:
    - name: nginx
      image: nginx:latest
EOF
</code></pre>
<p>This will produce the following output, which means the Pod was successfully
created:</p>
<pre><code class="language-console">pod/unprivileged-pod created
</code></pre>
<p>Now, let's try to create a pod with at least one privileged container:</p>
<pre><code class="language-console">kubectl apply -f - &lt;&lt;EOF
apiVersion: v1
kind: Pod
metadata:
  name: privileged-pod
spec:
  containers:
    - name: nginx
      image: nginx:latest
      securityContext:
          privileged: true
EOF
</code></pre>
<p>This time the creation of the Pod will be blocked, with the following message:</p>
<pre><code class="language-console">Error from server: error when creating &quot;STDIN&quot;: admission webhook &quot;privileged-pods.kubewarden.admission&quot; denied the request: User 'minikube-user' cannot schedule privileged containers
</code></pre>
<h2><a class="header" href="#uninstall" id="uninstall">Uninstall</a></h2>
<p>As a first step remove all the <code>ClusterAdmissionPolicy</code> resources you have created.
This can be done with the following command:</p>
<pre><code class="language-shell">kubectl delete --all clusteradmissionpolicies.policies.kubewarden.io
</code></pre>
<p>Then wait for the for the <code>kubewarden-controller</code> to remove all the
Kubernetes <code>ValidatingWebhookConfiguration</code> and the <code>MutatingWebhookConfiguration</code>
resources it created.</p>
<p>This can be monitored with the following command:</p>
<pre><code class="language-shell">kubectl get validatingwebhookconfigurations.admissionregistration.k8s.io -l &quot;kubewarden&quot; &amp;&amp; \
kubectl get mutatingwebhookconfigurations.admissionregistration.k8s.io -l &quot;kubewarden&quot;
</code></pre>
<p>If these resources are not automatically removed, you can do
remove them manually by using the following command:</p>
<pre><code class="language-shell">kubectl delete -l &quot;kubewarden&quot; validatingwebhookconfigurations.admissionregistration.k8s.io &amp;&amp; \
kubectl delete -l &quot;kubewarden&quot; mutatingwebhookconfigurations.admissionregistration.k8s.io
</code></pre>
<p>Finally you can uninstall the Helm chart:</p>
<pre><code class="language-shell">helm uninstall kubewarden-controller
</code></pre>
<p>Once this is done you can remove the Kubernetes namespace that was used to deploy
the Kubewarden stack:</p>
<pre><code class="language-shell">kubectl delete namespace kubewarden
</code></pre>
<p>This will delete all the resources that were created at runtime by the <code>kubewarden-controller</code>,
like the <code>policy-server</code> Deployment.</p>
<blockquote>
<p><strong>Note well:</strong> it's extremely important to remove the <code>ValidatingWebhookConfiguration</code>
and <code>MutatingWebhookConfiguration</code> resources <strong>before</strong> the
<code>policy-server</code> Deployment. Otherwise the Kubernetes
API server will continuously face timeout errors while trying to evaluate the
incoming requests.</p>
<p>By default the <code>ValidatingWebhookConfiguration</code> and <code>MutatingWebhookConfiguration</code>
resources created by Kubewarden have <code>policyFailure</code>
set to <code>Fail</code>, which will cause all these incoming requests to be rejected.</p>
<p><strong>This could bring havoc on your cluster.</strong></p>
</blockquote>
<h2><a class="header" href="#wrapping-up" id="wrapping-up">Wrapping up</a></h2>
<p>As we have seen, the <code>ClusterAdmissionPolicy</code> resource is the core type that
a cluster operator has to manage, the rest of the resources needed to
run the policies and configure them will be taken care of
automatically by the <code>kubewarden-controller</code> project.</p>
<h1><a class="header" href="#testing-policies" id="testing-policies">Testing Policies</a></h1>
<p>This section covers the topic of testing Kubewarden Policies. There are two possible
personas interested in testing policies:</p>
<ul>
<li>As a policy author: you're writing a Kubewarden Policy and you want to ensure
your code behaves the way you expect.</li>
<li>As an end user: you found a Kubewarden Policy and you want to tune/test the policy
settings before deploying it, maybe you want to keep testing these settings
inside of your CI/CD pipelines,...</li>
</ul>
<h1><a class="header" href="#kubewarden-policy-authors" id="kubewarden-policy-authors">Kubewarden Policy authors</a></h1>
<p>Kubewarden Policies are regular programs compiled as WebAssembly. As with any kind
of program, it's important to have a good test coverage.</p>
<p>Policy authors can leverage the testing frameworks and tools of their language
of choice to verify the behaviour of their policies.</p>
<p>As an example, you can take a look at these Kubewarden policies:</p>
<ul>
<li><a href="https://github.com/kubewarden/pod-privileged-policy">pod-privileged-policy</a>: this
is a Kubewarden Policy written using <a href="https://www.assemblyscript.org/">AssemblyScript</a>.</li>
<li><a href="https://github.com/kubewarden/psp-apparmor">psp-apparmor</a>: this
is a Kubewarden Policy written using <a href="https://www.rust-lang.org/">Rust</a>.</li>
</ul>
<p>Both policies have integrated test suites built using the regular testing libraries
of Rust and AssemblyScript.</p>
<p>Finally, both projects rely on GitHub actions to implement their CI pipelines.</p>
<h1><a class="header" href="#end-users" id="end-users">End users</a></h1>
<p>Aside from the approach of testing policy logic with the tools that
your language toolchain already provides, Kubewarden has a dedicated
project for testing policies:
<a href="https://github.com/kubewarden/policy-server/tree/main/crates/policy-testdrive"><code>policy-testdrive</code></a>.</p>
<p>The concept of <code>policy-testdrive</code> is quite simple from a user
point of view. You have to provide:</p>
<ol>
<li>The Wasm file providing the policy to be tested. The file is specified through
the <code>--policy</code> argument. At this  time you can only load files in the local
filesystem.</li>
<li>A file containing the admission request object to be evaluated by
the policy. This is provided via the <code>--request-file</code> argument.</li>
<li>The policy settings to be used at evaluation time, they can be provided
via <code>--settings</code> flag. The flag takes a JSON blob as parameter.</li>
</ol>
<h2><a class="header" href="#install-1" id="install-1">Install</a></h2>
<p>You can download pre-built binaries of <code>policy-testdrive</code>
from <a href="https://github.com/kubewarden/policy-server/releases">here</a>.</p>
<h2><a class="header" href="#quickstart" id="quickstart">Quickstart</a></h2>
<h3><a class="header" href="#prerequisites" id="prerequisites">Prerequisites</a></h3>
<p>We will use <a href="https://github.com/engineerd/wasm-to-oci"><code>wasm-to-oci</code></a>
to download a Kubewarden Policy published on a Container registry.</p>
<p>Pre-built binaries of <code>wasm-to-oci</code>can be downloaded from the project's
<a href="https://github.com/engineerd/wasm-to-oci/releases">GitHub Releases page</a>.</p>
<h3><a class="header" href="#obtain-a-kubewarden-policy" id="obtain-a-kubewarden-policy">Obtain a Kubewarden policy</a></h3>
<p>We will download the
<a href="https://github.com/kubewarden/psp-apparmor">psp-apparmor</a> policy:</p>
<pre><code class="language-console">wasm-to-oci pull ghcr.io/kubewarden/policies/psp-apparmor:v0.1.2
</code></pre>
<p>This will produce the following output:</p>
<pre><code class="language-console">INFO[0001] Pulled: ghcr.io/kubewarden/policies/psp-apparmor:v0.1.2 
INFO[0001] Size: 2682915
INFO[0001] Digest: sha256:5532a49834af8cc929994a65c0881190ef168295fffd2bed4e7325d2e91484b5 
</code></pre>
<p>This should have created a <code>module.wasm</code> file in the current directory.</p>
<h3><a class="header" href="#create-admissionreview-requests" id="create-admissionreview-requests">Create <code>AdmissionReview</code> requests</a></h3>
<p>We have to create some files holding the <code>AdmissionReview</code> objects that
will be evaluated by the policy.</p>
<p>Let's create a file named <code>pod-req-no-specific-apparmor-profile.json</code> with the following
contents:</p>
<pre><code class="language-json">{
  &quot;kind&quot;: {
    &quot;kind&quot;: &quot;Pod&quot;,
    &quot;version&quot;: &quot;v1&quot;
  },
  &quot;object&quot;: {
    &quot;metadata&quot;: {
      &quot;name&quot;: &quot;no-apparmor&quot;
    },
    &quot;spec&quot;: {
      &quot;containers&quot;: [
        {
          &quot;image&quot;: &quot;nginx&quot;,
          &quot;name&quot;: &quot;nginx&quot;
        }
      ]
    }
  },
  &quot;operation&quot;: &quot;CREATE&quot;,
  &quot;requestKind&quot;: {&quot;version&quot;: &quot;v1&quot;, &quot;kind&quot;: &quot;Pod&quot;},
  &quot;userInfo&quot;: {
    &quot;username&quot;: &quot;alice&quot;,
    &quot;uid&quot;: &quot;alice-uid&quot;,
    &quot;groups&quot;: [&quot;system:authenticated&quot;]
  }
}
</code></pre>
<p>This request tries to create a Pod that doesn't specify any AppArmor
profile to be used, that's because it doesn't have an <code>annotation</code> with the
<code>container.apparmor.security.beta.kubernetes.io/&lt;name of the container&gt;</code>
key.</p>
<p>Let's create a file named <code>pod-req-apparmor-unconfined.json</code> with the following
contents:</p>
<pre><code class="language-json">{
  &quot;kind&quot;: {
    &quot;kind&quot;: &quot;Pod&quot;,
    &quot;version&quot;: &quot;v1&quot;
  },
  &quot;object&quot;: {
    &quot;metadata&quot;: {
      &quot;name&quot;: &quot;privileged-pod&quot;,
      &quot;annotations&quot;: {
        &quot;container.apparmor.security.beta.kubernetes.io/nginx&quot;: &quot;unconfined&quot;
      }
    },
    &quot;spec&quot;: {
      &quot;containers&quot;: [
        {
          &quot;image&quot;: &quot;nginx&quot;,
          &quot;name&quot;: &quot;nginx&quot;
        }
      ]
    }
  },
  &quot;operation&quot;: &quot;CREATE&quot;,
  &quot;requestKind&quot;: {&quot;version&quot;: &quot;v1&quot;, &quot;kind&quot;: &quot;Pod&quot;},
  &quot;userInfo&quot;: {
    &quot;username&quot;: &quot;alice&quot;,
    &quot;uid&quot;: &quot;alice-uid&quot;,
    &quot;groups&quot;: [&quot;system:authenticated&quot;]
  }
}
</code></pre>
<p>This request tries to create a Pod with a container called <code>nginx</code> that is going
to be run with the <code>unconfined</code> AppArmor profile. This is considered a bad
security practice.</p>
<p>Finally, let's create a file named <code>pod-req-apparmor-custom.json</code> with the following
contents:</p>
<pre><code class="language-json">{
  &quot;kind&quot;: {
    &quot;kind&quot;: &quot;Pod&quot;,
    &quot;version&quot;: &quot;v1&quot;
  },
  &quot;object&quot;: {
    &quot;metadata&quot;: {
      &quot;name&quot;: &quot;privileged-pod&quot;,
      &quot;annotations&quot;: {
        &quot;container.apparmor.security.beta.kubernetes.io/nginx&quot;: &quot;localhost/nginx-custom&quot;
      }
    },
    &quot;spec&quot;: {
      &quot;containers&quot;: [
        {
          &quot;image&quot;: &quot;nginx&quot;,
          &quot;name&quot;: &quot;nginx&quot;
        }
      ]
    }
  },
  &quot;operation&quot;: &quot;CREATE&quot;,
  &quot;requestKind&quot;: {&quot;version&quot;: &quot;v1&quot;, &quot;kind&quot;: &quot;Pod&quot;},
  &quot;userInfo&quot;: {
    &quot;username&quot;: &quot;alice&quot;,
    &quot;uid&quot;: &quot;alice-uid&quot;,
    &quot;groups&quot;: [&quot;system:authenticated&quot;]
  }
}
</code></pre>
<p>This request tries to create a Pod with a container called <code>nginx</code> that is going
to be run with the profile provided by the administrators of the Kubernetes cluster.
This profile is called <code>nginx-custom</code>.</p>
<blockquote>
<p><strong>Note well:</strong> these are stripped down <code>AdmissionReview</code> objects, we left
only the fields that are relevant to our policy.</p>
</blockquote>
<h3><a class="header" href="#test-the-policy" id="test-the-policy">Test the policy</a></h3>
<p>Now we can use <code>policy-testdrive</code> to test the creation of a Pod that doesn't
specify an AppArmor profile:</p>
<pre><code class="language-console">policy-testdrive --policy module.wasm --request-file pod-req-no-specific-apparmor-profile.json
</code></pre>
<p>The policy will accept the request and produce the following output:</p>
<pre><code class="language-console">Settings validation result: SettingsValidationResponse { valid: true, message: None }
Policy evaluation results:
ValidationResponse { uid: &quot;&quot;, allowed: true, patch_type: None, patch: None, status: None }
</code></pre>
<p>The policy will instead reject the creation of a Pod with an <code>unconfined</code> AppArmor
profile:</p>
<pre><code class="language-console">$ policy-testdrive --policy module.wasm --request-file pod-req-apparmor-unconfined.json

Settings validation result: SettingsValidationResponse { valid: true, message: None }
Policy evaluation results:
ValidationResponse { uid: &quot;&quot;, allowed: false, patch_type: None, patch: None, status: Some(ValidationResponseStatus { message: Some(&quot;These AppArmor profiles are not allowed: [\&quot;unconfined\&quot;]&quot;), code: None }) }
</code></pre>
<p>Both times we did a test drive of the policy <strong>without</strong> providing any kind of
setting. As the <a href="https://github.com/kubewarden/psp-apparmor#configuration">policy's documentation</a>
states, this results in preventing the usage of non-default profiles.</p>
<p>As a matter of fact, the Pod using a custom <code>nginx</code> profile gets rejected by
the policy too:</p>
<pre><code class="language-console">$ policy-testdrive --policy module.wasm --request-file pod-req-apparmor-custom.json 

Settings validation result: SettingsValidationResponse { valid: true, message: None }
Policy evaluation results:
ValidationResponse { uid: &quot;&quot;, allowed: false, patch_type: None, patch: None, status: Some(ValidationResponseStatus { message: Some(&quot;These AppArmor profiles are not allowed: [\&quot;localhost/nginx-custom\&quot;]&quot;), code: None }) }
</code></pre>
<p>We can change the default behaviour and allow some chosen AppArmor to be used:</p>
<pre><code class="language-console">policy-testdrive --policy module.wasm \
  --request-file pod-req-apparmor-custom.json \
  --settings '{&quot;allowed_profiles&quot;: [&quot;runtime/default&quot;, &quot;localhost/nginx-custom&quot;]}'
</code></pre>
<p>This time the request is accepted:</p>
<pre><code class="language-console">Settings validation result: SettingsValidationResponse { valid: true, message: None }
Policy evaluation results:
ValidationResponse { uid: &quot;&quot;, allowed: true, patch_type: None, patch: None, status: None }
</code></pre>
<h2><a class="header" href="#wrapping-up-1" id="wrapping-up-1">Wrapping up</a></h2>
<p>Testing Kubewarden Policies is extremely important.</p>
<p>As a Kubewarden Policy author you can leverage the testing frameworks of your favorite
programming language and combine it with the CI systems of your choice to
ensure your code behaves as expected.</p>
<p>As a Kubewarden Policy end user you can use <code>policy-testdrive</code> to test
policies and their tuning outside of Kubernetes.</p>
<h1><a class="header" href="#what-is-a-kubewarden-policy" id="what-is-a-kubewarden-policy">What is a Kubewarden policy</a></h1>
<p>In this section we will explain what Kubewarden policies are by using some traditional computing
analogies.</p>
<p>A Kubewarden policy can be seen as a regular program that does one job: it receives
input data, performs some computation against that and it finally returns a response.</p>
<p>The input data are Kubernetes admission requests and the result of the computation
is a validation response, something that tells to Kubernetes whether to accept, reject or
mutate the original input data.</p>
<p>All these operations are performed by a component of Kubewarden that is called
<a href="https://github.com/kubewarden/policy-server">policy-server</a>.</p>
<p>The policy server doesn't bundle any data processing capability. All these capabilities are
added at runtime via add-ons: the Kubewarden policies.</p>
<p>As a consequence, a Kubewarden policy can be seen as a <a href="https://en.wikipedia.org/wiki/Plug-in_%28computing%29">traditional plug-in</a>
of the &quot;policy server&quot; program.</p>
<p>To recap:</p>
<ul>
<li>Kubewarden policies are plug-ins that expose a set of well-defined
functionalities (validate a Kubernetes request object, validate policy settings
provided by the user,...) using a well-defined API</li>
<li>Policy server is the &quot;main&quot; program that loads the plug-ins
(aka policies) and leverages their exposed functionalities to validate or mutate
Kubernetes requests</li>
</ul>
<p>Writing Kubewarden policies consists of writing the validation business logic
and then exposing it through a well-defined API.</p>
<h1><a class="header" href="#programming-language-requirements" id="programming-language-requirements">Programming language requirements</a></h1>
<p>Kubewarden policies are delivered as <a href="https://webassembly.org/">WebAssembly</a>
binaries.</p>
<p>Policy authors can write policies using any programming language that supports
WebAssembly as a compilation target. The list of supported language is constantly
evolving, <a href="https://github.com/appcypher/awesome-wasm-langs">this page</a>
provides a nice overview of the WebAssembly landscape.</p>
<p>Currently WebAssembly doesn't have an official way to share complex data types
between the host and a WebAssembly guest. To overcome this limitation
Kubewarden policies leverage the <a href="https://github.com/wapc">waPC</a> project, which
provides a bi-directional communication channel.</p>
<p>Because of that your programming language of choice must provide a waPC guest SDK.
If that's not the case, feel free to reach out. We can help you overcome this
limitation.</p>
<h1><a class="header" href="#policy-api" id="policy-api">Policy API</a></h1>
<p>The policy evaluator interacts with Kubewarden policies using a well defined API.
The purpose of this page is to document the API each policy must expose.</p>
<blockquote>
<p><strong>Note well:</strong> this section of the documentation is a bit low level, you can
jump straight to one of the &quot;language focused&quot; chapters and come back to this
page later.</p>
</blockquote>
<h2><a class="header" href="#the-validate-entry-point" id="the-validate-entry-point">The <code>validate</code> entry point</a></h2>
<p>The Kubewarden policy server receives
<a href="https://godoc.org/k8s.io/api/admission/v1#AdmissionReview"><code>AdmissionReview</code></a>
objects from the Kubernetes API server. It then forwards the value of
the <code>request</code> (of type
<a href="https://godoc.org/k8s.io/api/admission/v1#AdmissionRequest"><code>AdmissionRequest</code></a>
key to the policy to be evaluated.</p>
<p>The policy has to evaluate the <code>request</code> and state whether it should be
accepted or not. When the request is rejected, the policy must provide the
explanation message that is going to be shown to the end user.</p>
<p>By convention of the <code>policy-server</code> project, the guest has to expose
a function named <code>validate</code>, exposed through the waPC guest SDK, so
that the <code>policy-server</code> (waPC host) can invoke it.</p>
<p>The <code>validate</code> function receives a <code>ValidationRequest</code> object serialized as JSON and
returns a <code>ValidationResponse</code> object serialized as JSON.</p>
<h3><a class="header" href="#the-validationrequest-object" id="the-validationrequest-object">The <code>ValidationRequest</code> object</a></h3>
<p>The <code>ValidationRequest</code> is a simple JSON object that is received by the
<code>validate</code> function. It looks like this:</p>
<pre><code class="language-json">{
  &quot;request&quot;: &lt;AdmissionReview.request data&gt;,
  &quot;settings&quot;: {
     // your policy configuration
  }
}
</code></pre>
<p>The <code>settings</code> key points to a free-form JSON document that can hold the policy
specific settings.</p>
<h3><a class="header" href="#the-validationresponse-object" id="the-validationresponse-object">The <code>ValidationResponse</code> object</a></h3>
<p>The <code>validate</code> function returns the outcome of its validation using a <code>ValidationResponse</code>
object.</p>
<p>The <code>ValidationResponse</code> is structured in the following way:</p>
<pre><code class="language-json">{
  &quot;accepted&quot;: &lt;boolean&gt;,   // mandatory
  &quot;message&quot;: &lt;string&gt;,     // optional, ignored if accepted - recommended for rejections
  &quot;code&quot;: &lt;integer&gt;,        // optional, ignored if accepted
  &quot;mutated_object&quot;: &lt;dict&gt; // optional, used by mutation policies
}
</code></pre>
<p>The <code>message</code> and <code>code</code> attributes can be specified when the request
is not accepted. <code>message</code> is a free form textual error. <code>code</code>
represents an HTTP error code.</p>
<p>If the request is accepted, <code>message</code> and <code>code</code>
values will be ignored by the Kubernetes API server if they are
present.</p>
<p>If <code>message</code> and/or <code>code</code> are provided, and the request is not
accepted, the Kubernetes API server will forward this information as
part of the body of the error returned to the Kubernetes API server
client that issued the rejected request.</p>
<p>The <code>mutated_object</code> is an optional field used only by mutating policies.
This field contains the object the policy wants to be created inside of the
Kubernetes cluster.
For example, given a policy that mutates Pod objects, the <code>mutated_object</code> would
contain the full spec of a Pod.</p>
<h2><a class="header" href="#the-validate_settings-entry-point" id="the-validate_settings-entry-point">The <code>validate_settings</code> entry point</a></h2>
<p>Policy behaviour can be tuned using runtime configurations. As described above, the configuration
parameters are sent inside of each <code>validate</code> invocation via the <code>settings</code> dictionary.</p>
<p>Some policies might want to validate the settings a user provides to ensure they are correct.
This is done with the <code>validate_settings</code> function.</p>
<p>The <code>validate_settings</code> function receives as input a JSON representation of the settings
provided by the user. The function validates them and returns as a response a <code>SettingsValidationResponse</code>
object.</p>
<p>The structure of the object is the following one:</p>
<pre><code class="language-json">{
  &quot;valid&quot;: &lt;boolean&gt;,  // mandatory
  &quot;message&quot;: &lt;string&gt;, // optional, ignored if accepted - recommended for rejections
}
</code></pre>
<p>If the user provided settings are <code>valid</code>, the contents of <code>message</code> are ignored. Otherwise
the contents of <code>message</code> are shown to the user.</p>
<p>Kubewarden's policy server validates all the policy settings provided by users at start time.
It will exit immediately with an error if one or more of its policies received wrong configuration parameters.</p>
<h1><a class="header" href="#rust" id="rust">Rust</a></h1>
<p><a href="https://www.rust-lang.org/">Rust</a> is the most mature programming language that
can generate WebAssembly modules: WebAssembly is a first-class citizen
in the Rust world. That means many of the tools and crates of the Rust
ecosystem work out of the box.</p>
<p>Kubewarden provides a <a href="https://crates.io/crates/kubewarden-policy-sdk">Rust SDK</a>
that simplifies the process of writing policies, plus a
<a href="https://github.com/kubewarden/policy-rust-template">template project</a> to
quickly scaffold a policy project using the
<a href="https://github.com/cargo-generate/cargo-generate"><code>cargo-generate</code></a> utility.</p>
<p>This document illustrates how to take advantage of these projects to write
Kubewarden policies using the Rust programming language.</p>
<p>Note well, we won't cover the details of Kubewarden's Rust SDK inside of this
page. These can be found inside of the
<a href="https://docs.rs/kubewarden-policy-sdk/0.1.0">official crate documentation</a>.</p>
<h2><a class="header" href="#getting-rust-dependencies" id="getting-rust-dependencies">Getting Rust dependencies</a></h2>
<p>This section guides you through the process of installing the Rust compiler and
its dependencies.</p>
<p>As a first step install the Rust compiler and its tools, this can be easily done
using <a href="https://github.com/rust-lang/rustup">rustup</a>. Please follow
<a href="https://rust-lang.github.io/rustup/installation/index.html">rustup's install documentation</a>.</p>
<p>Once <code>rustup</code> is installed add the Wasm target:</p>
<pre><code class="language-shell">rustup target add wasm32-unknown-unknown
</code></pre>
<p>Finally, install the <a href="https://github.com/cargo-generate/cargo-generate">cargo-generate</a> utility:</p>
<pre><code class="language-shell">cargo install cargo-generate
</code></pre>
<h2><a class="header" href="#creating-a-new-validation-policy" id="creating-a-new-validation-policy">Creating a new validation policy</a></h2>
<p>We are going to create a simple validation policy that processes
Pod creation requests.</p>
<p>The policy will look at the <code>metadata.name</code> attribute of the Pod and reject
the pods that have an invalid name. We want the list of invalid names to be
configurable by the end users of the policy.</p>
<p>To summarize, the policy settings will look like that:</p>
<pre><code class="language-yaml">invalid_names:
- bad_name1
- bad_name2
</code></pre>
<p>The policy will accept the creation of a Pod like the following one:</p>
<pre><code class="language-yaml">apiVersion: v1
kind: Pod
metadata:
  name: nginx
spec:
  containers:
    - name: nginx
      image: nginx:latest
</code></pre>
<p>While it will reject the creation of a Pod like the following one:</p>
<pre><code class="language-yaml">apiVersion: v1
kind: Pod
metadata:
  name: bad_name1
spec:
  containers:
    - name: nginx
      image: nginx:latest
</code></pre>
<h3><a class="header" href="#scaffolding-new-policy-project" id="scaffolding-new-policy-project">Scaffolding new policy project</a></h3>
<p>The creation of a new policy project can be done by feeding this
<a href="https://github.com/kubewarden/policy-rust-template">template project</a>
into <code>cargo generate</code>:</p>
<pre><code class="language-shell">cargo generate --git https://github.com/kubewarden/policy-rust-template \
               --branch main \
               --name demo
</code></pre>
<p>The command will produce the following output:</p>
<pre><code>ðŸ”§   Creating project called `demo`...
âœ¨   Done! New project created /home/flavio/hacking/kubernetes/kubewarden/demo
</code></pre>
<p>The new policy project can now be found inside of the <code>demo</code> directory.</p>
<h3><a class="header" href="#defining-policy-settings" id="defining-policy-settings">Defining policy settings</a></h3>
<p>As a first step we will define the structure that holds the policy settings.</p>
<p>Open the <code>src/settings.rs</code> file and change the definition of the <code>Settings</code>
struct to look like that:</p>
<pre><code class="language-rust norun noplayground">use std::collections::HashSet;

#[derive(Deserialize, Default, Debug, Serialize)]
pub(crate) struct Settings {
    pub invalid_names: HashSet&lt;String&gt;,
}
</code></pre>
<p>This will automatically put the list of invalid names inside of
a Set collection.</p>
<p>Next we will write a settings validation function: we want to ensure
the policy is always run with at least one invalid name.</p>
<p>This can be done by changing the implementation of the <code>Validatable</code> trait.</p>
<p>Change the scaffolded implementation defined inside of <code>src/settings.rs</code>
to look like that:</p>
<pre><code class="language-rust norun noplayground">impl kubewarden::settings::Validatable for Settings {
    fn validate(&amp;self) -&gt; Result&lt;(), String&gt; {
        if self.invalid_names.is_empty() {
            Err(String::from(&quot;No invalid name specified. Specify at least one invalid name to match&quot;))
        } else {
            Ok(())
        }
    }
}
</code></pre>
<p>Now we can write a unit test to ensure the settings validation is actually working.
This can be done in the <a href="https://doc.rust-lang.org/stable/book/ch11-00-testing.html">usual Rust way</a>.</p>
<p>There are already some default tests at the bottom of the <code>src/settings.rs</code>
file. Replace the automatically generated code to look like that:</p>
<pre><code class="language-rust norun noplayground">#[cfg(test)]
mod tests {
    use super::*;

    use kubewarden_policy_sdk::settings::Validatable;

    #[test]
    fn accept_settings_with_a_list_of_invalid_names() -&gt; Result&lt;(), ()&gt; {
        let mut invalid_names = HashSet::new();
        invalid_names.insert(String::from(&quot;bad_name1&quot;));
        invalid_names.insert(String::from(&quot;bad_name2&quot;));

        let settings = Settings { invalid_names };

        assert!(settings.validate().is_ok());
        Ok(())
    }

    #[test]
    fn reject_settings_without_a_list_of_invalid_names() -&gt; Result&lt;(), ()&gt; {
        let invalid_names = HashSet::&lt;String&gt;::new();
        let settings = Settings { invalid_names };

        assert!(settings.validate().is_err());
        Ok(())
    }
}
</code></pre>
<p>We can now run the unit tests by doing:</p>
<pre><code class="language-shell">cargo test
</code></pre>
<p>This will produce an output similar to the following one:</p>
<pre><code class="language-shell">  Compiling demo v0.1.0 (/home/flavio/hacking/kubernetes/kubewarden/demo)
    Finished test [unoptimized + debuginfo] target(s) in 4.19s
     Running target/debug/deps/demo-24670dd6a538fd72

running 2 tests
test settings::tests::accept_settings_with_a_list_of_invalid_names ... ok
test settings::tests::reject_settings_without_a_list_of_invalid_names ... ok

test result: ok. 2 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s
</code></pre>
<h3><a class="header" href="#writing-the-validation-business-logic" id="writing-the-validation-business-logic">Writing the validation business logic</a></h3>
<p>It's time to write the actual validation code. This is defined inside of the
<code>src/lib.rs</code> file. Inside of this file you will find a function called <code>validate</code>.</p>
<p>The scaffolded function is already doing something:</p>
<pre><code class="language-rust norun noplayground">fn validate(payload: &amp;[u8]) -&gt; CallResult {
    // NOTE 1
    let validation_request: ValidationRequest&lt;Settings&gt; = ValidationRequest::new(payload)?;

    // NOTE 2
    match serde_json::from_value::&lt;apicore::Pod&gt;(validation_request.request.object) {
        Ok(pod) =&gt; {
            // NOTE 3
            if pod.metadata.name == Some(&quot;invalid-pod-name&quot;.to_string()) {
                kubewarden::reject_request(
                    Some(format!(&quot;pod name {:?} is not accepted&quot;, pod.metadata.name)),
                    None,
                )
            } else {
                kubewarden::accept_request()
            }
        }
        Err(_) =&gt; {
            // NOTE 4
            // We were forwarded a request we cannot unmarshal or
            // understand, just accept it
            kubewarden::accept_request()
        }
    }
}
</code></pre>
<p>This is a walk-through the code described above:</p>
<ol>
<li>Parse the incoming <code>payload</code> into a <code>ValidationRequest&lt;Setting&gt;</code> object. This
automatically populates the <code>Settings</code> instance inside of <code>ValidationRequest</code> with
the params provided by the user.</li>
<li>Convert the Kubernetes raw JSON object embedded into the request
into an instance of the <a href="https://arnavion.github.io/k8s-openapi/v0.11.x/k8s_openapi/api/core/v1/struct.Pod.html">Pod struct</a></li>
<li>The request contains a Pod object, the code approves only the requests
that do not have <code>metadata.name</code> equal to the hard-coded value <code>invalid-pod-name</code></li>
<li>The request doesn't contain a Pod object, hence the policy accepts the request</li>
</ol>
<p>As you can see the code is already doing a validation that resembles the one we
want to implement. We just have to get rid of the hard-coded value and use the
values provided by the user via the policy settings.</p>
<p>This can be done with the following code:</p>
<pre><code class="language-rust norun noplayground">fn validate(payload: &amp;[u8]) -&gt; CallResult {
    let validation_request: ValidationRequest&lt;Settings&gt; = ValidationRequest::new(payload)?;

    match serde_json::from_value::&lt;apicore::Pod&gt;(validation_request.request.object) {
        Ok(pod) =&gt; {
            let pod_name = pod.metadata.name.unwrap_or_default();
            if validation_request
                .settings
                .invalid_names
                .contains(&amp;pod_name)
            {
                kubewarden::reject_request(
                    Some(format!(&quot;pod name {:?} is not accepted&quot;, pod_name)),
                    None,
                )
            } else {
                kubewarden::accept_request()
            }
        }
        Err(_) =&gt; {
            // We were forwarded a request we cannot unmarshal or
            // understand, just accept it
            kubewarden::accept_request()
        }
    }
}
</code></pre>
<p>Finally, we will create some unit tests to ensure the validation code works as
expected.</p>
<p>The <code>lib.rs</code> file has already some tests defined at the bottom of the file, as
you can see Kubewarden's Rust SDK provides some test helpers too.</p>
<p>Moreover, the scaffolded project already ships with some default
<a href="https://en.wikipedia.org/wiki/Test_fixture#Software">test fixtures</a> inside of
the <code>test_data</code> directory. We are going to take advantage of these recorded
admission requests to write our unit tests.</p>
<p>Change the contents of the test section inside of <code>src/lib.rs</code> to look like that:</p>
<pre><code class="language-rust norun noplayground">#[cfg(test)]
mod tests {
    use super::*;

    use kubewarden_policy_sdk::test::Testcase;
    use std::collections::HashSet;

    #[test]
    fn accept_pod_with_valid_name() -&gt; Result&lt;(), ()&gt; {
        let mut invalid_names = HashSet::new();
        invalid_names.insert(String::from(&quot;bad_name1&quot;));
        let settings = Settings { invalid_names };

        let request_file = &quot;test_data/pod_creation.json&quot;;
        let tc = Testcase {
            name: String::from(&quot;Pod creation with valid name&quot;),
            fixture_file: String::from(request_file),
            expected_validation_result: true,
            settings,
        };

        let res = tc.eval(validate).unwrap();
        assert!(
            res.mutated_object.is_none(),
            &quot;Something mutated with test case: {}&quot;,
            tc.name,
        );

        Ok(())
    }

    #[test]
    fn reject_pod_with_invalid_name() -&gt; Result&lt;(), ()&gt; {
        let mut invalid_names = HashSet::new();
        invalid_names.insert(String::from(&quot;nginx&quot;));
        let settings = Settings { invalid_names };

        let request_file = &quot;test_data/pod_creation.json&quot;;
        let tc = Testcase {
            name: String::from(&quot;Pod creation with invalid name&quot;),
            fixture_file: String::from(request_file),
            expected_validation_result: false,
            settings,
        };

        let res = tc.eval(validate).unwrap();
        assert!(
            res.mutated_object.is_none(),
            &quot;Something mutated with test case: {}&quot;,
            tc.name,
        );

        Ok(())
    }

    #[test]
    fn accept_request_with_non_pod_resource() -&gt; Result&lt;(), ()&gt; {
        let mut invalid_names = HashSet::new();
        invalid_names.insert(String::from(&quot;prod&quot;));
        let settings = Settings { invalid_names };

        let request_file = &quot;test_data/ingress_creation.json&quot;;
        let tc = Testcase {
            name: String::from(&quot;Ingress creation&quot;),
            fixture_file: String::from(request_file),
            expected_validation_result: true,
            settings,
        };

        let res = tc.eval(validate).unwrap();
        assert!(
            res.mutated_object.is_none(),
            &quot;Something mutated with test case: {}&quot;,
            tc.name,
        );

        Ok(())
    }
}
</code></pre>
<p>We now have three unit tests defined inside of this file:</p>
<ul>
<li><code>accept_pod_with_valid_name</code>: ensures a Pod with a valid
name is accepted</li>
<li><code>reject_pod_with_invalid_name</code>: ensures a Pod with an invalid
name is rejected</li>
<li><code>accept_request_with_non_pod_resource</code>: ensure the policy accepts
request that do not have a <code>Pod</code> as object</li>
</ul>
<p>We can run the unit tests again:</p>
<pre><code class="language-shell">$ cargo test
   Compiling demo v0.1.0 (/home/flavio/hacking/kubernetes/kubewarden/demo)
    Finished test [unoptimized + debuginfo] target(s) in 3.45s
     Running target/debug/deps/demo-24670dd6a538fd72

running 5 tests
test settings::tests::accept_settings_with_a_list_of_invalid_names ... ok
test settings::tests::reject_settings_without_a_list_of_invalid_names ... ok
test tests::accept_request_with_non_pod_resource ... ok
test tests::accept_pod_with_valid_name ... ok
test tests::reject_pod_with_invalid_name ... ok

test result: ok. 5 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s
</code></pre>
<p>That's all if you want to write a simple validating policy.</p>
<h2><a class="header" href="#creating-a-new-mutation-policy" id="creating-a-new-mutation-policy">Creating a new mutation policy</a></h2>
<p>Mutating policies are similar to validating ones, but have also the ability to mutate an
incoming object.</p>
<p>They can:</p>
<ul>
<li>Reject a request</li>
<li>Accept a request without doing any change to the incoming object</li>
<li>Mutate the incoming object as they like and accept the request</li>
</ul>
<p>Writing a Kubewarden mutation policies is extremely simple. We will use the validating
policy created inside of the previous steps and, with very few changes, turn it into a
mutating one.</p>
<p>Our policy will use the same validation logic defined before, but it will also add
an annotation to all the Pods that have a valid name.</p>
<p>Attempting to create a Pod like that:</p>
<pre><code class="language-yaml">apiVersion: v1
kind: Pod
metadata:
  name: nginx
spec:
  containers:
    - name: nginx
      image: nginx:latest
</code></pre>
<p>Will lead to the creation of this Pod:</p>
<pre><code class="language-yaml">apiVersion: v1
kind: Pod
metadata:
  name: nginx
  annotations:
    kubewarden.policy.demo/inspected: true
spec:
  containers:
    - name: nginx
      image: nginx:latest
</code></pre>
<h3><a class="header" href="#write-the-mutation-code" id="write-the-mutation-code">Write the mutation code</a></h3>
<p>The mutation code is done inside of the <code>validate</code> function. The function should be changed
to approve the request via the <a href="https://docs.rs/kubewarden-policy-sdk/0.1.0/kubewarden_policy_sdk/fn.mutate_request.html"><code>mutate_request</code></a>
instead of the <a href="https://docs.rs/kubewarden-policy-sdk/0.1.0/kubewarden_policy_sdk/fn.accept_request.html"><code>accept_request</code></a>.</p>
<p>This is how the <code>validate</code> function has to look like:</p>
<pre><code class="language-rust norun noplayground">fn validate(payload: &amp;[u8]) -&gt; CallResult {
    let validation_request: ValidationRequest&lt;Settings&gt; = ValidationRequest::new(payload)?;

    match serde_json::from_value::&lt;apicore::Pod&gt;(validation_request.request.object) {
        // NOTE 1
        Ok(mut pod) =&gt; {
            let pod_name = pod.metadata.name.clone().unwrap_or_default();
            if validation_request
                .settings
                .invalid_names
                .contains(&amp;pod_name)
            {
                kubewarden::reject_request(
                    Some(format!(&quot;pod name {:?} is not accepted&quot;, pod_name)),
                    None,
                )
            } else {
                // NOTE 2
                let mut new_annotations = pod.metadata.annotations.clone().unwrap_or_default();
                new_annotations.insert(
                    String::from(&quot;kubewarden.policy.demo/inspected&quot;),
                    String::from(&quot;true&quot;),
                );
                pod.metadata.annotations = Some(new_annotations);

                // NOTE 3
                let mutated_object = serde_json::to_value(pod)?;
                kubewarden::mutate_request(&amp;mutated_object)
            }
        }
        Err(_) =&gt; {
            // We were forwarded a request we cannot unmarshal or
            // understand, just accept it
            kubewarden::accept_request()
        }
    }
}
</code></pre>
<p>Compared to the previous code, we made only three changes:</p>
<ol>
<li>We defined the <code>pod</code> object as mutable, see the <code>mut</code> keyword. This is
needed because we will extend its <code>metadata.annotations</code> attribute</li>
<li>This is the actual code that takes the existing <code>annotations</code>, adds the
new one, and finally puts the updated <code>annotations</code> object back into the original
<code>pod</code> instance</li>
<li>Serialize the <code>pod</code> object into a generic <code>serde_json::Value</code> and then return
a mutation response</li>
</ol>
<p>Having done these changes, it's time to run the unit tests again:</p>
<pre><code class="language-shell">$ cargo test
   Compiling demo v0.1.0 (/home/flavio/hacking/kubernetes/kubewarden/demo)
    Finished test [unoptimized + debuginfo] target(s) in 4.53s
     Running target/debug/deps/demo-24670dd6a538fd72

running 5 tests
test settings::tests::reject_settings_without_a_list_of_invalid_names ... ok
test settings::tests::accept_settings_with_a_list_of_invalid_names ... ok
test tests::reject_pod_with_invalid_name ... ok
test tests::accept_pod_with_valid_name ... FAILED
test tests::accept_request_with_non_pod_resource ... ok

failures:

---- tests::accept_pod_with_valid_name stdout ----
thread 'tests::accept_pod_with_valid_name' panicked at 'Something mutated with test case: Pod creation with valid name', src/lib.rs:74:9
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace


failures:
    tests::accept_pod_with_valid_name

test result: FAILED. 4 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s
</code></pre>
<p>As you can see, the <code>accept_pod_with_valid_name</code> fails because the response actually
contains a mutated object. It looks like our code is actually working!</p>
<p>Let's update the <code>accept_pod_with_valid_name</code> to look like that:</p>
<pre><code class="language-rust norun noplayground">#[test]
fn accept_pod_with_valid_name() -&gt; Result&lt;(), ()&gt; {
    let mut invalid_names = HashSet::new();
    invalid_names.insert(String::from(&quot;bad_name1&quot;));
    let settings = Settings { invalid_names };

    let request_file = &quot;test_data/pod_creation.json&quot;;
    let tc = Testcase {
        name: String::from(&quot;Pod creation with valid name&quot;),
        fixture_file: String::from(request_file),
        expected_validation_result: true,
        settings,
    };

    let res = tc.eval(validate).unwrap();
    // NOTE 1
    assert!(
        res.mutated_object.is_some(),
        &quot;Expected accepted object to be mutated&quot;,
    );

    // NOTE 2
    let final_pod =
        serde_json::from_str::&lt;apicore::Pod&gt;(res.mutated_object.unwrap().as_str()).unwrap();
    let final_annotations = final_pod.metadata.annotations.unwrap();
    assert_eq!(
        final_annotations.get_key_value(&quot;kubewarden.policy.demo/inspected&quot;),
        Some((
            &amp;String::from(&quot;kubewarden.policy.demo/inspected&quot;),
            &amp;String::from(&quot;true&quot;)
        )),
    );

    Ok(())
}
</code></pre>
<p>Compared to the initial test, we made only two changes:</p>
<ol>
<li>Change the <code>assert!</code> statement to ensure the request is still accepted,
but it also includes a mutated object</li>
<li>Created a <code>Pod</code> instance starting from the mutated object that is part of
the response. Assert the mutated Pod object contains the right
<code>metadata.annotations</code>.</li>
</ol>
<p>We can run the tests again, this time all of them will pass:</p>
<pre><code class="language-shell">$ cargo test
   Compiling demo v0.1.0 (/home/flavio/hacking/kubernetes/kubewarden/demo)
    Finished test [unoptimized + debuginfo] target(s) in 2.61s
     Running target/debug/deps/demo-24670dd6a538fd72

running 5 tests
test settings::tests::reject_settings_without_a_list_of_invalid_names ... ok
test settings::tests::accept_settings_with_a_list_of_invalid_names ... ok
test tests::accept_request_with_non_pod_resource ... ok
test tests::reject_pod_with_invalid_name ... ok
test tests::accept_pod_with_valid_name ... ok

test result: ok. 5 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s
</code></pre>
<p>As you can see the creation of a mutation policy is pretty straightforward.</p>
<h2><a class="header" href="#building-the-policy" id="building-the-policy">Building the policy</a></h2>
<p>So far we have built the policy using as a compilation target the same operating
system and architecture of our development machine.</p>
<p>It's now time to build the policy as a WebAssembly binary, also known as <code>.wasm</code>
file.</p>
<p>This can be done with a simple command:</p>
<pre><code class="language-shell">make build
</code></pre>
<p>This command will build the code in release mode, with WebAssembly as
compilation target.</p>
<p>The build will produce the following file:</p>
<pre><code class="language-shell">$ file target/wasm32-unknown-unknown/release/demo.wasm
target/wasm32-unknown-unknown/release/demo.wasm: WebAssembly (wasm) binary module version 0x1 (MVP)
</code></pre>
<h2><a class="header" href="#distributing-the-policy" id="distributing-the-policy">Distributing the policy</a></h2>
<p>This topic is covered inside of the <a href="writing-policies//distributing-policies.html">&quot;distributing policies&quot;</a>
section of Kubewarden's documentation.</p>
<h2><a class="header" href="#more-examples" id="more-examples">More examples</a></h2>
<p>You can find more Kubewarden policies written in Rust inside of Kubewarden's
GitHub space. <a href="https://github.com/search?l=Rust&amp;q=topic%3Apolicy-as-code+org%3Akubewarden&amp;type=Repositories">This query</a>
can help you find them.</p>
<p><strong>Worth of note:</strong> these repositories have a series of GitHub Actions that automate
the following tasks:</p>
<ul>
<li>Run unit tests and code linting on pull requests and after code is merged
into the main branch</li>
<li>Build the policy in <code>release</code> mode and push it to a OCI registry as an
artifact</li>
</ul>
<h1><a class="header" href="#distributing-policies" id="distributing-policies">Distributing Policies</a></h1>
<p>Kubewarden policies are Wasm binaries that are evaluated by the
Kubewarden Policy Server.</p>
<p>The Kubewarden policy server can load policies from these
sources:</p>
<ul>
<li>Local filesystem</li>
<li>HTTP(s) server</li>
<li>OCI compliant registry like <a href="https://github.com/distribution/distribution">distribution</a>
and other container registries (GitHub container registry, Azure Container
Registry, Amazon ECR, Google Container Registry, ...)</li>
</ul>
<p>We think distributing Kubewarden policies via a regular OCI compliant
registry is the best choice. Container registries are basically a
mandatory requirement for any Kubernetes cluster. Having a single
place to store, and secure, all the artifacts required by a cluster
can be really handy.</p>
<h1><a class="header" href="#pushing-policies-to-an-oci-compliant-registry" id="pushing-policies-to-an-oci-compliant-registry">Pushing policies to an OCI compliant registry</a></h1>
<p>The <a href="https://github.com/opencontainers/artifacts">OCI Artifacts</a>
specification allows to store any kind of binary blob inside of a
regular OCI compliant container registry.</p>
<p>The target OCI compliant registry <strong>must support artifacts</strong> in order
to successfully push a Kubewarden Policy to it.</p>
<p>The <a href="https://github.com/engineerd/wasm-to-oci"><code>wasm-to-oci</code></a> command line tool
can be used to push a Kubewarden Policy to an OCI compliant registry.</p>
<p>Pushing a policy can be done in this way:</p>
<pre><code class="language-bash">$ wasm-to-oci push pod-runtime-class-policy.wasm \
              &lt;oci-registry&gt;/kubewarden-policies/pod-runtime-class-policy:v0.0.1
</code></pre>
<p>The policy can then be referenced from the Kubewarden Policy Server as
<code>registry://&lt;oci-registry&gt;/kubewarden-policies/pod-runtime-class-policy:v0.0.1</code>.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>
