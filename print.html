<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Kubewarden Kubernetes Policy Engine</title>
        
        <meta name="robots" content="noindex" />
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="Documentation of Kubewarden project">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        
        <link rel="icon" href="favicon.svg">
        
        
        <link rel="shortcut icon" href="favicon.png">
        
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        
        <link rel="stylesheet" href="css/print.css" media="print">
        

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="introduction.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="quick-start.html"><strong aria-hidden="true">2.</strong> Quick Start</a></li><li class="chapter-item expanded "><a href="architecture.html"><strong aria-hidden="true">3.</strong> Architecture</a></li><li class="chapter-item expanded "><a href="writing-policies/index.html"><strong aria-hidden="true">4.</strong> Writing Policies</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="writing-policies/spec/01-intro.html"><strong aria-hidden="true">4.1.</strong> Policy Specification</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="writing-policies/spec/02-settings.html"><strong aria-hidden="true">4.1.1.</strong> Settings</a></li><li class="chapter-item expanded "><a href="writing-policies/spec/03-validating-policies.html"><strong aria-hidden="true">4.1.2.</strong> Validating policies</a></li><li class="chapter-item expanded "><a href="writing-policies/spec/04-mutating-policies.html"><strong aria-hidden="true">4.1.3.</strong> Mutating policies</a></li><li class="chapter-item expanded "><a href="writing-policies/spec/05-context-aware-policies.html"><strong aria-hidden="true">4.1.4.</strong> Context aware policies</a></li></ol></li><li class="chapter-item expanded "><a href="writing-policies/rust/01-intro.html"><strong aria-hidden="true">4.2.</strong> Rust</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="writing-policies/rust/02-create-policy.html"><strong aria-hidden="true">4.2.1.</strong> Create a new policy</a></li><li class="chapter-item expanded "><a href="writing-policies/rust/03-define-policy-settings.html"><strong aria-hidden="true">4.2.2.</strong> Define policy settings</a></li><li class="chapter-item expanded "><a href="writing-policies/rust/04-write-validation-logic.html"><strong aria-hidden="true">4.2.3.</strong> Write the validation logic</a></li><li class="chapter-item expanded "><a href="writing-policies/rust/05-mutation-policy.html"><strong aria-hidden="true">4.2.4.</strong> Write a mutation policy</a></li><li class="chapter-item expanded "><a href="writing-policies/rust/06-build-and-distribute.html"><strong aria-hidden="true">4.2.5.</strong> Build and distribute</a></li></ol></li><li class="chapter-item expanded "><a href="writing-policies/go/01-intro.html"><strong aria-hidden="true">4.3.</strong> Go</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="writing-policies/go/02-scaffold.html"><strong aria-hidden="true">4.3.1.</strong> Create a new policy</a></li><li class="chapter-item expanded "><a href="writing-policies/go/03-policy-settings.html"><strong aria-hidden="true">4.3.2.</strong> Define policy settings</a></li><li class="chapter-item expanded "><a href="writing-policies/go/04-validation.html"><strong aria-hidden="true">4.3.3.</strong> Write the validation logic</a></li><li class="chapter-item expanded "><a href="writing-policies/go/05-e2e-tests.html"><strong aria-hidden="true">4.3.4.</strong> End-to-end testing</a></li><li class="chapter-item expanded "><a href="writing-policies/go/06-automate.html"><strong aria-hidden="true">4.3.5.</strong> GitHub Action integration</a></li><li class="chapter-item expanded "><a href="writing-policies/go/07-distribute.html"><strong aria-hidden="true">4.3.6.</strong> Distribute policy</a></li></ol></li><li class="chapter-item expanded "><a href="writing-policies/swift.html"><strong aria-hidden="true">4.4.</strong> Swift</a></li><li class="chapter-item expanded "><a href="writing-policies/typescript.html"><strong aria-hidden="true">4.5.</strong> TypeScript</a></li></ol></li><li class="chapter-item expanded "><a href="distributing-policies.html"><strong aria-hidden="true">5.</strong> Distributing Policies</a></li><li class="chapter-item expanded "><a href="testing-policies/01-intro.html"><strong aria-hidden="true">6.</strong> Testing Policies</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="testing-policies/02-policy-authors.html"><strong aria-hidden="true">6.1.</strong> While creating a policy</a></li><li class="chapter-item expanded "><a href="testing-policies/03-cluster-operators.html"><strong aria-hidden="true">6.2.</strong> Before deployment</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">Kubewarden Kubernetes Policy Engine</h1>

                    <div class="right-buttons">
                        
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                        
                        <a href="https://github.com/kubewarden/docs" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        
                        

                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <blockquote>
<p><strong>WARNING:</strong> Kubewarden is in early development stage, it's not production ready.</p>
<p>Feedback is highly appreciated.</p>
</blockquote>
<h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p>Kubewarden is a <a href="https://kubernetes.io/docs/reference/access-authn-authz/extensible-admission-controllers/">Kubernetes Dynamic Admission
Controller</a>
that validates incoming requests using policies written in
WebAssembly.</p>
<h2 id="what-is-webassembly"><a class="header" href="#what-is-webassembly">What is WebAssembly?</a></h2>
<p>As stated on <a href="https://webassembly.org/">WebAssembly's official
website</a>:</p>
<blockquote>
<p>WebAssembly (abbreviated Wasm) is a binary instruction format for a
stack-based virtual machine. Wasm is designed as a portable
compilation target for programming languages, enabling deployment on
the web for client and server applications.</p>
</blockquote>
<p>WebAssembly has been originally conceived as an &quot;extension&quot; of
browsers. However, recent efforts have been made by the WebAssembly
community to allow the execution of WebAssembly code outside of
browsers.</p>
<h2 id="why-use-webassembly"><a class="header" href="#why-use-webassembly">Why use WebAssembly?</a></h2>
<p>By using WebAssembly, users can write Kubernetes policies using their
favorite programming language, as long as the language can produce
Wasm binaries.</p>
<p>Policy authors can reuse their skills, tools and best
practices. Policies are &quot;traditional&quot; programs that can have reusable
blocks (regular libraries), can be tested, can be linted, can be
plugged into their current CI and CD workflows,...</p>
<p>Wasm modules are portable, once built they can run on any kind of
processor architecture and Operating System. A policy built on a Apple
Silicon machine can be run on a x86_64 Linux server without any
conversion.</p>
<h2 id="policy-distribution"><a class="header" href="#policy-distribution">Policy distribution</a></h2>
<p>Kubewarden Policies can be served by a regular web server or, even
better, can be published inside of an OCI compliant registry.</p>
<p>Kubewarden Policies can be stored inside of an OCI compliant registry as
<a href="https://github.com/opencontainers/artifacts">OCI artifacts</a>.</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="quick-start"><a class="header" href="#quick-start">Quick Start</a></h1>
<p>The Kubewarden stack is made of the following components:</p>
<ul>
<li>An arbitrary number of <code>ClusterAdmissionPolicy</code> resources: this is how policies
are defined inside of Kubernetes</li>
<li>A Deployment of Kubewarden <code>policy-server</code>: this component loads all the
policies defined by the administrators and evaluates them</li>
<li>A Deployment of <code>kubewarden-controller</code>: this is the controller
that monitors the <code>ClusterAdmissionPolicy</code> resources and interacts
with the Kubewarden <code>policy-server</code></li>
</ul>
<h2 id="install"><a class="header" href="#install">Install</a></h2>
<p>The Kubewarden stack can be deployed using a helm chart:</p>
<pre><code class="language-console">helm repo add kubewarden https://charts.kubewarden.io
helm install --namespace kubewarden --create-namespace kubewarden-controller kubewarden/kubewarden-controller
</code></pre>
<p>This will install <code>kubewarden-controller</code> on the Kubernetes cluster in
the default configuration and will register the
<code>ClusterAdmissionPolicy</code> Custom Resource. The components of the
Kubewarden stack will be deployed inside of a Kubernetes Namespace
called <code>kubewarden</code>.</p>
<p>The default configuration values should be good enough for the majority of
deployments, all the options are documented <a href="https://charts.kubewarden.io/#configuration">here</a>.</p>
<p>The Kubewarden Policy Server is completely managed by the kubewarden-controller.</p>
<h2 id="kubewarden-policies"><a class="header" href="#kubewarden-policies">Kubewarden Policies</a></h2>
<p>Enforcing policies is by far the most common operation a Kubernetes
administrator will perform. You can declare as many policies as you want,
targeting any kind of Kubernetes resource and type of operation that can be
done against them.</p>
<p>The <code>ClusterAdmissionPolicy</code> resource is the core of the Kubewarden stack: this is
how validating policies are defined.</p>
<pre><code class="language-yaml">apiVersion: policies.kubewarden.io/v1alpha2
kind: ClusterAdmissionPolicy
metadata:
  name: psp-capabilities
spec:
  module: registry://ghcr.io/kubewarden/policies/psp-capabilities:v0.1.3
  rules:
  - apiGroups: [&quot;&quot;]
    apiVersions: [&quot;v1&quot;]
    resources: [&quot;pods&quot;]
    operations:
    - CREATE
    - UPDATE
  mutating: true
  settings:
    allowed_capabilities:
    - CHOWN
    required_drop_capabilities:
    - NET_ADMIN
</code></pre>
<p>This is a quick overview of the attributes of the <code>ClusterAdmissionPolicy</code> resource:</p>
<ul>
<li><code>module</code>: this is the location of the Kubewarden policy, several schemas are
supported.
<ul>
<li><code>registry</code>: download from an <a href="https://github.com/opencontainers/artifacts">OCI artifacts</a>
compliant container registry</li>
<li><code>http</code>, <code>https</code>: download from a regular HTTP(s) server</li>
<li><code>file</code>: load the module from the local filesystem</li>
</ul>
</li>
<li><code>resources</code>: types of resources evaluated by the policy</li>
<li><code>operations</code>: what operations for the previously given types should
be forwarded to this admission policy by the API server for
evaluation.</li>
<li><code>mutating</code>: a boolean value that must be set to <code>true</code> for policies that can
mutate incoming requests.</li>
<li><code>settings</code> (optional): a free-form object that contains the policy
configuration values.</li>
<li><code>failurePolicy</code> (optional): how unrecognized errors and timeout errors from
the policy are handled. Allowed values are <code>Ignore</code> or <code>Fail</code>. <code>Ignore</code> means
that an error calling the webhook is ignored and the API request is allowed
to continue. <code>Fail</code> means that an error calling the webhook causes the
admission to fail and the API request to be rejected.
The default behaviour is <code>Fail</code>.</li>
</ul>
<p>The complete documentation of this Custom Resource can be found
<a href="https://github.com/kubewarden/kubewarden-controller/blob/main/docs/crds/README.asciidoc">here</a>
or on
<a href="https://doc.crds.dev/github.com/kubewarden/kubewarden-controller">docs.crds.dev</a>.</p>
<blockquote>
<p><strong>NOTE:</strong> ClusterAdmissionPolicy resources are registered with a <code>*</code> webhook
<code>scope</code>, which means that registered webhooks will be forwarded all
requests matching the given <code>resources</code> and <code>operations</code> -- either
namespaced (in any namespace), or cluster-wide resources.</p>
</blockquote>
<blockquote>
<p><strong>NOTE:</strong> The <code>ClusterAdmissionPolicy</code> resource is cluster-wide. There are
plans to also provide a namespaced version that will only impact
registered namespaced resources on its own namespace.</p>
</blockquote>
<h2 id="enforce-your-first-policy"><a class="header" href="#enforce-your-first-policy">Enforce your first policy</a></h2>
<p>We will use the <a href="https://github.com/kubewarden/pod-privileged-policy"><code>pod-privileged</code> policy</a>.
This policy prevents the creation of privileged containers inside of a Kubernetes cluster.</p>
<p>Let's define a <code>ClusterAdmissionPolicy</code> for that:</p>
<pre><code class="language-shell">kubectl apply -f - &lt;&lt;EOF
apiVersion: policies.kubewarden.io/v1alpha2
kind: ClusterAdmissionPolicy
metadata:
  name: privileged-pods
spec:
  module: registry://ghcr.io/kubewarden/policies/pod-privileged:v0.1.5
  rules:
  - apiGroups: [&quot;&quot;]
    apiVersions: [&quot;v1&quot;]
    resources: [&quot;pods&quot;]
    operations:
    - CREATE
    - UPDATE
  mutating: false
EOF
</code></pre>
<p>This will produce the following output:
<code>clusteradmissionpolicy.policies.kubewarden.io/privileged-pods created</code></p>
<p>Defining the <code>ClusterAdmissionPolicy</code> will lead to a rollout of the Kubewarden Policy
Server Deployment. Once the new policy is ready to be served, the <code>kubewarden-controller</code>
will register a <a href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.20/#validatingwebhookconfiguration-v1-admissionregistration-k8s-io">ValidatingWebhookConfiguration</a>
object.</p>
<p>Once all the instances of <code>policy-server</code> are ready, the
<code>ValidatingWebhookConfiguration</code> can be shown with:</p>
<pre><code class="language-shell">kubectl get validatingwebhookconfigurations.admissionregistration.k8s.io -l kubewarden
</code></pre>
<p>Which will output something like</p>
<pre><code>NAME              WEBHOOKS   AGE
privileged-pods   1          9s
</code></pre>
<p>Let's try to create a Pod with no privileged containers:</p>
<pre><code class="language-shell">kubectl apply -f - &lt;&lt;EOF
apiVersion: v1
kind: Pod
metadata:
  name: unprivileged-pod
spec:
  containers:
    - name: nginx
      image: nginx:latest
EOF
</code></pre>
<p>This will produce the following output, which means the Pod was successfully
created:</p>
<p><code>pod/unprivileged-pod created</code></p>
<p>Now, let's try to create a pod with at least one privileged container:</p>
<pre><code class="language-shell">kubectl apply -f - &lt;&lt;EOF
apiVersion: v1
kind: Pod
metadata:
  name: privileged-pod
spec:
  containers:
    - name: nginx
      image: nginx:latest
      securityContext:
          privileged: true
EOF
</code></pre>
<p>This time the creation of the Pod will be blocked, with the following message:</p>
<pre><code>Error from server: error when creating &quot;STDIN&quot;: admission webhook &quot;privileged-pods.kubewarden.admission&quot; denied the request: User 'minikube-user' cannot schedule privileged containers
</code></pre>
<h2 id="uninstall"><a class="header" href="#uninstall">Uninstall</a></h2>
<p>As a first step remove all the <code>ClusterAdmissionPolicy</code> resources you have created.
This can be done with the following command:</p>
<pre><code class="language-shell">kubectl delete --all clusteradmissionpolicies.policies.kubewarden.io
</code></pre>
<p>Then wait for the for the <code>kubewarden-controller</code> to remove all the
Kubernetes <code>ValidatingWebhookConfiguration</code> and the <code>MutatingWebhookConfiguration</code>
resources it created.</p>
<p>This can be monitored with the following command:</p>
<pre><code class="language-shell">kubectl get validatingwebhookconfigurations.admissionregistration.k8s.io -l &quot;kubewarden&quot; &amp;&amp; \
kubectl get mutatingwebhookconfigurations.admissionregistration.k8s.io -l &quot;kubewarden&quot;
</code></pre>
<p>If these resources are not automatically removed, you can do
remove them manually by using the following command:</p>
<pre><code class="language-shell">kubectl delete -l &quot;kubewarden&quot; validatingwebhookconfigurations.admissionregistration.k8s.io &amp;&amp; \
kubectl delete -l &quot;kubewarden&quot; mutatingwebhookconfigurations.admissionregistration.k8s.io
</code></pre>
<p>Finally you can uninstall the Helm chart:</p>
<pre><code class="language-shell">helm uninstall kubewarden-controller
</code></pre>
<p>Once this is done you can remove the Kubernetes namespace that was used to deploy
the Kubewarden stack:</p>
<pre><code class="language-shell">kubectl delete namespace kubewarden
</code></pre>
<p>This will delete all the resources that were created at runtime by the <code>kubewarden-controller</code>,
like the <code>policy-server</code> Deployment.</p>
<blockquote>
<p><strong>Note well:</strong> it's extremely important to remove the <code>ValidatingWebhookConfiguration</code>
and <code>MutatingWebhookConfiguration</code> resources <strong>before</strong> the
<code>policy-server</code> Deployment. Otherwise the Kubernetes
API server will continuously face timeout errors while trying to evaluate the
incoming requests.</p>
<p>By default the <code>ValidatingWebhookConfiguration</code> and <code>MutatingWebhookConfiguration</code>
resources created by Kubewarden have <code>policyFailure</code>
set to <code>Fail</code>, which will cause all these incoming requests to be rejected.</p>
<p><strong>This could bring havoc on your cluster.</strong></p>
</blockquote>
<h2 id="wrapping-up"><a class="header" href="#wrapping-up">Wrapping up</a></h2>
<p>As we have seen, the <code>ClusterAdmissionPolicy</code> resource is the core type that
a cluster operator has to manage, the rest of the resources needed to
run the policies and configure them will be taken care of
automatically by the <code>kubewarden-controller</code> project.</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="architecture"><a class="header" href="#architecture">Architecture</a></h1>
<p>Kubewarden is a Kubernetes policy engine that uses policies written using
WebAssembly.</p>
<p>The Kubewarden stack is made by the following components:</p>
<ul>
<li>
<p>Kubewarden Custom Resources: these are <a href="https://kubernetes.io/docs/concepts/extend-kubernetes/api-extension/custom-resources/">Kubernetes Custom Resources</a>
that simplify the process of managing policies.</p>
</li>
<li>
<p><a href="https://github.com/kubewarden/kubewarden-controller"><code>kubewarden-controller</code></a>:
this is a Kubernetes controller that reconciles Kubewarden's Custom Resources.
This component creates parts of the Kubewarden stack and, most important of
all, translates Kubewarden's concepts into native Kubernetes directives.</p>
</li>
<li>
<p>Kubewarden policies: these are WebAssembly modules that hold the validation
or mutation logic. These are covered in depth inside of <a href="/writing-policies/index.html">this chapter</a>.</p>
</li>
<li>
<p><a href="https://github.com/kubewarden/policy-server"><code>policy-server</code></a>:
this component receives the requests to be validated. It does that
by executing Kubewarden's policies.</p>
</li>
</ul>
<p>At the bottom of the stack, Kubewarden's integrates with Kubernetes using the
concept of <a href="https://kubernetes.io/docs/reference/access-authn-authz/extensible-admission-controllers/">Dynamic Admission Control</a>.
In particular, Kubewarden operates as a Kubernetes Admission Webhook.
<code>policy-server</code> is the actual Webhook endpoint that is reached by Kubernetes
API server to validate relevant requests.</p>
<p>Kubernetes is made aware of the existence of Kubewarden's Webhook endpoints by
<code>kubewarden-controller</code>. This is done by registering either
a <code>MutatingWebhookConfiguration</code> or a <code>ValidatingWebhookConfiguration</code>
object.</p>
<p>This diagram shows the full architecture overview of a cluster running
the Kubewarden stack:</p>
<p><img src="/images/architecture.png" alt="Full architecture" /></p>
<h2 id="journey-of-a-kubewarden-policy"><a class="header" href="#journey-of-a-kubewarden-policy">Journey of a Kubewarden policy</a></h2>
<p>The architecture diagram from above can be intimidating at first, this
section explains it step by step.</p>
<h3 id="defining-the-first-policy"><a class="header" href="#defining-the-first-policy">Defining the first policy</a></h3>
<p>On a fresh new cluster, the only Kubewarden components defined are its Custom
Resources and the <code>kubewarden-controller</code> Deployment.</p>
<p>This chart shows what happens when the first policy is defined inside of the
cluster:</p>
<p><img src="/images/architecture_sequence_01.png" alt="Defining the first ClusterAdmissionPolicy resource" /></p>
<p><code>kubewarden-controller</code> notices the new <code>ClusterAdmissionPolicy</code> resource and,
as a result of that, it initializes the <code>policy-server</code> component.</p>
<p>As stated above, Kubewarden works as a Kubernetes Admission Webhook. Kubernetes
dictates that all the Webhook endpoints must be secured with TLS.
<code>kubewarden-controller</code> takes care of setting up this secure communication
by doing these steps:</p>
<ol>
<li>Generate a self-signed Certificate Authority</li>
<li>Use this CA to generate a TLS certificate and a TLS key for the
<code>policy-server</code> Service.</li>
</ol>
<p>All these objects are stored into Kubernetes as Secret resources.</p>
<p><code>kubewarden-controller</code> then creates a ConfigMap that
holds the configuration of <code>policy-server</code>. This configuration includes
the policy defined inside of the <code>ClusterAdmissionPolicy</code> resource.</p>
<p>Finally, <code>kubewarden-controller</code> will create the <code>policy-server</code>
Deployment and a Kubernetes ClusterIP Service to expose it inside of
the cluster network.</p>
<h3 id="initialization-of-policy-server"><a class="header" href="#initialization-of-policy-server">Initialization of <code>policy-server</code></a></h3>
<p>At start time, <code>policy-server</code> reads its configuration and downloads
all the Kubewarden policies. Policies can be downloaded from remote
endpoints like HTTP(s) servers and container registries.</p>
<p>Policies' behaviour can be tuned by users via policy-specific configuration
parameters. Once all the policies are downloaded, <code>policy-server</code> will ensure
the policy settings provided by the user are valid.</p>
<p><code>policy-server</code> performs the validation of policies's settings by
invoking the <code>validate_setting</code> function exposed by each policy.
This topic is covered more in depth inside
of <a href="/writing-policies/spec/01-intro.html">this section</a> of the documentation.</p>
<p><code>policy-server</code> will exit with an error if one or more policies received wrong
configuration parameters from the end user.</p>
<p>If all the policies are properly configured, <code>policy-server</code> will spawn a
pool of worker threads to evaluate incoming requests using the Kubewarden
policies specified by the user.</p>
<p>Finally, <code>policy-server</code> will start a HTTPS server that listens to incoming
validation requests. The web server is secured using the TLS key and certificate
that have been previously created by <code>kubewarden-controller</code>.</p>
<p>Each policy is exposed by the web server via a dedicated path that follows this
naming convention: <code>/validate/&lt;policy ID&gt;</code>.</p>
<p>This is how the cluster looks like once the initialization of <code>policy-server</code>
is completed:</p>
<p><img src="/images/architecture_sequence_02.png" alt="policy-server initialized" /></p>
<h3 id="making-kubernetes-aware-of-the-policy"><a class="header" href="#making-kubernetes-aware-of-the-policy">Making Kubernetes aware of the policy</a></h3>
<p>The <code>policy-server</code> Pods have a
<a href="https://kubernetes.io/docs/tasks/configure-pod-container/configure-liveness-readiness-startup-probes/"><code>Readiness Probe</code></a>,
<code>kubewarden-controller</code> relies on that to know when the <code>policy-server</code> Deployment
is ready to evaluate admission reviews.</p>
<p>Once the <code>policy-server</code> Deployed is marked as <code>Ready</code>, <code>kubewarden-controller</code>
will make the Kubernetes API server aware of the new policy by creating either a
<code>MutatingWebhookConfiguration</code> or a <code>ValidatingWebhookConfiguration</code>
object.</p>
<p>Each policy has its dedicated <code>MutatingWebhookConfiguration</code>/<code>ValidatingWebhookConfiguration</code>
which points to the Webhook endpoint served by <code>policy-server</code>. The endpoint
is reachable by the <code>/validate/&lt;policy ID&gt;</code> URL mentioned before.</p>
<p><img src="/images/architecture_sequence_03.png" alt="Kubernetes Webhook endpoint configuration" /></p>
<h3 id="policy-in-action"><a class="header" href="#policy-in-action">Policy in action</a></h3>
<p>Now that all the plumbing has been done, Kubernetes will start sending the
relevant Admission Review requests to the right <code>policy-server</code> endpoint.</p>
<p><img src="/images/architecture_sequence_04.png" alt="Policy in action" /></p>
<p><code>policy-server</code> receives the Admission Request object and, based on the
endpoint that received the request, uses the right policy to evaluate it.</p>
<p>Each policy is evaluated inside of its own dedicated WebAssembly sandbox.
The communication between <code>policy-server</code> (the &quot;host&quot;) and the WebAssembly
policy (the &quot;guest&quot;) is done using the waPC communication protocol. This is
covered in depth inside of <a href="/writing-policies/index.html">this</a>
section of the documentation.</p>
<h2 id="how-multiple-policies-are-handled"><a class="header" href="#how-multiple-policies-are-handled">How multiple policies are handled</a></h2>
<p>A cluster can have multiple Kubewarden policies defined. This leads
back to the initial diagram:</p>
<p><img src="/images/architecture.png" alt="Full architecture" /></p>
<p>Each policy is defined via its own <code>ClusterAdmissionPolicy</code> resource. All of
them are loaded by the same instance of <code>policy-server</code>.</p>
<p><code>policy-server</code> defines multiple validation endpoints, one per policy defined
inside of its configuration file. It's also possible to load the same policy
multiple times, just with different configuration parameters.</p>
<p>The Kubernetes API server is made aware of these policy via the
<code>ValidatingWebhookConfiguration</code> and <code>MutatingWebhookConfiguration</code> resources
that are kept in sync by <code>kubewarden-controller</code>.</p>
<p>Finally, the incoming admission requests are then dispatched by the Kubernetes
API server to the right validation endpoint exposed by <code>policy-server</code>.</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="what-is-a-kubewarden-policy"><a class="header" href="#what-is-a-kubewarden-policy">What is a Kubewarden policy</a></h1>
<p>In this section we will explain what Kubewarden policies are by using some traditional computing
analogies.</p>
<p>A Kubewarden policy can be seen as a regular program that does one job: it receives
input data, performs some computation against that and it finally returns a response.</p>
<p>The input data are Kubernetes admission requests and the result of the computation
is a validation response, something that tells to Kubernetes whether to accept, reject or
mutate the original input data.</p>
<p>All these operations are performed by a component of Kubewarden that is called
<a href="https://github.com/kubewarden/policy-server">policy-server</a>.</p>
<p>The policy server doesn't bundle any data processing capability. All these capabilities are
added at runtime via add-ons: the Kubewarden policies.</p>
<p>As a consequence, a Kubewarden policy can be seen as a <a href="https://en.wikipedia.org/wiki/Plug-in_%28computing%29">traditional plug-in</a>
of the &quot;policy server&quot; program.</p>
<p>To recap:</p>
<ul>
<li>Kubewarden policies are plug-ins that expose a set of well-defined
functionalities (validate a Kubernetes request object, validate policy settings
provided by the user,...) using a well-defined API</li>
<li>Policy server is the &quot;main&quot; program that loads the plug-ins
(aka policies) and leverages their exposed functionalities to validate or mutate
Kubernetes requests</li>
</ul>
<p>Writing Kubewarden policies consists of writing the validation business logic
and then exposing it through a well-defined API.</p>
<h1 id="programming-language-requirements"><a class="header" href="#programming-language-requirements">Programming language requirements</a></h1>
<p>Kubewarden policies are delivered as <a href="https://webassembly.org/">WebAssembly</a>
binaries.</p>
<p>Policy authors can write policies using any programming language that supports
WebAssembly as a compilation target. The list of supported language is constantly
evolving, <a href="https://github.com/appcypher/awesome-wasm-langs">this page</a>
provides a nice overview of the WebAssembly landscape.</p>
<p>Currently WebAssembly doesn't have an official way to share complex data types
between the host and a WebAssembly guest. To overcome this limitation
Kubewarden policies leverage the <a href="https://github.com/wapc">waPC</a> project, which
provides a bi-directional communication channel.</p>
<p>Because of that your programming language of choice must provide a waPC guest SDK.
If that's not the case, feel free to reach out. We can help you overcome this
limitation.</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="policy-communication-specification"><a class="header" href="#policy-communication-specification">Policy communication specification</a></h1>
<p>The policy evaluator interacts with Kubewarden policies using a well defined API.
The purpose of this section is to document the API used by the host (
be it <code>policy-server</code> or <code>policy-testdrive</code>) to communicate with Kubewarden's
policies.</p>
<blockquote>
<p><strong>Note well:</strong> this section of the documentation is a bit low level, you can
jump straight to one of the &quot;language focused&quot; chapters and come back to this
chapter later.</p>
</blockquote>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="policy-settings"><a class="header" href="#policy-settings">Policy settings</a></h1>
<p>Policy behaviour is not set in stone, it can be configured by providing configuration
details to the policy at runtime. The policy author has full freedom to define
the structure of the policy settings.</p>
<p>Kubewarden takes care of serializing the policy settings into JSON and provide
them to the policy every time it is invoked.</p>
<h2 id="settings-validation"><a class="header" href="#settings-validation">Settings validation</a></h2>
<p>Some policies might want to validate the settings a user provides to ensure
they are correct.</p>
<p>Each policy must register a waPC function called <code>validate_settings</code> that
takes care of validating the policy settings.</p>
<p>The <code>validate_settings</code> function receives as input a JSON representation of
the settings provided by the user. The function validates them and returns
as a response a <code>SettingsValidationResponse</code> object.</p>
<p>The structure of the <code>SettingsValidationResponse</code> object is the following one:</p>
<pre><code class="language-json">{
  // mandatory
  &quot;valid&quot;: &lt;boolean&gt;,

  // optional, ignored if accepted - recommended for rejections
  &quot;message&quot;: &lt;string&gt;,
}
</code></pre>
<p>If the user provided settings are <code>valid</code>, the contents of <code>message</code> are ignored.
Otherwise the contents of <code>message</code> are shown to the user.</p>
<blockquote>
<p><strong>Note well:</strong> Kubewarden's <a href="https://github.com/chimera-kube/policy-server">policy-server</a>
validates all the policy settings provided by users at start time.
The policy-server exits immediately with an error if at least one of its
policies received wrong configuration parameters.</p>
</blockquote>
<h2 id="example"><a class="header" href="#example">Example</a></h2>
<p>Let's take as an example the <a href="https://github.com/kubewarden/psp-capabilities">psp-capabilities</a>
policy which has the following configuration format:</p>
<pre><code class="language-yaml">allowed_capabilities:
- CHOWN

required_drop_capabilities:
- NET_ADMIN

default_add_capabilities:
- KILL
</code></pre>
<p>The <code>validate_settings</code> function will receive as input the following JSON
document:</p>
<pre><code class="language-json">{
  &quot;allowed_capabilities&quot;: [
    &quot;CHOWN&quot;
  ],
  &quot;required_drop_capabilities&quot;: [
    &quot;NET_ADMIN&quot;
  ],
  &quot;default_add_capabilities&quot;: [
    &quot;KILL&quot;
  ]
}
</code></pre>
<h1 id="recap"><a class="header" href="#recap">Recap</a></h1>
<p>Each policy must register a waPC function called <code>validate_settings</code> that has
the following API:</p>
<table>
  <thead>
    <tr>
      <th>waPC function name</th>
      <th>Input payload</th>
      <th>Output payload</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>validate_settings</code></td>
      <td>
<pre>
{
  // your policy configuration
}
</pre>
      </td>
      <td>
<pre>
{
  // <strong>mandatory</strong>
  "validate": &lt;boolean&gt;,<br>
  // optional, ignored if accepted
  // recommended for rejections
  "message": &lt;string&gt;,
}
</pre>
      </td>
    </tr>
  </tbody>
</table>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="validating-policies"><a class="header" href="#validating-policies">Validating policies</a></h1>
<p>The Kubewarden policy server receives
<a href="https://godoc.org/k8s.io/api/admission/v1#AdmissionReview"><code>AdmissionReview</code></a>
objects from the Kubernetes API server. It then forwards the value of
its <code>request</code> attribute (of type
<a href="https://godoc.org/k8s.io/api/admission/v1#AdmissionRequest"><code>AdmissionRequest</code></a>
key to the policy to be evaluated.</p>
<p>The policy has to evaluate the <code>request</code> and state whether it should be
accepted or not. When the request is rejected, the policy might provide the
explanation message and a specific error code that is going to be shown to the end user.</p>
<p>By convention of the <code>policy-server</code> project, the guest has to expose
a function named <code>validate</code>, exposed through the waPC guest SDK, so
that the <code>policy-server</code> (waPC host) can invoke it.</p>
<p>The <code>validate</code> function receives a <code>ValidationRequest</code> object serialized as JSON and
returns a <code>ValidationResponse</code> object serialized as JSON.</p>
<h2 id="the-validationrequest-object"><a class="header" href="#the-validationrequest-object">The <code>ValidationRequest</code> object</a></h2>
<p>The <code>ValidationRequest</code> is a simple JSON object that is received by the
<code>validate</code> function. It looks like this:</p>
<pre><code class="language-json">{
  &quot;request&quot;: &lt;AdmissionReview.request data&gt;,
  &quot;settings&quot;: {
     // your policy configuration
  }
}
</code></pre>
<p>The <code>settings</code> key points to a free-form JSON document that can hold the policy
specific settings. The previous chapter focused on policies and settings.</p>
<h3 id="a-concrete-example"><a class="header" href="#a-concrete-example">A concrete example</a></h3>
<p>Given the following Kubernetes <code>AdmissionReview</code>:</p>
<pre><code class="language-json">{
  &quot;apiVersion&quot;: &quot;admission.k8s.io/v1&quot;,
  &quot;kind&quot;: &quot;AdmissionReview&quot;,
  &quot;request&quot;: {
    # Random uid uniquely identifying this admission call
    &quot;uid&quot;: &quot;705ab4f5-6393-11e8-b7cc-42010a800002&quot;,

    # Fully-qualified group/version/kind of the incoming object
    &quot;kind&quot;: {&quot;group&quot;:&quot;autoscaling&quot;,&quot;version&quot;:&quot;v1&quot;,&quot;kind&quot;:&quot;Scale&quot;},
    # Fully-qualified group/version/kind of the resource being modified
    &quot;resource&quot;: {&quot;group&quot;:&quot;apps&quot;,&quot;version&quot;:&quot;v1&quot;,&quot;resource&quot;:&quot;deployments&quot;},
    # subresource, if the request is to a subresource
    &quot;subResource&quot;: &quot;scale&quot;,

    # Fully-qualified group/version/kind of the incoming object in the original request to the API server.
    # This only differs from `kind` if the webhook specified `matchPolicy: Equivalent` and the
    # original request to the API server was converted to a version the webhook registered for.
    &quot;requestKind&quot;: {&quot;group&quot;:&quot;autoscaling&quot;,&quot;version&quot;:&quot;v1&quot;,&quot;kind&quot;:&quot;Scale&quot;},
    # Fully-qualified group/version/kind of the resource being modified in the original request to the API server.
    # This only differs from `resource` if the webhook specified `matchPolicy: Equivalent` and the
    # original request to the API server was converted to a version the webhook registered for.
    &quot;requestResource&quot;: {&quot;group&quot;:&quot;apps&quot;,&quot;version&quot;:&quot;v1&quot;,&quot;resource&quot;:&quot;deployments&quot;},
    # subresource, if the request is to a subresource
    # This only differs from `subResource` if the webhook specified `matchPolicy: Equivalent` and the
    # original request to the API server was converted to a version the webhook registered for.
    &quot;requestSubResource&quot;: &quot;scale&quot;,

    # Name of the resource being modified
    &quot;name&quot;: &quot;my-deployment&quot;,
    # Namespace of the resource being modified, if the resource is namespaced (or is a Namespace object)
    &quot;namespace&quot;: &quot;my-namespace&quot;,

    # operation can be CREATE, UPDATE, DELETE, or CONNECT
    &quot;operation&quot;: &quot;UPDATE&quot;,

    &quot;userInfo&quot;: {
      # Username of the authenticated user making the request to the API server
      &quot;username&quot;: &quot;admin&quot;,
      # UID of the authenticated user making the request to the API server
      &quot;uid&quot;: &quot;014fbff9a07c&quot;,
      # Group memberships of the authenticated user making the request to the API server
      &quot;groups&quot;: [&quot;system:authenticated&quot;,&quot;my-admin-group&quot;],
      # Arbitrary extra info associated with the user making the request to the API server.
      # This is populated by the API server authentication layer and should be included
      # if any SubjectAccessReview checks are performed by the webhook.
      &quot;extra&quot;: {
        &quot;some-key&quot;:[&quot;some-value1&quot;, &quot;some-value2&quot;]
      }
    },

    # object is the new object being admitted.
    # It is null for DELETE operations.
    &quot;object&quot;: {&quot;apiVersion&quot;:&quot;autoscaling/v1&quot;,&quot;kind&quot;:&quot;Scale&quot;,...},
    # oldObject is the existing object.
    # It is null for CREATE and CONNECT operations.
    &quot;oldObject&quot;: {&quot;apiVersion&quot;:&quot;autoscaling/v1&quot;,&quot;kind&quot;:&quot;Scale&quot;,...},
    # options contains the options for the operation being admitted, like meta.k8s.io/v1 CreateOptions, UpdateOptions, or DeleteOptions.
    # It is null for CONNECT operations.
    &quot;options&quot;: {&quot;apiVersion&quot;:&quot;meta.k8s.io/v1&quot;,&quot;kind&quot;:&quot;UpdateOptions&quot;,...},

    # dryRun indicates the API request is running in dry run mode and will not be persisted.
    # Webhooks with side effects should avoid actuating those side effects when dryRun is true.
    # See http://k8s.io/docs/reference/using-api/api-concepts/#make-a-dry-run-request for more details.
    &quot;dryRun&quot;: false
  }
}
</code></pre>
<p>The <code>ValidationRequest</code> object would look like that:</p>
<pre><code class="language-json">{
  &quot;request&quot;: {
    # Random uid uniquely identifying this admission call
    &quot;uid&quot;: &quot;705ab4f5-6393-11e8-b7cc-42010a800002&quot;,

    # Fully-qualified group/version/kind of the incoming object
    &quot;kind&quot;: {&quot;group&quot;:&quot;autoscaling&quot;,&quot;version&quot;:&quot;v1&quot;,&quot;kind&quot;:&quot;Scale&quot;},
    # Fully-qualified group/version/kind of the resource being modified
    &quot;resource&quot;: {&quot;group&quot;:&quot;apps&quot;,&quot;version&quot;:&quot;v1&quot;,&quot;resource&quot;:&quot;deployments&quot;},
    # subresource, if the request is to a subresource
    &quot;subResource&quot;: &quot;scale&quot;,

    # Fully-qualified group/version/kind of the incoming object in the original request to the API server.
    # This only differs from `kind` if the webhook specified `matchPolicy: Equivalent` and the
    # original request to the API server was converted to a version the webhook registered for.
    &quot;requestKind&quot;: {&quot;group&quot;:&quot;autoscaling&quot;,&quot;version&quot;:&quot;v1&quot;,&quot;kind&quot;:&quot;Scale&quot;},
    # Fully-qualified group/version/kind of the resource being modified in the original request to the API server.
    # This only differs from `resource` if the webhook specified `matchPolicy: Equivalent` and the
    # original request to the API server was converted to a version the webhook registered for.
    &quot;requestResource&quot;: {&quot;group&quot;:&quot;apps&quot;,&quot;version&quot;:&quot;v1&quot;,&quot;resource&quot;:&quot;deployments&quot;},
    # subresource, if the request is to a subresource
    # This only differs from `subResource` if the webhook specified `matchPolicy: Equivalent` and the
    # original request to the API server was converted to a version the webhook registered for.
    &quot;requestSubResource&quot;: &quot;scale&quot;,

    # Name of the resource being modified
    &quot;name&quot;: &quot;my-deployment&quot;,
    # Namespace of the resource being modified, if the resource is namespaced (or is a Namespace object)
    &quot;namespace&quot;: &quot;my-namespace&quot;,

    # operation can be CREATE, UPDATE, DELETE, or CONNECT
    &quot;operation&quot;: &quot;UPDATE&quot;,

    &quot;userInfo&quot;: {
      # Username of the authenticated user making the request to the API server
      &quot;username&quot;: &quot;admin&quot;,
      # UID of the authenticated user making the request to the API server
      &quot;uid&quot;: &quot;014fbff9a07c&quot;,
      # Group memberships of the authenticated user making the request to the API server
      &quot;groups&quot;: [&quot;system:authenticated&quot;,&quot;my-admin-group&quot;],
      # Arbitrary extra info associated with the user making the request to the API server.
      # This is populated by the API server authentication layer and should be included
      # if any SubjectAccessReview checks are performed by the webhook.
      &quot;extra&quot;: {
        &quot;some-key&quot;:[&quot;some-value1&quot;, &quot;some-value2&quot;]
      }
    },

    # object is the new object being admitted.
    # It is null for DELETE operations.
    &quot;object&quot;: {&quot;apiVersion&quot;:&quot;autoscaling/v1&quot;,&quot;kind&quot;:&quot;Scale&quot;,...},
    # oldObject is the existing object.
    # It is null for CREATE and CONNECT operations.
    &quot;oldObject&quot;: {&quot;apiVersion&quot;:&quot;autoscaling/v1&quot;,&quot;kind&quot;:&quot;Scale&quot;,...},
    # options contains the options for the operation being admitted, like meta.k8s.io/v1 CreateOptions, UpdateOptions, or DeleteOptions.
    # It is null for CONNECT operations.
    &quot;options&quot;: {&quot;apiVersion&quot;:&quot;meta.k8s.io/v1&quot;,&quot;kind&quot;:&quot;UpdateOptions&quot;,...},

    # dryRun indicates the API request is running in dry run mode and will not be persisted.
    # Webhooks with side effects should avoid actuating those side effects when dryRun is true.
    # See http://k8s.io/docs/reference/using-api/api-concepts/#make-a-dry-run-request for more details.
    &quot;dryRun&quot;: false
  },
  &quot;settings&quot;: {
    # policy settings
  }
}
</code></pre>
<h2 id="the-validationresponse-object"><a class="header" href="#the-validationresponse-object">The <code>ValidationResponse</code> object</a></h2>
<p>The <code>validate</code> function returns the outcome of its validation using a <code>ValidationResponse</code>
object.</p>
<p>The <code>ValidationResponse</code> is structured in the following way:</p>
<pre><code class="language-json">{
  // mandatory
  &quot;accepted&quot;: &lt;boolean&gt;,

  // optional, ignored if accepted - recommended for rejections
  &quot;message&quot;: &lt;string&gt;,

  // optional, ignored if accepted
  &quot;code&quot;: &lt;integer&gt;,

  // optional, used by mutation policies
  &quot;mutated_object&quot;: &lt;string&gt;
}
</code></pre>
<p>The <code>message</code> and <code>code</code> attributes can be specified when the request
is not accepted. <code>message</code> is a free form textual error. <code>code</code>
represents an HTTP error code.</p>
<p>If the request is accepted, <code>message</code> and <code>code</code>
values will be ignored by the Kubernetes API server if they are
present.</p>
<p>If <code>message</code> or <code>code</code> are provided, and the request is not
accepted, the Kubernetes API server will forward this information as
part of the body of the error returned to the Kubernetes API server
client that issued the rejected request.</p>
<p>The <code>mutated_object</code> is an optional field used only by mutating policies.
This is going to be covered inside of the next chapter.</p>
<h1 id="recap-1"><a class="header" href="#recap-1">Recap</a></h1>
<p>These are the functions a validating policy must implement:</p>
<table>
  <thead>
    <tr>
      <th>waPC function name</th>
      <th>Input payload</th>
      <th>Output payload</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>validate</code></td>
      <td>
<pre>
{
  "request": {
    // AdmissionReview.request data
  },
  "settings": {
    // your policy configuration
  }
}
</pre>
      </td>
      <td>
<pre>
{
  // <strong>mandatory</strong>
  "accepted": &lt;boolean&gt;,<br>
  // optional, ignored if accepted
  //recommended for rejections
  "message": &lt;string&gt;,<br>
  // optional, ignored if accepted
  "code": &lt;integer&gt;
}
</pre>
      </td>
    </tr>
    <tr>
      <td><code>validate_settings</code></td>
      <td>
<pre>
{
  // your policy configuration
}
</pre>
      </td>
      <td>
<pre>
{
  // <strong>mandatory</strong>
  "validate": &lt;boolean&gt;,<br>
  // optional, ignored if accepted
  // recommended for rejections
  "message": &lt;string&gt;,
}
</pre>
      </td>
    </tr>
  </tbody>
</table>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="mutating-policies"><a class="header" href="#mutating-policies">Mutating policies</a></h1>
<p>Mutation policies are structured in the very same was as validating ones:</p>
<ul>
<li>They have to register a <code>validate</code> and a <code>validate_settings</code> waPC functions</li>
<li>The communication API used between the host and the policy is the very same
as the one used by validating policies.</li>
</ul>
<p>Mutating policies can accept a request and propose a mutation of the incoming
object by returning a <code>ValidationResponse</code> object that looks like that:</p>
<pre><code class="language-json">```json
{
  &quot;accepted&quot;: true,
  &quot;mutated_object&quot;: &lt;object to be created&gt;
}
</code></pre>
<p>The <code>mutated_object</code> field contains the object the policy wants to be created
inside of the Kubernetes cluster serialized to JSON.</p>
<h2 id="a-concrete-example-1"><a class="header" href="#a-concrete-example-1">A concrete example</a></h2>
<p>Let's assume the policy received <code>ValidationRequest</code>:</p>
<pre><code class="language-json">{
  &quot;settings&quot;: {},
  &quot;request&quot;: {
    &quot;operation&quot;: &quot;CREATE&quot;,
    &quot;object&quot;: {
      &quot;apiVersion&quot;: &quot;v1&quot;,
      &quot;kind&quot;: &quot;Pod&quot;,
      &quot;metadata&quot;: {
        &quot;name&quot;: &quot;security-context-demo-4&quot;
      },
      &quot;spec&quot;: {
        &quot;containers&quot;: [
        {
          &quot;name&quot;: &quot;sec-ctx-4&quot;,
          &quot;image&quot;: &quot;gcr.io/google-samples/node-hello:1.0&quot;,
          &quot;securityContext&quot;: {
            &quot;capabilities&quot;: {
              &quot;add&quot;: [&quot;NET_ADMIN&quot;, &quot;SYS_TIME&quot;]
            }
          }
        }
        ]
      }
    }
  }
}
</code></pre>
<blockquote>
<p><strong>Note well:</strong> we left some irrelevant fields out of the <code>request</code> object.</p>
</blockquote>
<p>This request is generated because someone tried to create a Pod that would
look like that:</p>
<pre><code class="language-yaml">apiVersion: v1
kind: Pod
metadata:
  name: security-context-demo-4
spec:
  containers:
  - name: sec-ctx-4
    image: gcr.io/google-samples/node-hello:1.0
    securityContext:
      capabilities:
        add:
        - NET_ADMIN
        - SYS_TIME
</code></pre>
<p>Let's assume our policy replies with the following <code>ValidationResponse</code>:</p>
<pre><code class="language-json">{
  &quot;accepted&quot;: true,
  &quot;mutated_object&quot;: {
    &quot;apiVersion&quot;: &quot;v1&quot;,
    &quot;kind&quot;: &quot;Pod&quot;,
    &quot;metadata&quot;: {
      &quot;name&quot;: &quot;security-context-demo-4&quot;
    },
    &quot;spec&quot;: {
      &quot;containers&quot;: [
        {
          &quot;name&quot;: &quot;sec-ctx-4&quot;,
          &quot;image&quot;: &quot;gcr.io/google-samples/node-hello:1.0&quot;,
          &quot;securityContext&quot;: {
            &quot;capabilities&quot;: {
              &quot;add&quot;: [
                &quot;NET_ADMIN&quot;,
                &quot;SYS_TIME&quot;
              ],
              &quot;drop&quot;: [
                &quot;BPF&quot;
              ]
            }
          }
        }
      ]
    }
  }
}
</code></pre>
<p>That would lead to the request being accepted, but the final Pod would look like
that:</p>
<pre><code class="language-yaml">apiVersion: v1
kind: Pod
metadata:
  name: security-context-demo-4
spec:
  containers:
  - name: sec-ctx-4
    image: gcr.io/google-samples/node-hello:1.0
    securityContext:
      capabilities:
        add:
        - NET_ADMIN
        - SYS_TIME
        drop:
        - BPF
</code></pre>
<p>As you can see the policy altered the <code>securityContext.capabilities.drop</code>
section of the only container declared inside of the Pod.</p>
<p>The container is now dropping the <code>BPF</code> capability thanks to our policy.</p>
<h1 id="recap-2"><a class="header" href="#recap-2">Recap</a></h1>
<p>These are the functions a mutating policy must implement:</p>
<table>
  <thead>
    <tr>
      <th>waPC function name</th>
      <th>Input payload</th>
      <th>Output payload</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>validate</code></td>
      <td>
<pre>
{
  "request": {
    // AdmissionReview.request data
  },
  "settings": {
    // your policy configuration
  }
}
</pre>
      </td>
      <td>
<pre>
{
  // <strong>mandatory</strong>
  "accepted": &lt;boolean&gt;,<br>
  // optional, ignored if accepted
  //recommended for rejections
  "message": &lt;string&gt;,<br>
  // optional, ignored if accepted
  "code": &lt;integer&gt;, <br>
  // JSON Object to be created
  // Can be used only when the request is accepted
  "mutated_object": &lt;object&gt;
}
</pre>
      </td>
    </tr>
    <tr>
      <td><code>validate_settings</code></td>
      <td>
<pre>
{
  // your policy configuration
}
</pre>
      </td>
      <td>
<pre>
{
  // <strong>mandatory</strong>
  "validate": &lt;boolean&gt;,<br>
  // optional, ignored if accepted
  // recommended for rejections
  "message": &lt;string&gt;,
}
</pre>
      </td>
    </tr>
  </tbody>
</table>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="context-aware-policies"><a class="header" href="#context-aware-policies">Context aware policies</a></h1>
<blockquote>
<p><strong>NOTE:</strong> This feature is a work in progress, and not to be depended
upon. Features described here are incomplete and subject to change
at any time until the feature stabilizes.</p>
<p>Feedback is highly appreciated.</p>
</blockquote>
<p>The <code>policy-server</code> has capabilities to expose cluster information to
policies, so that they can take decisions based on other existing
resources, and not only based on the resource they are evaluated in
isolation.</p>
<p>The <code>policy-server</code> being a deployment, is deployed on the Kubernetes
cluster with a specific service account, that is able to list and
watch a subset of Kubernetes resources, meaning:</p>
<ul>
<li>Namespaces</li>
<li>Services</li>
<li>Ingresses</li>
</ul>
<p>This information is exposed to policies (waPC guests) through a
well known procedure call set of endpoints, that allows to retrieve
this cached information.</p>
<p>The result of these procedure calls is the JSON-encoded result of the
list of resources, as provided by Kubernetes.</p>
<p>The <code>policy-server</code> will be the component responsible for refreshing
this information when it considers, and the policy always retrieves
the latest available information exposed by the <code>policy-server</code>.</p>
<h2 id="accessing-the-cluster-context"><a class="header" href="#accessing-the-cluster-context">Accessing the cluster context</a></h2>
<p>Language SDK's that support cluster context at this time will expose
functions that allow policies to retrieve the current state of the
cluster.</p>
<p>The workflow we have seen until now has been that the policy exposes
well known waPC functions, namely: <code>validate</code> and
<code>validate_settings</code>. At some point, the host will call these functions
when it requires either to validate a request, or to validate the
settings that were provided to it for the given policy.</p>
<p>In this case, after the host calls to the <code>validate</code> waPC function in
the guest, the guest is able to retrieve cluster information in order
to produce a response to the <code>validate</code> waPC function that was called
by the host on the guest.</p>
<p>This guest-host intercommunication is performed using the regular waPC
host calling mechanism, and so any guest implementing the waPC
intercommunication mechanism is able to request this information from
the host.</p>
<p>waPC has the following function arguments when performing a call from
the guest to the host:</p>
<ul>
<li>Binding</li>
<li>Namespace</li>
<li>Operation</li>
<li>Payload</li>
</ul>
<p>By contract, or convention, policies can retrieve the Kubernetes
cluster information by calling the host in the following ways:</p>
<table>
  <thead>
    <tr>
      <th>Binding</th>
      <th>Namespace</th>
      <th>Operation</th>
      <th>Input payload</th>
      <th>Output payload (JSON format)</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>kubernetes</code></td>
      <td><code>ingresses</code></td>
      <td><code>list</code></td>
      <td>N/A</td>
      <td>Result of <code>GET /apis/networking.k8s.io/v1/ingresses</code></td>
    </tr>
    <tr>
      <td><code>kubernetes</code></td>
      <td><code>namespaces</code></td>
      <td><code>list</code></td>
      <td>N/A</td>
      <td>Result of <code>GET /apis/v1/namespaces</code></td>
    </tr>
    <tr>
      <td><code>kubernetes</code></td>
      <td><code>services</code></td>
      <td><code>list</code></td>
      <td>N/A</td>
      <td>Result of <code>GET /apis/v1/services</code></td>
    </tr>
  </tbody>
</table>
<p>The request the waPC guest performs to the host is local, and served
from a cache -- this request does not get forwarded to the Kubernetes
API server. The policy-server (host) decides when to refresh this
information from the Kubernetes API server.</p>
<blockquote>
<p><strong>NOTE:</strong> This is a proof-of-concept at this time, there are plans
to generalize what resources can be fetched from the cluster, to
include all built-in Kubernetes types, as well as custom resources.</p>
</blockquote>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="rust"><a class="header" href="#rust">Rust</a></h1>
<p><a href="https://www.rust-lang.org/">Rust</a> is the most mature programming language that
can generate WebAssembly modules: WebAssembly is a first-class citizen
in the Rust world. That means many of the tools and crates of the Rust
ecosystem work out of the box.</p>
<p>Kubewarden provides a <a href="https://crates.io/crates/kubewarden-policy-sdk">Rust SDK</a>
that simplifies the process of writing policies, plus a
<a href="https://github.com/kubewarden/policy-rust-template">template project</a> to
quickly scaffold a policy project using the
<a href="https://github.com/cargo-generate/cargo-generate"><code>cargo-generate</code></a> utility.</p>
<p>This document illustrates how to take advantage of these projects to write
Kubewarden policies using the Rust programming language.</p>
<p>Note well, we won't cover the details of Kubewarden's Rust SDK inside of this
page. These can be found inside of the
<a href="https://docs.rs/kubewarden-policy-sdk/0.1.0">official crate documentation</a>.</p>
<h2 id="getting-rust-dependencies"><a class="header" href="#getting-rust-dependencies">Getting Rust dependencies</a></h2>
<p>This section guides you through the process of installing the Rust compiler and
its dependencies.</p>
<p>As a first step install the Rust compiler and its tools, this can be easily done
using <a href="https://github.com/rust-lang/rustup">rustup</a>. Please follow
<a href="https://rust-lang.github.io/rustup/installation/index.html">rustup's install documentation</a>.</p>
<p>Once <code>rustup</code> is installed add the Wasm target:</p>
<pre><code class="language-shell">rustup target add wasm32-unknown-unknown
</code></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="creating-a-new-validation-policy"><a class="header" href="#creating-a-new-validation-policy">Creating a new validation policy</a></h1>
<p>We are going to create a simple validation policy that processes
Pod creation requests.</p>
<p>The policy will look at the <code>metadata.name</code> attribute of the Pod and reject
the pods that have an invalid name. We want the list of invalid names to be
configurable by the end users of the policy.</p>
<p>To summarize, the policy settings will look like that:</p>
<pre><code class="language-yaml">invalid_names:
- bad_name1
- bad_name2
</code></pre>
<p>The policy will accept the creation of a Pod like the following one:</p>
<pre><code class="language-yaml">apiVersion: v1
kind: Pod
metadata:
  name: nginx
spec:
  containers:
    - name: nginx
      image: nginx:latest
</code></pre>
<p>While it will reject the creation of a Pod like the following one:</p>
<pre><code class="language-yaml">apiVersion: v1
kind: Pod
metadata:
  name: bad_name1
spec:
  containers:
    - name: nginx
      image: nginx:latest
</code></pre>
<h2 id="scaffolding-new-policy-project"><a class="header" href="#scaffolding-new-policy-project">Scaffolding new policy project</a></h2>
<p>The creation of a new policy project can be done by feeding this
<a href="https://github.com/kubewarden/policy-rust-template">template project</a>
into <code>cargo generate</code>.</p>
<p>First, install <code>cargo-generate</code>. Note, this requires <a href="https://pkgs.org/download/openssl-devel">openssl-devel</a>.</p>
<pre><code>cargo install cargo-generate
</code></pre>
<p>Now scaffold the project as follows:</p>
<pre><code class="language-shell">cargo generate --git https://github.com/kubewarden/policy-rust-template \
               --branch main \
               --name demo
</code></pre>
<p>The command will produce the following output:</p>
<pre><code>   Creating project called `demo`...
   Done! New project created /home/flavio/hacking/kubernetes/kubewarden/demo
</code></pre>
<p>The new policy project can now be found inside of the <code>demo</code> directory.</p>
<p>Note: if you plan to make use of the GitHub container registry
functionality in the demo, you will need to
<a href="https://docs.github.com/en/packages/working-with-a-github-packages-registry/enabling-improved-container-support-with-the-container-registry#enabling-the-container-registry-for-your-personal-account">enable improved container support</a>.</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="defining-policy-settings"><a class="header" href="#defining-policy-settings">Defining policy settings</a></h1>
<p>As a first step we will define the structure that holds the policy settings.</p>
<p>Open the <code>src/settings.rs</code> file and change the definition of the <code>Settings</code>
struct to look like that:</p>
<pre><code class="language-rust norun noplayground">use std::collections::HashSet;

#[derive(Deserialize, Default, Debug, Serialize)]
pub(crate) struct Settings {
    pub invalid_names: HashSet&lt;String&gt;,
}
</code></pre>
<p>This will automatically put the list of invalid names inside of
a Set collection.</p>
<p>Next we will write a settings validation function: we want to ensure
the policy is always run with at least one invalid name.</p>
<p>This can be done by changing the implementation of the <code>Validatable</code> trait.</p>
<p>Change the scaffolded implementation defined inside of <code>src/settings.rs</code>
to look like that:</p>
<pre><code class="language-rust norun noplayground">impl kubewarden::settings::Validatable for Settings {
    fn validate(&amp;self) -&gt; Result&lt;(), String&gt; {
        if self.invalid_names.is_empty() {
            Err(String::from(&quot;No invalid name specified. Specify at least one invalid name to match&quot;))
        } else {
            Ok(())
        }
    }
}
</code></pre>
<h2 id="add-unit-tests"><a class="header" href="#add-unit-tests">Add unit tests</a></h2>
<p>Now we can write a unit test to ensure the settings validation is actually working.
This can be done in the <a href="https://doc.rust-lang.org/stable/book/ch11-00-testing.html">usual Rust way</a>.</p>
<p>There are already some default tests at the bottom of the <code>src/settings.rs</code>
file. Replace the automatically generated code to look like that:</p>
<pre><code class="language-rust norun noplayground">#[cfg(test)]
mod tests {
    use super::*;

    use kubewarden_policy_sdk::settings::Validatable;

    #[test]
    fn accept_settings_with_a_list_of_invalid_names() -&gt; Result&lt;(), ()&gt; {
        let mut invalid_names = HashSet::new();
        invalid_names.insert(String::from(&quot;bad_name1&quot;));
        invalid_names.insert(String::from(&quot;bad_name2&quot;));

        let settings = Settings { invalid_names };

        assert!(settings.validate().is_ok());
        Ok(())
    }

    #[test]
    fn reject_settings_without_a_list_of_invalid_names() -&gt; Result&lt;(), ()&gt; {
        let invalid_names = HashSet::&lt;String&gt;::new();
        let settings = Settings { invalid_names };

        assert!(settings.validate().is_err());
        Ok(())
    }
}
</code></pre>
<p>We can now run the unit tests by doing:</p>
<pre><code class="language-shell">cargo test
</code></pre>
<p>This will produce an output similar to the following one:</p>
<pre><code class="language-shell">  Compiling demo v0.1.0 (/home/flavio/hacking/kubernetes/kubewarden/demo)
    Finished test [unoptimized + debuginfo] target(s) in 4.19s
     Running target/debug/deps/demo-24670dd6a538fd72

running 2 tests
test settings::tests::accept_settings_with_a_list_of_invalid_names ... ok
test settings::tests::reject_settings_without_a_list_of_invalid_names ... ok

test result: ok. 2 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s
</code></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="writing-the-validation-logic"><a class="header" href="#writing-the-validation-logic">Writing the validation logic</a></h1>
<p>It's time to write the actual validation code. This is defined inside of the
<code>src/lib.rs</code> file. Inside of this file you will find a function called <code>validate</code>.</p>
<p>The scaffolded function is already doing something:</p>
<pre><code class="language-rust norun noplayground">fn validate(payload: &amp;[u8]) -&gt; CallResult {
    // NOTE 1
    let validation_request: ValidationRequest&lt;Settings&gt; = ValidationRequest::new(payload)?;

    // NOTE 2
    match serde_json::from_value::&lt;apicore::Pod&gt;(validation_request.request.object) {
        Ok(pod) =&gt; {
            // NOTE 3
            if pod.metadata.name == Some(&quot;invalid-pod-name&quot;.to_string()) {
                kubewarden::reject_request(
                    Some(format!(&quot;pod name {:?} is not accepted&quot;, pod.metadata.name)),
                    None,
                )
            } else {
                kubewarden::accept_request()
            }
        }
        Err(_) =&gt; {
            // NOTE 4
            // We were forwarded a request we cannot unmarshal or
            // understand, just accept it
            kubewarden::accept_request()
        }
    }
}
</code></pre>
<p>This is a walk-through the code described above:</p>
<ol>
<li>Parse the incoming <code>payload</code> into a <code>ValidationRequest&lt;Setting&gt;</code> object. This
automatically populates the <code>Settings</code> instance inside of <code>ValidationRequest</code> with
the params provided by the user.</li>
<li>Convert the Kubernetes raw JSON object embedded into the request
into an instance of the <a href="https://arnavion.github.io/k8s-openapi/v0.11.x/k8s_openapi/api/core/v1/struct.Pod.html">Pod struct</a></li>
<li>The request contains a Pod object, the code approves only the requests
that do not have <code>metadata.name</code> equal to the hard-coded value <code>invalid-pod-name</code></li>
<li>The request doesn't contain a Pod object, hence the policy accepts the request</li>
</ol>
<p>As you can see the code is already doing a validation that resembles the one we
want to implement. We just have to get rid of the hard-coded value and use the
values provided by the user via the policy settings.</p>
<p>This can be done with the following code:</p>
<pre><code class="language-rust norun noplayground">fn validate(payload: &amp;[u8]) -&gt; CallResult {
    let validation_request: ValidationRequest&lt;Settings&gt; = ValidationRequest::new(payload)?;

    match serde_json::from_value::&lt;apicore::Pod&gt;(validation_request.request.object) {
        Ok(pod) =&gt; {
            let pod_name = pod.metadata.name.unwrap_or_default();
            if validation_request
                .settings
                .invalid_names
                .contains(&amp;pod_name)
            {
                kubewarden::reject_request(
                    Some(format!(&quot;pod name {:?} is not accepted&quot;, pod_name)),
                    None,
                )
            } else {
                kubewarden::accept_request()
            }
        }
        Err(_) =&gt; {
            // We were forwarded a request we cannot unmarshal or
            // understand, just accept it
            kubewarden::accept_request()
        }
    }
}
</code></pre>
<h2 id="unit-tests"><a class="header" href="#unit-tests">Unit tests</a></h2>
<p>Finally, we will create some unit tests to ensure the validation code works as
expected.</p>
<p>The <code>lib.rs</code> file has already some tests defined at the bottom of the file, as
you can see Kubewarden's Rust SDK provides some test helpers too.</p>
<p>Moreover, the scaffolded project already ships with some default
<a href="https://en.wikipedia.org/wiki/Test_fixture#Software">test fixtures</a> inside of
the <code>test_data</code> directory. We are going to take advantage of these recorded
admission requests to write our unit tests.</p>
<p>Change the contents of the test section inside of <code>src/lib.rs</code> to look like that:</p>
<pre><code class="language-rust norun noplayground">#[cfg(test)]
mod tests {
    use super::*;

    use kubewarden_policy_sdk::test::Testcase;
    use std::collections::HashSet;

    #[test]
    fn accept_pod_with_valid_name() -&gt; Result&lt;(), ()&gt; {
        let mut invalid_names = HashSet::new();
        invalid_names.insert(String::from(&quot;bad_name1&quot;));
        let settings = Settings { invalid_names };

        let request_file = &quot;test_data/pod_creation.json&quot;;
        let tc = Testcase {
            name: String::from(&quot;Pod creation with valid name&quot;),
            fixture_file: String::from(request_file),
            expected_validation_result: true,
            settings,
        };

        let res = tc.eval(validate).unwrap();
        assert!(
            res.mutated_object.is_none(),
            &quot;Something mutated with test case: {}&quot;,
            tc.name,
        );

        Ok(())
    }

    #[test]
    fn reject_pod_with_invalid_name() -&gt; Result&lt;(), ()&gt; {
        let mut invalid_names = HashSet::new();
        invalid_names.insert(String::from(&quot;nginx&quot;));
        let settings = Settings { invalid_names };

        let request_file = &quot;test_data/pod_creation.json&quot;;
        let tc = Testcase {
            name: String::from(&quot;Pod creation with invalid name&quot;),
            fixture_file: String::from(request_file),
            expected_validation_result: false,
            settings,
        };

        let res = tc.eval(validate).unwrap();
        assert!(
            res.mutated_object.is_none(),
            &quot;Something mutated with test case: {}&quot;,
            tc.name,
        );

        Ok(())
    }

    #[test]
    fn accept_request_with_non_pod_resource() -&gt; Result&lt;(), ()&gt; {
        let mut invalid_names = HashSet::new();
        invalid_names.insert(String::from(&quot;prod&quot;));
        let settings = Settings { invalid_names };

        let request_file = &quot;test_data/ingress_creation.json&quot;;
        let tc = Testcase {
            name: String::from(&quot;Ingress creation&quot;),
            fixture_file: String::from(request_file),
            expected_validation_result: true,
            settings,
        };

        let res = tc.eval(validate).unwrap();
        assert!(
            res.mutated_object.is_none(),
            &quot;Something mutated with test case: {}&quot;,
            tc.name,
        );

        Ok(())
    }
}
</code></pre>
<p>We now have three unit tests defined inside of this file:</p>
<ul>
<li><code>accept_pod_with_valid_name</code>: ensures a Pod with a valid
name is accepted</li>
<li><code>reject_pod_with_invalid_name</code>: ensures a Pod with an invalid
name is rejected</li>
<li><code>accept_request_with_non_pod_resource</code>: ensure the policy accepts
request that do not have a <code>Pod</code> as object</li>
</ul>
<p>We can run the unit tests again:</p>
<pre><code class="language-shell">$ cargo test
   Compiling demo v0.1.0 (/home/flavio/hacking/kubernetes/kubewarden/demo)
    Finished test [unoptimized + debuginfo] target(s) in 3.45s
     Running target/debug/deps/demo-24670dd6a538fd72

running 5 tests
test settings::tests::accept_settings_with_a_list_of_invalid_names ... ok
test settings::tests::reject_settings_without_a_list_of_invalid_names ... ok
test tests::accept_request_with_non_pod_resource ... ok
test tests::accept_pod_with_valid_name ... ok
test tests::reject_pod_with_invalid_name ... ok

test result: ok. 5 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s
</code></pre>
<p>That's all if you want to write a simple validating policy.</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="creating-a-new-mutation-policy"><a class="header" href="#creating-a-new-mutation-policy">Creating a new mutation policy</a></h1>
<p>Mutating policies are similar to validating ones, but have also the ability to mutate an
incoming object.</p>
<p>They can:</p>
<ul>
<li>Reject a request</li>
<li>Accept a request without doing any change to the incoming object</li>
<li>Mutate the incoming object as they like and accept the request</li>
</ul>
<p>Writing a Kubewarden mutation policies is extremely simple. We will use the validating
policy created inside of the previous steps and, with very few changes, turn it into a
mutating one.</p>
<p>Our policy will use the same validation logic defined before, but it will also add
an annotation to all the Pods that have a valid name.</p>
<p>Attempting to create a Pod like that:</p>
<pre><code class="language-yaml">apiVersion: v1
kind: Pod
metadata:
  name: nginx
spec:
  containers:
    - name: nginx
      image: nginx:latest
</code></pre>
<p>Will lead to the creation of this Pod:</p>
<pre><code class="language-yaml">apiVersion: v1
kind: Pod
metadata:
  name: nginx
  annotations:
    kubewarden.policy.demo/inspected: true
spec:
  containers:
    - name: nginx
      image: nginx:latest
</code></pre>
<h2 id="write-the-mutation-code"><a class="header" href="#write-the-mutation-code">Write the mutation code</a></h2>
<p>The mutation code is done inside of the <code>validate</code> function. The function should be changed
to approve the request via the <a href="https://docs.rs/kubewarden-policy-sdk/0.1.0/kubewarden_policy_sdk/fn.mutate_request.html"><code>mutate_request</code></a>
instead of the <a href="https://docs.rs/kubewarden-policy-sdk/0.1.0/kubewarden_policy_sdk/fn.accept_request.html"><code>accept_request</code></a>.</p>
<p>This is how the <code>validate</code> function has to look like:</p>
<pre><code class="language-rust norun noplayground">fn validate(payload: &amp;[u8]) -&gt; CallResult {
    let validation_request: ValidationRequest&lt;Settings&gt; = ValidationRequest::new(payload)?;

    match serde_json::from_value::&lt;apicore::Pod&gt;(validation_request.request.object) {
        // NOTE 1
        Ok(mut pod) =&gt; {
            let pod_name = pod.metadata.name.clone().unwrap_or_default();
            if validation_request
                .settings
                .invalid_names
                .contains(&amp;pod_name)
            {
                kubewarden::reject_request(
                    Some(format!(&quot;pod name {:?} is not accepted&quot;, pod_name)),
                    None,
                )
            } else {
                // NOTE 2
                let mut new_annotations = pod.metadata.annotations.clone().unwrap_or_default();
                new_annotations.insert(
                    String::from(&quot;kubewarden.policy.demo/inspected&quot;),
                    String::from(&quot;true&quot;),
                );
                pod.metadata.annotations = Some(new_annotations);

                // NOTE 3
                let mutated_object = serde_json::to_value(pod)?;
                kubewarden::mutate_request(&amp;mutated_object)
            }
        }
        Err(_) =&gt; {
            // We were forwarded a request we cannot unmarshal or
            // understand, just accept it
            kubewarden::accept_request()
        }
    }
}
</code></pre>
<p>Compared to the previous code, we made only three changes:</p>
<ol>
<li>We defined the <code>pod</code> object as mutable, see the <code>mut</code> keyword. This is
needed because we will extend its <code>metadata.annotations</code> attribute</li>
<li>This is the actual code that takes the existing <code>annotations</code>, adds the
new one, and finally puts the updated <code>annotations</code> object back into the original
<code>pod</code> instance</li>
<li>Serialize the <code>pod</code> object into a generic <code>serde_json::Value</code> and then return
a mutation response</li>
</ol>
<p>Having done these changes, it's time to run the unit tests again:</p>
<pre><code class="language-shell">$ cargo test
   Compiling demo v0.1.0 (/home/flavio/hacking/kubernetes/kubewarden/demo)
    Finished test [unoptimized + debuginfo] target(s) in 4.53s
     Running target/debug/deps/demo-24670dd6a538fd72

running 5 tests
test settings::tests::reject_settings_without_a_list_of_invalid_names ... ok
test settings::tests::accept_settings_with_a_list_of_invalid_names ... ok
test tests::reject_pod_with_invalid_name ... ok
test tests::accept_pod_with_valid_name ... FAILED
test tests::accept_request_with_non_pod_resource ... ok

failures:

---- tests::accept_pod_with_valid_name stdout ----
thread 'tests::accept_pod_with_valid_name' panicked at 'Something mutated with test case: Pod creation with valid name', src/lib.rs:74:9
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace


failures:
    tests::accept_pod_with_valid_name

test result: FAILED. 4 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s
</code></pre>
<p>As you can see, the <code>accept_pod_with_valid_name</code> fails because the response actually
contains a mutated object. It looks like our code is actually working!</p>
<h2 id="update-the-unit-tests"><a class="header" href="#update-the-unit-tests">Update the unit tests</a></h2>
<p>Let's update the <code>accept_pod_with_valid_name</code> to look like that:</p>
<pre><code class="language-rust norun noplayground">#[test]
fn accept_pod_with_valid_name() -&gt; Result&lt;(), ()&gt; {
    let mut invalid_names = HashSet::new();
    invalid_names.insert(String::from(&quot;bad_name1&quot;));
    let settings = Settings { invalid_names };

    let request_file = &quot;test_data/pod_creation.json&quot;;
    let tc = Testcase {
        name: String::from(&quot;Pod creation with valid name&quot;),
        fixture_file: String::from(request_file),
        expected_validation_result: true,
        settings,
    };

    let res = tc.eval(validate).unwrap();
    // NOTE 1
    assert!(
        res.mutated_object.is_some(),
        &quot;Expected accepted object to be mutated&quot;,
    );

    // NOTE 2
    let final_pod =
        serde_json::from_str::&lt;apicore::Pod&gt;(res.mutated_object.unwrap().as_str()).unwrap();
    let final_annotations = final_pod.metadata.annotations.unwrap();
    assert_eq!(
        final_annotations.get_key_value(&quot;kubewarden.policy.demo/inspected&quot;),
        Some((
            &amp;String::from(&quot;kubewarden.policy.demo/inspected&quot;),
            &amp;String::from(&quot;true&quot;)
        )),
    );

    Ok(())
}
</code></pre>
<p>Compared to the initial test, we made only two changes:</p>
<ol>
<li>Change the <code>assert!</code> statement to ensure the request is still accepted,
but it also includes a mutated object</li>
<li>Created a <code>Pod</code> instance starting from the mutated object that is part of
the response. Assert the mutated Pod object contains the right
<code>metadata.annotations</code>.</li>
</ol>
<p>We can run the tests again, this time all of them will pass:</p>
<pre><code class="language-shell">$ cargo test
   Compiling demo v0.1.0 (/home/flavio/hacking/kubernetes/kubewarden/demo)
    Finished test [unoptimized + debuginfo] target(s) in 2.61s
     Running target/debug/deps/demo-24670dd6a538fd72

running 5 tests
test settings::tests::reject_settings_without_a_list_of_invalid_names ... ok
test settings::tests::accept_settings_with_a_list_of_invalid_names ... ok
test tests::accept_request_with_non_pod_resource ... ok
test tests::reject_pod_with_invalid_name ... ok
test tests::accept_pod_with_valid_name ... ok

test result: ok. 5 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s
</code></pre>
<p>As you can see the creation of a mutation policy is pretty straightforward.</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h2 id="building-the-policy"><a class="header" href="#building-the-policy">Building the policy</a></h2>
<p>So far we have built the policy using as a compilation target the same operating
system and architecture of our development machine.</p>
<p>It's now time to build the policy as a WebAssembly binary, also known as <code>.wasm</code>
file.</p>
<p>This can be done with a simple command:</p>
<pre><code class="language-shell">make build
</code></pre>
<p>This command will build the code in release mode, with WebAssembly as
compilation target.</p>
<p>The build will produce the following file:</p>
<pre><code class="language-shell">$ file target/wasm32-unknown-unknown/release/demo.wasm
target/wasm32-unknown-unknown/release/demo.wasm: WebAssembly (wasm) binary module version 0x1 (MVP)
</code></pre>
<h2 id="distributing-the-policy"><a class="header" href="#distributing-the-policy">Distributing the policy</a></h2>
<p>This topic is covered inside of the <a href="writing-policies/rust//distributing-policies.html">&quot;distributing policies&quot;</a>
section of Kubewarden's documentation.</p>
<h2 id="more-examples"><a class="header" href="#more-examples">More examples</a></h2>
<p>You can find more Kubewarden policies written in Rust inside of Kubewarden's
GitHub space. <a href="https://github.com/search?l=Rust&amp;q=topic%3Apolicy-as-code+org%3Akubewarden&amp;type=Repositories">This query</a>
can help you find them.</p>
<p><strong>Worth of note:</strong> these repositories have a series of GitHub Actions that automate
the following tasks:</p>
<ul>
<li>Run unit tests and code linting on pull requests and after code is merged
into the main branch</li>
<li>Build the policy in <code>release</code> mode and push it to a OCI registry as an
artifact</li>
</ul>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><blockquote>
<p><strong>Note well:</strong> Go's support for WebAssembly is fast evolving. The contents
of this page have been written during April 2021, hence they could be outdated.</p>
</blockquote>
<h1 id="go"><a class="header" href="#go">Go</a></h1>
<p>Currently the official Go compiler cannot produce WebAssembly binaries
that can be run <strong>outside</strong> of the browser.
<a href="https://github.com/golang/go/issues/31105">This upstream issue</a> is tracking
the evolution of this topic.
Due to that, it's not possible to use the Go compiler to write Kubewarden policies.</p>
<p>Luckily there's another Go compiler that is capable of building WebAssembly
binaries that can be used by Kubewarden. This compiler is called <a href="https://tinygo.org/">TinyGo</a>:</p>
<blockquote>
<p>TinyGo is a project to bring the Go programming language to microcontrollers
and modern web browsers by creating a new compiler based on LLVM.</p>
<p>You can compile and run TinyGo programs on many different microcontroller
boards such as the BBC micro:bit and the Arduino Uno.</p>
<p>TinyGo can also be used to produce WebAssembly (Wasm) code which is very
compact in size.</p>
</blockquote>
<h2 id="limitations"><a class="header" href="#limitations">Limitations</a></h2>
<p>TinyGo doesn't yet support all the Go features (see <a href="https://tinygo.org/lang-support/">here</a>
to see the current project status). Currently its biggest limitation
is the lack of a fully supported <code>reflect</code> package. That leads to the inability to use
the <code>encoding/json</code> package against structures and user defined types.</p>
<p>Kubewarden policies need to process JSON data like the policy settings and
the actual request received by Kubernetes.</p>
<p>Despite TinyGo's current limitations, it's still easy and doable to write
Kubewarden validation policies with it.</p>
<blockquote>
<p><strong>Note well:</strong> unfortunately, it's currently impossible to write mutating
policies using TinyGo.</p>
</blockquote>
<h2 id="tooling"><a class="header" href="#tooling">Tooling</a></h2>
<p>Writing Kubewarden policies requires a version of TinyGo greater than <code>0.17.0</code>.</p>
<p>These Go libraries are extremely useful when writing a Kubewarden policy:</p>
<ul>
<li><a href="https://github.com/kubewarden/policy-sdk-go">Kubewarden Go SDK</a>: provides a series of
structures and functions that reduce the amount of code to write. It also provides test helpers.</li>
<li><a href="https://github.com/tidwall/gjson">gjson</a>: provides a powerful query language that allows
quick navigation of JSON documents and data retrieval. This library doesn't use the
<code>encoding/json</code> package provided by Go's stdlib, hence it's usable with TinyGo.</li>
<li><a href="https://github.com/deckarep/golang-set">mapset</a>: provides a Go implementation of the
<a href="https://en.wikipedia.org/wiki/Set_(abstract_data_type)">Set</a>
data structure. This library significantly reduces the amount of code to be written,
that's because operations like Set <code>union</code>, <code>intersection</code>, <code>difference</code> are pretty frequent inside
of policies.</li>
</ul>
<p>Last but not least, the Kubewarden project provides a
<a href="https://github.com/kubewarden/go-policy-template">template Go policy project</a>
that can be used to quickly create Kubewarden policies written in Go.</p>
<h2 id="getting-tinygo-dependencies"><a class="header" href="#getting-tinygo-dependencies">Getting TinyGo dependencies</a></h2>
<p>The easiest way to get TinyGo is by using the upstream container images.
Official releases can be found <a href="https://hub.docker.com/r/tinygo/tinygo">here</a>, while
builds from the development branch are automatically pushed
<a href="https://hub.docker.com/r/tinygo/tinygo-dev">here</a>.</p>
<p>If needed, checkout TinyGo's <a href="https://tinygo.org/getting-started/">getting started</a> page for
more information.</p>
<blockquote>
<p><strong>Note well:</strong> Kubewarden's requires code that is available only on the development branch. This will
be solved once TinyGo <code>0.17.0</code> is released. In the meantime we will use the container image
based on the development branch: <code>tinygo/tinygo-dev:latest</code>.</p>
</blockquote>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="creating-a-new-validation-policy-1"><a class="header" href="#creating-a-new-validation-policy-1">Creating a new validation policy</a></h1>
<p>We are going to create a validation policy that validates the labels of generic Kubernetes
objects.</p>
<p>The policy will reject all the resources that use one or more labels on the deny list.
The policy will also validate certain labels using a regular expression 
provided by the user.</p>
<p>To summarize, the policy settings will look like that:</p>
<pre><code class="language-yaml"># List of labels that cannot be used
denied_labels:
- foo
- bar

# Labels that are validated with user-defined regular expressions
constrained_labels:
  priority: &quot;[123]&quot;
  cost-center: &quot;^cc-\d+&quot;
</code></pre>
<p>The policy would reject the creation of this Pod:</p>
<pre><code class="language-yaml">apiVersion: v1
kind: Pod
metadata:
  name: nginx
  labels:
    foo: hello world
spec:
  containers:
    - name: nginx
      image: nginx:latest
</code></pre>
<p>The policy would also reject the creation of this Pod:</p>
<pre><code class="language-yaml">apiVersion: v1
kind: Pod
metadata:
  name: nginx
  labels:
    cost-center: cc-marketing
spec:
  containers:
    - name: nginx
      image: nginx:latest
</code></pre>
<p>Policy's settings can also be used to force certain labels to be specified,
regardless of their contents:</p>
<pre><code class="language-yaml"># Policy's settings

constrained_labels:
  mandatory-label: &quot;.*&quot; # &lt;- this label must be present, we don't care about its value
</code></pre>
<h2 id="scaffolding-new-policy-project-1"><a class="header" href="#scaffolding-new-policy-project-1">Scaffolding new policy project</a></h2>
<p>The creation of a new policy project can be done by using this GitHub
template repository: <a href="https://github.com/kubewarden/go-policy-template">kubewarden/go-policy-template</a>.
Just press the &quot;Use  this template&quot; green button near the top of the page
and follow GitHub's wizard.</p>
<p>Clone the repository locally and then ensure the <code>module</code> directive inside
of the <code>go.mod</code> file looks like that:</p>
<pre><code class="language-go">module &lt;path to your repository&gt;
</code></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="defining-policy-settings-1"><a class="header" href="#defining-policy-settings-1">Defining policy settings</a></h1>
<p>As a first step we will define the structure that holds the policy settings.</p>
<p>We will do that by adding this code inside of the <code>settings.go</code> file:</p>
<pre><code class="language-go">import (
	&quot;github.com/deckarep/golang-set&quot;
	&quot;github.com/kubewarden/gjson&quot;
	kubewarden &quot;github.com/kubewarden/policy-sdk-go&quot;

	&quot;fmt&quot;
	&quot;regexp&quot;
)

type Settings struct {
	DeniedLabels      mapset.Set                    `json:&quot;denied_labels&quot;`
	ConstrainedLabels map[string]*RegularExpression `json:&quot;constrained_labels&quot;`
}
</code></pre>
<p>As you can see we're using the <code>regexp</code> package to handle regular expression objects, plus
we use the <code>mapset.Set</code> structure to store the list of denied labels.</p>
<p>The <code>Settings</code> struct has json attributes, we will use them later when writing
our unit tests. The unit tests are going to be executed using Go official compiler, hence
we will be able to leverage the <code>encoding/json</code> package.</p>
<p>The <code>Settings</code> class is not using the official <code>regexp.RegExp</code> object to
represent regular expressions. That's because the <code>regexp.RegExp</code> struct doesn't
handle serialization and deserialization to JSON.</p>
<p>This is the implementation of the <code>RegularExpression</code> struct:</p>
<pre><code class="language-go">// A wrapper around the standard regexp.Regexp struct
// that implements marshalling and unmarshalling
type RegularExpression struct {
	*regexp.Regexp
}

// Convenience method to build a regular expression
func CompileRegularExpression(expr string) (*RegularExpression, error) {
	nativeRegExp, err := regexp.Compile(expr)
	if err != nil {
		return nil, err
	}
	return &amp;RegularExpression{nativeRegExp}, nil
}

// UnmarshalText satisfies the encoding.TextMarshaler interface,
// also used by json.Unmarshal.
func (r *RegularExpression) UnmarshalText(text []byte) error {
	nativeRegExp, err := regexp.Compile(string(text))
	if err != nil {
		return err
	}
	r.Regexp = nativeRegExp
	return nil
}

// MarshalText satisfies the encoding.TextMarshaler interface,
// also used by json.Marshal.
func (r *RegularExpression) MarshalText() ([]byte, error) {
	if r.Regexp != nil {
		return []byte(r.Regexp.String()), nil
	}

	return nil, nil
}
</code></pre>
<h2 id="building-settings-instances"><a class="header" href="#building-settings-instances">Building <code>Settings</code> instances</a></h2>
<p>At runtime we can't rely on the automatic struct marshalling and unmarshalling
provided by the <code>encoding/json</code> package due to TinyGo current limitations.
Because of that we will create two initialization helpers:</p>
<ul>
<li><code>NewSettingsFromValidationReq</code>: this is used when building a <code>Settings</code>
instance starting from a <a href="writing-policies/go//writing-policies/index.html#the-validationrequest-object"><code>ValidationRequest</code></a>
object</li>
<li><code>NewSettingsFromValidateSettingsPayload</code>: this is used when building a
<code>Settings</code> instance inside of the <a href="writing-policies/go//writing-policies/index.html#the-validate_settings-entry-point"><code>validate_settings</code></a> entry point. This entry point receives the &quot;naked&quot; Settings JSON
dictionary</li>
</ul>
<p>This is the implementation of these functions:</p>
<pre><code class="language-go">// Builds a new Settings instance starting from a validation
// request payload:
// {
//    &quot;request&quot;: ...,
//    &quot;settings&quot;: {
//       &quot;denied_labels&quot;: [...],
//       &quot;constrained_labels&quot;: { ... }
//    }
// }
func NewSettingsFromValidationReq(payload []byte) (Settings, error) {
	// Note well: we don't validate the input JSON now, this has
	// already done inside of the `validate` function

	return newSettings(
		payload,
		&quot;settings.denied_labels&quot;,
		&quot;settings.constrained_labels&quot;)
}

// Builds a new Settings instance starting from a Settings
// payload:
// {
//    &quot;denied_names&quot;: [ ... ],
//    &quot;constrained_labels&quot;: { ... }
// }
func NewSettingsFromValidateSettingsPayload(payload []byte) (Settings, error) {
	if !gjson.ValidBytes(payload) {
		return Settings{}, fmt.Errorf(&quot;denied JSON payload&quot;)
	}

	return newSettings(
		payload,
		&quot;denied_labels&quot;,
		&quot;constrained_labels&quot;)
}
</code></pre>
<p>The heavy lifting of the setting is done inside of the <code>newSettings</code> function, which
is invoked by both <code>NewSettingsFromValidateSettingsPayload</code> and <code>NewSettingsFromValidationReq</code>.</p>
<p>The function takes the raw JSON payload and a list of <a href="https://github.com/tidwall/gjson">gjson</a>
queries. These queries are used to extract the values from the JSON data and
build the actual object:</p>
<pre><code class="language-go">func newSettings(payload []byte, paths ...string) (Settings, error) {
	if len(paths) != 2 {
		return Settings{}, fmt.Errorf(&quot;wrong number of json paths&quot;)
	}

	data := gjson.GetManyBytes(payload, paths...)

	deniedLabels := mapset.NewThreadUnsafeSet()
	data[0].ForEach(func(_, entry gjson.Result) bool {
		deniedLabels.Add(entry.String())
		return true
	})

	constrainedLabels := make(map[string]*RegularExpression)
	var err error
	data[1].ForEach(func(key, value gjson.Result) bool {
		var regExp *RegularExpression
		regExp, err = CompileRegularExpression(value.String())
		if err != nil {
			return false
		}

		constrainedLabels[key.String()] = regExp
		return true
	})
	if err != nil {
		return Settings{}, err
	}

	return Settings{
		DeniedLabels:      deniedLabels,
		ConstrainedLabels: constrainedLabels,
	}, nil
}
</code></pre>
<p>As you can see the code above is pretty straightforward. The <code>gjson</code> package
provides a convenient method to fetch multiple values from the JSON data.</p>
<p>The <code>newSettings</code> function also creates instances of <code>regexp.Regexp</code> objects
and ensures the regular expressions provided by the user are correct.</p>
<blockquote>
<p><strong>Note well:</strong> all the <code>mapset.Set</code> objects are deliberately created using
their <a href="https://pkg.go.dev/github.com/deckarep/golang-set?utm_source=godoc#NewThreadUnsafeSet">thread-unsafe variant</a>.
The WebAssembly code is executed in single thread, hence there are no
concurrency issues.</p>
<p>Moreover, the WebAssembly standard doesn't cover
threads yet. See <a href="https://github.com/WebAssembly/threads">the official proposal</a>
for more details.</p>
</blockquote>
<h2 id="implementing-settings-validation"><a class="header" href="#implementing-settings-validation">Implementing <code>Settings</code> validation</a></h2>
<p>All Kubewarden policies have to implement
<a href="writing-policies/go//writing-policies/index.html#the-validate_settings-entry-point">settings validation</a>.</p>
<p>This can be easily done by adding a <code>Valid</code> method to the <code>Settings</code> instances:</p>
<pre><code class="language-go">func (s *Settings) Valid() (bool, error) {
	constrainedLabels := mapset.NewThreadUnsafeSet()

	for label := range s.ConstrainedLabels {
		constrainedLabels.Add(label)
	}

	constrainedAndDenied := constrainedLabels.Intersect(s.DeniedLabels)
	if constrainedAndDenied.Cardinality() != 0 {
		return false,
			fmt.Errorf(&quot;These labels cannot be constrained and denied at the same time: %v&quot;, constrainedAndDenied)
	}

	return true, nil
}
</code></pre>
<p>The <code>Valid</code> method ensures no &quot;denied&quot; label is also part of the &quot;constrained&quot; map. The check
is simplified by the usage of the <code>Intersect</code> method provided by <code>mapset.Set</code>.</p>
<blockquote>
<p><strong>Note well:</strong> the <code>Valid</code> method is invoked against an already instantiated <code>Setting</code> object. That means
the validation of the regular expression provided by the user already took place at
inside of the <code>Settings</code> constructor.</p>
</blockquote>
<p>Finally, we have to ensure the <code>validateSettings</code> function that was automatically generated
is changed to look like that:</p>
<pre><code class="language-go">func validateSettings(payload []byte) ([]byte, error) {
	settings, err := NewSettingsFromValidateSettingsPayload(payload)
	if err != nil {
		// this happens when one of the user-defined regular expressions are invalid
		return kubewarden.RejectSettings(
			kubewarden.Message(fmt.Sprintf(&quot;Provided settings are not valid: %v&quot;, err)))
	}

	valid, err := settings.Valid()
	if valid {
		return kubewarden.AcceptSettings()
	}
	return kubewarden.RejectSettings(
		kubewarden.Message(fmt.Sprintf(&quot;Provided settings are not valid: %v&quot;, err)))
}
</code></pre>
<p>As you can see, the function takes advantage of the helper functions provided
by <a href="https://github.com/kubewarden/policy-sdk-go">Kubewarden's SDK</a>.</p>
<h2 id="testing-the-settings-code"><a class="header" href="#testing-the-settings-code">Testing the settings code</a></h2>
<p>As always, it's important to have good test coverage of the code we write.
The code we generated comes with a series of unit test defined inside of
the <code>settings_test.go</code> file.</p>
<p>We will have to change the contents of this file to reflect the new behaviour of the
<code>Settings</code> class.</p>
<p>We will start by including the Go packages we will use:</p>
<pre><code class="language-go">import (
	&quot;encoding/json&quot;
	&quot;testing&quot;

	kubewarden_testing &quot;github.com/kubewarden/policy-sdk-go/testing&quot;
)
</code></pre>
<p>As stated before, the unit tests are not part of the final WebAssembly binary, hence
we can build them using the official Go compiler. That means we can use the <code>encoding/json</code>
package to simplify our tests.</p>
<p>We will start by writing a unit test that ensures we can allocate a <code>Settings</code>
instance from a <a href="writing-policies/go//writing-policies/index.html#the-validationrequest-object"><code>ValidationRequest</code></a>
object:</p>
<pre><code class="language-go">func TestParseValidSettings(t *testing.T) {
	request := `
	{
		&quot;request&quot;: &quot;doesn't matter here&quot;,
		&quot;settings&quot;: {
			&quot;denied_labels&quot;: [ &quot;foo&quot;, &quot;bar&quot; ],
			&quot;constrained_labels&quot;: {
				&quot;cost-center&quot;: &quot;cc-\\d+&quot;
			}
		}
	}
	`
	rawRequest := []byte(request)

	settings, err := NewSettingsFromValidationReq(rawRequest)
	if err != nil {
		t.Errorf(&quot;Unexpected error %+v&quot;, err)
	}

	expected_denied_labels := []string{&quot;foo&quot;, &quot;bar&quot;}
	for _, exp := range expected_denied_labels {
		if !settings.DeniedLabels.Contains(exp) {
			t.Errorf(&quot;Missing value %s&quot;, exp)
		}
	}

	re, found := settings.ConstrainedLabels[&quot;cost-center&quot;]
	if !found {
		t.Error(&quot;Didn't find the expected constrained label&quot;)
	}

	expected_regexp := `cc-\d+`
	if re.String() != expected_regexp {
		t.Errorf(&quot;Execpted regexp to be %v - got %v instead&quot;,
			expected_regexp, re.String())
	}
</code></pre>
<p>Next we will define a test that ensures a <code>Settings</code> instance
cannot be generated when the user provides a broken regular
expression:</p>
<pre><code class="language-go">func TestParseSettingsWithInvalidRegexp(t *testing.T) {
	request := `
	{
		&quot;request&quot;: &quot;doesn't matter here&quot;,
		&quot;settings&quot;: {
			&quot;denied_labels&quot;: [ &quot;foo&quot;, &quot;bar&quot; ],
			&quot;constrained_labels&quot;: {
				&quot;cost-center&quot;: &quot;cc-[a+&quot;
			}
		}
	}
	`
	rawRequest := []byte(request)

	_, err := NewSettingsFromValidationReq(rawRequest)
	if err == nil {
		t.Errorf(&quot;Didn'g get expected error&quot;)
	}
}
</code></pre>
<p>Next we will define a test that checks the behaviour
of the <a href="writing-policies/go//writing-policies/index.html#the-validate_settings-entry-point"><code>validate_settings</code></a>
entry-point.</p>
<p>In this case we actually look at the <code>SettingsValidationResponse</code> objected
returned by our <code>validateSettings</code> function:</p>
<pre><code class="language-go">func TestDetectValidSettings(t *testing.T) {
	request := `
	{
		&quot;denied_labels&quot;: [ &quot;foo&quot;, &quot;bar&quot; ],
		&quot;constrained_labels&quot;: {
			&quot;cost-center&quot;: &quot;cc-\\d+&quot;
		}
	}
	`
	rawRequest := []byte(request)
	responsePayload, err := validateSettings(rawRequest)
	if err != nil {
		t.Errorf(&quot;Unexpected error %+v&quot;, err)
	}

	var response kubewarden_testing.SettingsValidationResponse
	if err := json.Unmarshal(responsePayload, &amp;response); err != nil {
		t.Errorf(&quot;Unexpected error: %+v&quot;, err)
	}

	if !response.Valid {
		t.Errorf(&quot;Expected settings to be valid: %s&quot;, response.Message)
	}
}
</code></pre>
<p>Finally, we write two more tests to ensure the <code>validateSettings</code> function
rejects invalid settings with the right messages:</p>
<pre><code class="language-go">func TestDetectNotValidSettingsDueToBrokenRegexp(t *testing.T) {
	request := `
	{
		&quot;denied_labels&quot;: [ &quot;foo&quot;, &quot;bar&quot; ],
		&quot;constrained_labels&quot;: {
			&quot;cost-center&quot;: &quot;cc-[a+&quot;
		}
	}
	`
	rawRequest := []byte(request)
	responsePayload, err := validateSettings(rawRequest)
	if err != nil {
		t.Errorf(&quot;Unexpected error %+v&quot;, err)
	}

	var response kubewarden_testing.SettingsValidationResponse
	if err := json.Unmarshal(responsePayload, &amp;response); err != nil {
		t.Errorf(&quot;Unexpected error: %+v&quot;, err)
	}

	if response.Valid {
		t.Error(&quot;Expected settings to not be valid&quot;)
	}

	if response.Message != &quot;Provided settings are not valid: error parsing regexp: missing closing ]: `[a+`&quot; {
		t.Errorf(&quot;Unexpected validation error message: %s&quot;, response.Message)
	}
}

func TestDetectNotValidSettingsDueToConflictingLabels(t *testing.T) {
	request := `
	{
		&quot;denied_labels&quot;: [ &quot;foo&quot;, &quot;bar&quot;, &quot;cost-center&quot; ],
		&quot;constrained_labels&quot;: {
			&quot;cost-center&quot;: &quot;.*&quot;
		}
	}
	`
	rawRequest := []byte(request)
	responsePayload, err := validateSettings(rawRequest)
	if err != nil {
		t.Errorf(&quot;Unexpected error %+v&quot;, err)
	}

	var response kubewarden_testing.SettingsValidationResponse
	if err := json.Unmarshal(responsePayload, &amp;response); err != nil {
		t.Errorf(&quot;Unexpected error: %+v&quot;, err)
	}

	if response.Valid {
		t.Error(&quot;Expected settings to not be valid&quot;)
	}

	if response.Message != &quot;Provided settings are not valid: These labels cannot be constrained and denied at the same time: Set{cost-center}&quot; {
		t.Errorf(&quot;Unexpected validation error message: %s&quot;, response.Message)
	}
}
</code></pre>
<p>Now we can run the test by using the following command:</p>
<pre><code class="language-shell">go test -v settings.go settings_test.go
</code></pre>
<p>All the tests will pass with the following output:</p>
<pre><code class="language-shell">=== RUN   TestParseValidSettings
--- PASS: TestParseValidSettings (0.00s)
=== RUN   TestParseSettingsWithInvalidRegexp
--- PASS: TestParseSettingsWithInvalidRegexp (0.00s)
=== RUN   TestDetectValidSettings
--- PASS: TestDetectValidSettings (0.00s)
=== RUN   TestDetectNotValidSettingsDueToBrokenRegexp
--- PASS: TestDetectNotValidSettingsDueToBrokenRegexp (0.00s)
=== RUN   TestDetectNotValidSettingsDueToConflictingLabels
--- PASS: TestDetectNotValidSettingsDueToConflictingLabels (0.00s)
PASS
ok  	command-line-arguments	0.001s
</code></pre>
<p>We can now move to implement the actual validation code.</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="writing-the-validation-logic-1"><a class="header" href="#writing-the-validation-logic-1">Writing the validation logic</a></h1>
<p>It's now time to write the actual validation logic. This is done
inside of the <code>validate.go</code> file.</p>
<p>The scaffolded policy has already a <code>validate</code> function, we will need to make
very few changes to it.</p>
<p>This is how the function has to look like:</p>
<pre><code class="language-go">func validate(payload []byte) ([]byte, error) {
	// NOTE 1
	if !gjson.ValidBytes(payload) {
		return kubewarden.RejectRequest(
			kubewarden.Message(&quot;Not a valid JSON document&quot;),
			kubewarden.Code(400))
	}

	// NOTE 2
	settings, err := NewSettingsFromValidationReq(payload)
	if err != nil {
		return kubewarden.RejectRequest(
			kubewarden.Message(err.Error()),
			kubewarden.Code(400))
	}

	// NOTE 3
	data := gjson.GetBytes(
		payload,
		&quot;request.object.metadata.labels&quot;)

	// NOTE 4
	data.ForEach(func(key, value gjson.Result) bool {
		label := key.String()

		// NOTE 5
		if settings.DeniedLabels.Contains(label) {
			err = fmt.Errorf(&quot;Label %s is on the deny list&quot;, label)
			// stop iterating over labels
			return false
		}

		// NOTE 6
		regExp, found := settings.ConstrainedLabels[label]
		if found {
			// This is a constrained label
			if !regExp.Match([]byte(value.String())) {
				err = fmt.Errorf(&quot;The value of %s doesn't pass user-defined constraint&quot;, label)
				// stop iterating over labels
				return false
			}
		}

		return true
	})

	// NOTE 7
	if err != nil {
		return kubewarden.RejectRequest(
			kubewarden.Message(err.Error()),
			kubewarden.NoCode)
	}

	return kubewarden.AcceptRequest()
</code></pre>
<p>The code has some <code>NOTE</code> section inside of it. Let's get through them:</p>
<ol>
<li>The function ensures the JSON payload is properly formatted. This
is done using a function provided by the <code>gjson</code> library</li>
<li>The <code>Settings</code> instance is created using one of the constructor
methods we defined inside of <code>settings.go</code></li>
<li>We use a <code>gjson</code> selector to get the <code>label</code> map provided by the object
embedded into the request</li>
<li>We use a <code>gjson</code> helper to iterate over the results of the query. If the query
has no results the loop will never take place.</li>
<li>We look for the <code>label</code> of the object inside of the list of denied labels
provided by the user via the policy settings. If the <code>label</code> is a denied
one, we set the value of the <code>err</code> variable and exit from the loop (that
happens by returning <code>false</code> instead of <code>true</code>).</li>
<li>We look for the <code>label</code> of the object inside of the list of constrained labels
provided by the user via the policy settings. When we have a match we use
the regular expression provided by the user to validate the value of the label.
If the validation fails, we set the value of the <code>err</code> variable and exit
from the loop (that happens by returning <code>false</code> instead of <code>true</code>).</li>
<li>If the <code>err</code> variable is not <code>nil</code>, we use the helper provided by Kubewarden's
SDK to reject the request. Otherwise we accept it.</li>
</ol>
<h2 id="testing-the-validation-code"><a class="header" href="#testing-the-validation-code">Testing the validation code</a></h2>
<p>It's now time to write some unit tests to ensure the validation code is behaving
properly. These tests are going to be located inside of the <code>validate_test.go</code>
file.</p>
<p>The tests will rely on some <a href="https://en.wikipedia.org/wiki/Test_fixture#Software">test fixtures</a>
located inside of the <code>test_data</code> directory. This directory has already
been populated by the template repository.</p>
<p>We will start by including the following packages:</p>
<pre><code class="language-go">import (
	&quot;encoding/json&quot;
	&quot;testing&quot;

	&quot;github.com/deckarep/golang-set&quot;
	kubewarden_testing &quot;github.com/kubewarden/policy-sdk-go/testing&quot;
)
</code></pre>
<p>The first unit test will ensure that having no user settings leads
to the request to be accepted:</p>
<pre><code class="language-go">func TestEmptySettingsLeadsToRequestAccepted(t *testing.T) {
	settings := Settings{}

	payload, err := kubewarden_testing.BuildValidationRequest(
		&quot;test_data/ingress.json&quot;,
		&amp;settings)
	if err != nil {
		t.Errorf(&quot;Unexpected error: %+v&quot;, err)
	}

	responsePayload, err := validate(payload)
	if err != nil {
		t.Errorf(&quot;Unexpected error: %+v&quot;, err)
	}

	var response kubewarden_testing.ValidationResponse
	if err := json.Unmarshal(responsePayload, &amp;response); err != nil {
		t.Errorf(&quot;Unexpected error: %+v&quot;, err)
	}

	if response.Accepted != true {
		t.Error(&quot;Unexpected rejection&quot;)
	}
}
</code></pre>
<p>As you can see we are using some test helper functions and structures provided
by the Kubewarden SDK.</p>
<p>The next test ensures a request can be accepted when none of its labels
is relevant to the user:</p>
<pre><code class="language-go">func TestRequestAccepted(t *testing.T) {
	constrainedLabels := make(map[string]*RegularExpression)
	re, err := CompileRegularExpression(`^world-`)
	if err != nil {
		t.Errorf(&quot;Unexpected error: %+v&quot;, err)
	}
	constrainedLabels[&quot;hello&quot;] = re

	settings := Settings{
		DeniedLabels:      mapset.NewThreadUnsafeSetFromSlice([]interface{}{&quot;bad1&quot;, &quot;bad2&quot;}),
		ConstrainedLabels: constrainedLabels,
	}

	payload, err := kubewarden_testing.BuildValidationRequest(
		&quot;test_data/ingress.json&quot;,
		&amp;settings)
	if err != nil {
		t.Errorf(&quot;Unexpected error: %+v&quot;, err)
	}

	responsePayload, err := validate(payload)
	if err != nil {
		t.Errorf(&quot;Unexpected error: %+v&quot;, err)
	}

	var response kubewarden_testing.ValidationResponse
	if err := json.Unmarshal(responsePayload, &amp;response); err != nil {
		t.Errorf(&quot;Unexpected error: %+v&quot;, err)
	}

	if response.Accepted != true {
		t.Error(&quot;Unexpected rejection&quot;)
	}
}
</code></pre>
<p>Next we will ensure a request is accepted when one of its labels satisfies
the constraint provided by the user:</p>
<pre><code class="language-go">func TestAcceptRequestWithConstraintLabel(t *testing.T) {
	constrainedLabels := make(map[string]*RegularExpression)
	re, err := CompileRegularExpression(`^team-`)
	if err != nil {
		t.Errorf(&quot;Unexpected error: %s&quot;, err)
	}
	constrainedLabels[&quot;owner&quot;] = re
	settings := Settings{
		DeniedLabels:      mapset.NewThreadUnsafeSetFromSlice([]interface{}{&quot;bad1&quot;, &quot;bad2&quot;}),
		ConstrainedLabels: constrainedLabels,
	}

	payload, err := kubewarden_testing.BuildValidationRequest(
		&quot;test_data/ingress.json&quot;,
		&amp;settings)
	if err != nil {
		t.Errorf(&quot;Unexpected error: %+v&quot;, err)
	}

	responsePayload, err := validate(payload)
	if err != nil {
		t.Errorf(&quot;Unexpected error: %+v&quot;, err)
	}

	var response kubewarden_testing.ValidationResponse
	if err := json.Unmarshal(responsePayload, &amp;response); err != nil {
		t.Errorf(&quot;Unexpected error: %+v&quot;, err)
	}

	if response.Accepted != true {
		t.Error(&quot;Unexpected rejection&quot;)
	}
}
</code></pre>
<p>It's now time to test the rejection of requests.</p>
<p>This test verifies a request is rejected when one of the labels is
on the deny list:</p>
<pre><code class="language-go">func TestRejectionBecauseDeniedLabel(t *testing.T) {
	constrainedLabels := make(map[string]*RegularExpression)
	re, err := CompileRegularExpression(`^world-`)
	if err != nil {
		t.Errorf(&quot;Unexpected error: %+v&quot;, err)
	}
	constrainedLabels[&quot;hello&quot;] = re

	settings := Settings{
		DeniedLabels:      mapset.NewThreadUnsafeSetFromSlice([]interface{}{&quot;owner&quot;}),
		ConstrainedLabels: constrainedLabels,
	}

	payload, err := kubewarden_testing.BuildValidationRequest(
		&quot;test_data/ingress.json&quot;,
		&amp;settings)
	if err != nil {
		t.Errorf(&quot;Unexpected error: %+v&quot;, err)
	}

	responsePayload, err := validate(payload)
	if err != nil {
		t.Errorf(&quot;Unexpected error: %+v&quot;, err)
	}

	var response kubewarden_testing.ValidationResponse
	if err := json.Unmarshal(responsePayload, &amp;response); err != nil {
		t.Errorf(&quot;Unexpected error: %+v&quot;, err)
	}

	if response.Accepted != false {
		t.Error(&quot;Unexpected accept response&quot;)
	}

	expected_message := &quot;Label owner is on the deny list&quot;
	if response.Message != expected_message {
		t.Errorf(&quot;Got '%s' instead of '%s'&quot;, response.Message, expected_message)
	}
}
</code></pre>
<p>The next test ensures a request is rejected when one of the user defined
constraints is not satisfied:</p>
<pre><code class="language-go">func TestRejectionBecauseConstrainedLabelNotValid(t *testing.T) {
	constrainedLabels := make(map[string]*RegularExpression)
	re, err := CompileRegularExpression(`^cc-\d+$`)
	if err != nil {
		t.Errorf(&quot;Unexpected error: %+v&quot;, err)
	}
	constrainedLabels[&quot;cc-center&quot;] = re

	settings := Settings{
		DeniedLabels:      mapset.NewThreadUnsafeSetFromSlice([]interface{}{}),
		ConstrainedLabels: constrainedLabels,
	}

	payload, err := kubewarden_testing.BuildValidationRequest(
		&quot;test_data/ingress.json&quot;,
		&amp;settings)
	if err != nil {
		t.Errorf(&quot;Unexpected error: %+v&quot;, err)
	}

	responsePayload, err := validate(payload)
	if err != nil {
		t.Errorf(&quot;Unexpected error: %+v&quot;, err)
	}

	var response kubewarden_testing.ValidationResponse
	if err := json.Unmarshal(responsePayload, &amp;response); err != nil {
		t.Errorf(&quot;Unexpected error: %+v&quot;, err)
	}

	if response.Accepted != false {
		t.Error(&quot;Unexpected accept response&quot;)
	}

	expected_message := &quot;The value of cc-center doesn't pass user-defined constraint&quot;
	if response.Message != expected_message {
		t.Errorf(&quot;Got '%s' instead of '%s'&quot;, response.Message, expected_message)
	}
}
</code></pre>
<p>We can now run all the unit tests, including the one defined inside of <code>settings_test.go</code>,
by using this simple command:</p>
<pre><code class="language-shell">make test
</code></pre>
<p>This will produce the following output:</p>
<pre><code class="language-shell">go test -v
=== RUN   TestParseValidSettings
--- PASS: TestParseValidSettings (0.00s)
=== RUN   TestParseSettingsWithInvalidRegexp
--- PASS: TestParseSettingsWithInvalidRegexp (0.00s)
=== RUN   TestDetectValidSettings
--- PASS: TestDetectValidSettings (0.00s)
=== RUN   TestDetectNotValidSettingsDueToBrokenRegexp
--- PASS: TestDetectNotValidSettingsDueToBrokenRegexp (0.00s)
=== RUN   TestDetectNotValidSettingsDueToConflictingLabels
--- PASS: TestDetectNotValidSettingsDueToConflictingLabels (0.00s)
=== RUN   TestEmptySettingsLeadsToRequestAccepted
--- PASS: TestEmptySettingsLeadsToRequestAccepted (0.00s)
=== RUN   TestRequestAccepted
--- PASS: TestRequestAccepted (0.00s)
=== RUN   TestAcceptRequestWithConstraintLabel
--- PASS: TestAcceptRequestWithConstraintLabel (0.00s)
=== RUN   TestRejectionBecauseDeniedLabel
--- PASS: TestRejectionBecauseDeniedLabel (0.00s)
=== RUN   TestRejectionBecauseConstrainedLabelNotValid
--- PASS: TestRejectionBecauseConstrainedLabelNotValid (0.00s)
PASS
ok  	github.com/kubewarden/safe-labels-policy	0.001s
</code></pre>
<p>We can now move to the next step, write some end-to-end tests.</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="end-to-end-testing"><a class="header" href="#end-to-end-testing">End-to-end testing</a></h1>
<p>So far we have tested the policy using a set of Go unit tests. This section shows
how we can write end-to-end test that run tests against the actual WebAssembly
binary produced by TinyGo.</p>
<h2 id="prerequisites"><a class="header" href="#prerequisites">Prerequisites</a></h2>
<p>These tools need to be installed on your development machine:</p>
<ul>
<li>docker or another container engine: used to build the WebAssembly
policy. We will rely on the compiler shipped within the official
TinyGo container image.</li>
<li><a href="https://github.com/bats-core/bats-core">bats</a>: used to write the
tests and automate their execution.</li>
<li><a href="https://github.com/kubewarden/policy-server/releases">policy-testdrive</a>:
cli tool provided by Kubewarden to run its policies outside of
Kubernetes. This is covered in depth inside of <a href="writing-policies/go//testing-policies.html">this section</a>
of the documentation.</li>
</ul>
<h2 id="building-the-policy-1"><a class="header" href="#building-the-policy-1">Building the policy</a></h2>
<p>As a first step we need to build the policy into a WebAssembly binary.</p>
<p>This can be done with this simple command:</p>
<pre><code class="language-shell">make wasm
</code></pre>
<p>This will pull the official TinyGo container image and run the build process
inside of an ephemeral container.</p>
<p>The compilation produces a file called <code>policy.wasm</code>.</p>
<h2 id="writing-tests"><a class="header" href="#writing-tests">Writing tests</a></h2>
<p>We are going to use <a href="https://github.com/bats-core/bats-core">bats</a> to write and
automate our tests. Each test will be composed by the following steps:</p>
<ol>
<li>Run the policy using <code>policy-testdrive</code>.</li>
<li>Perform some assertions against the output produced by the
<code>policy-testdrive</code>.</li>
</ol>
<p>All the end-to-end tests are located inside of a file called <code>e2e.bats</code>. The
scaffolded project already includes such a file. We will just change its
contents to reflect how our policy behaves.</p>
<p>As a final note, the end-to-end tests we will use the same test fixtures files
we previously used inside of the Go unit tests.</p>
<p>The first test ensures a request is approved when no settings are provided:</p>
<pre><code class="language-bash">@test &quot;accept when no settings are provided&quot; {
  run policy-testdrive -p policy.wasm -r test_data/ingress.json

  # this prints the output when one the checks below fails
  echo &quot;output = ${output}&quot;

  # settings validation passed
  [[ &quot;$output&quot; == *&quot;valid: true&quot;* ]]

  # request rejected
  [[ &quot;$output&quot; == *&quot;allowed: true&quot;* ]]
}
</code></pre>
<p>We can execute the end-to-end tests by using this command:</p>
<pre><code class="language-shell">make e2e-tests
</code></pre>
<p>This will produce the following output:</p>
<pre><code class="language-shell">bats e2e.bats
  accept when no settings are provided

1 test, 0 failures
</code></pre>
<p>Let's write a test to ensure a request is approved when a user-defined constraint
is respected:</p>
<pre><code class="language-bash">@test &quot;accept user defined constraint is respected&quot; {
  run policy-testdrive -p policy.wasm \
    -r test_data/ingress.json \
    -s '{&quot;constrained_labels&quot;: {&quot;owner&quot;: &quot;^team-&quot;}}'
  # this prints the output when one the checks below fails
  echo &quot;output = ${output}&quot;

  # settings validation passed
  [[ &quot;$output&quot; == *&quot;valid: true&quot;* ]]

  # request accepted
  [[ &quot;$output&quot; == *&quot;allowed: true&quot;* ]]
}
</code></pre>
<p>Next, we can write a test to ensure a request is accepted when none of the
labels is on the deny list:</p>
<pre><code class="language-bash">@test &quot;accept labels are not on deny list&quot; {
  run policy-testdrive -p policy.wasm \
    -r test_data/ingress.json \
    -s '{&quot;denied_labels&quot;: [&quot;foo&quot;, &quot;bar&quot;]}'
  # this prints the output when one the checks below fails
  echo &quot;output = ${output}&quot;

  # settings validation passed
  [[ &quot;$output&quot; == *&quot;valid: true&quot;* ]]

  # request accepted
  [[ &quot;$output&quot; == *&quot;allowed: true&quot;* ]]
}
</code></pre>
<p>Let's improve the test coverage by adding a test that rejects a request
because one of the labels is on the deny list:</p>
<pre><code class="language-bash">@test &quot;reject because label is on deny list&quot; {
  run policy-testdrive -p policy.wasm \
    -r test_data/ingress.json \
    -s '{&quot;denied_labels&quot;: [&quot;foo&quot;, &quot;owner&quot;]}'

  # this prints the output when one the checks below fails
  echo &quot;output = ${output}&quot;

  # settings validation passed
  [[ &quot;$output&quot; == *&quot;valid: true&quot;* ]]

  # request rejected
  [[ &quot;$output&quot; == *&quot;allowed: false&quot;* ]]
  [[ &quot;$output&quot; == *&quot;Label owner is on the deny list&quot;* ]]
}
</code></pre>
<p>The following test ensures a request is rejected when one of its labels doesn't
satisfy the constraint provided by the user:</p>
<pre><code class="language-bash">@test &quot;reject because label doesn't pass validation constraint&quot; {
  run policy-testdrive -p policy.wasm \
    -r test_data/ingress.json \
    -s '{&quot;constrained_labels&quot;: {&quot;cc-center&quot;: &quot;^cc-\\d+$&quot;}}'

  # this prints the output when one the checks below fails
  echo &quot;output = ${output}&quot;

  # settings validation passed
  [[ &quot;$output&quot; == *&quot;valid: true&quot;* ]]

  # request rejected
  [[ &quot;$output&quot; == *&quot;allowed: false&quot;* ]]
  [[ &quot;$output&quot; == *&quot;The value of cc-center doesn\'t pass user-defined constraint&quot;* ]]
}
</code></pre>
<p>We want to ensure settings' validation is working properly. This can be done
with the following tests:</p>
<pre><code class="language-bash">@test &quot;fail settings validation because of conflicting labels&quot; {
  run policy-testdrive -p policy.wasm \
    -r test_data/ingress.json \
    -s '{&quot;denied_labels&quot;: [&quot;foo&quot;, &quot;cc-center&quot;], &quot;constrained_labels&quot;: {&quot;cc-center&quot;: &quot;^cc-\\d+$&quot;}}'

  # this prints the output when one the checks below fails
  echo &quot;output = ${output}&quot;

  # settings validation passed
  [[ &quot;$output&quot; == *&quot;valid: false&quot;* ]]
  [[ &quot;$output&quot; == *&quot;Provided settings are not valid: These labels cannot be constrained and denied at the same time: Set{cc-center}&quot;* ]]
}

@test &quot;fail settings validation because of invalid constraint&quot; {
  run policy-testdrive -p policy.wasm \
    -r test_data/ingress.json \
    -s '{&quot;constrained_labels&quot;: {&quot;cc-center&quot;: &quot;^cc-[12$&quot;}}'

  # this prints the output when one the checks below fails
  echo &quot;output = ${output}&quot;

  # settings validation passed
  [[ &quot;$output&quot; == *&quot;valid: false&quot;* ]]
  [[ &quot;$output&quot; == *&quot;Provided settings are not valid: error parsing regexp: missing closing ]: `[12$`&quot;* ]]
}
</code></pre>
<h2 id="conclusion"><a class="header" href="#conclusion">Conclusion</a></h2>
<p>We have reached a pretty good level of coverage, let's run all the end-to-end
tests:</p>
<pre><code class="language-shell">$ make e2e-tests
bats e2e.bats
  accept when no settings are provided
  accept user defined constraint is respected
  accept labels are not on deny list
  reject because label is on deny list
  reject because label doesn't pass validation constraint
  fail settings validation because of conflicting labels
  fail settings validation because of invalid constraint

7 tests, 0 failures
</code></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="automations"><a class="header" href="#automations">Automations</a></h1>
<p>This section describes how we can use GitHub Actions to automate as many tasks
as possible.</p>
<p>The scaffolded project already includes all the GitHub actions you need.
These files can be found inside of the <code>.github/workflows</code> directory.</p>
<p>The same principles can be adapted to use a different CI system.</p>
<h2 id="testing"><a class="header" href="#testing">Testing</a></h2>
<p>We can automate the execution of the unit tests and of the end-to-end tests.</p>
<p>This is working out of the box thanks to these files:</p>
<ul>
<li><code>.github/workflows/e2e-tests.yml</code></li>
<li><code>.github/workflows/unit-tests.yml</code></li>
</ul>
<h2 id="release"><a class="header" href="#release">Release</a></h2>
<p>The scaffolded project created a <code>.github/workflows/release.yml.template</code>.</p>
<p>This file defines a pipeline that performs the following steps:</p>
<ul>
<li>Checkout code</li>
<li>Build the WebAssembly policy</li>
<li>Push the policy to an OCI registry</li>
<li>Eventually create a new GitHub Release</li>
</ul>
<p>To enable the pipeline you need to rename it to <code>release.yml</code> and change the
value of the <code>OCI_TARGET</code> to match your preferences.</p>
<p>The pipeline will act differently based on the commit that triggered its execution.</p>
<p>Regular commits will lead to the creation of an OCI artifact called <code>&lt;policy-name&gt;:latest</code>.
No GitHub Release will be created for this commits.</p>
<p>On the other hand, creating a tag that matches the <code>v*</code> pattern, will lead
to:</p>
<ol>
<li>Creation of an OCI artifact called <code>&lt;policy-name&gt;:&lt;tag&gt;</code>.</li>
<li>Creation of a GitHub Release named <code>Release &lt;full tag name&gt;</code>. The release
will include the following assets: the source code of the policy and the WebAssembly
binary.</li>
</ol>
<h3 id="a-concrete-example-2"><a class="header" href="#a-concrete-example-2">A concrete example</a></h3>
<p>Let's assume we have a policy named named <code>safe-labels</code> and we want to publish
it as <code>ghcr.io/kubewarden/policies/safe-labels</code>.</p>
<p>The contents of the <code>jobs.env</code> section of <code>release.yml</code> should look like that:</p>
<pre><code class="language-yaml">jobs:
  build:
    name: Create new release with Wasm artifact
    runs-on: ubuntu-latest
    env:
      WASM_BINARY_NAME: policy.wasm
      OCI_TARGET: ghcr.io/kubewarden/policies/safe-labels
</code></pre>
<p>Pushing a tag named <code>v0.1.0</code> will lead to the creation and publishing of the
OCI artifact called <code>ghcr.io/kubewarden/policies/safe-labels:v0.1.0</code>.</p>
<p>A GitHub Release named <code>Release v0.1.0</code> will be created. The release will
include the following assets:</p>
<ul>
<li>Source code compressed as <code>zip</code> and <code>tar.gz</code></li>
<li>A file named <code>policy.wasm</code> that is the actual WebAssembly policy</li>
</ul>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="distribute-policy"><a class="header" href="#distribute-policy">Distribute policy</a></h1>
<p>Congratulations for having made this far </p>
<p>We hope you enjoyed the journey!</p>
<p>In case you haven't realized, we actually created the
<a href="https://github.com/kubewarden/safe-labels-policy">safe-labels-policy</a>
together.</p>
<p>There's nothing special to be done when it comes to distributing the
policy. If you followed this guide you have already published
your policy using the GitHub <code>release.yml</code> Action defined in the previous
chapter.</p>
<p>The topic of distributing policies is covered in depth inside of the
<a href="writing-policies/go//distributing-policies.html">&quot;distributing policies&quot;</a>
section of Kubewarden's documentation.</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="swift"><a class="header" href="#swift">Swift</a></h1>
<p>As stated on the <a href="https://swift.org/">official website</a>:</p>
<blockquote>
<p>Swift is a general-purpose programming language built using a modern approach
to safety, performance, and software design patterns.</p>
</blockquote>
<p>The swift compiler doesn't yet have WebAssembly support, however the
<a href="https://swiftwasm.org/">Swiftwasm</a> provides a patched compiler with this
capability.</p>
<p>The Swiftwasm team is also working to upstream all these changes into the
Swift project. In the meantime the toolchain provided by the Swiftwasm project
can be used to build Kubewarden policies.</p>
<p><strong>Note well:</strong> you don't need an Apple system to write or run Swift code. Everything
can be done also on a Linux machine or on Windows (by using Docker for Windows).</p>
<h2 id="current-state"><a class="header" href="#current-state">Current State</a></h2>
<p>The creation of a Swift SDK is in progress, it can be found inside
of <a href="https://github.com/kubewarden/policy-sdk-swift">this repository</a>.
We plan to provide a template project to simplify the process of creating
Swift-based policies, like we do with other languages.</p>
<p>The documentation will be expanded to cover more detailed instructions for Swift
as soon as the work on the SDK is done.</p>
<p>In the meantime, no severe limitations have been found inside of Swift, only
some minor glitches:</p>
<ul>
<li>It's critical to perform some post-build optimizations before using the
policy <em>&quot;in production&quot;</em>:
<ol>
<li>Strip the Wasm module via <code>wasm-strip</code> to reduce its size</li>
<li>Optimize the Wasm module via <code>wasm-opt</code></li>
</ol>
</li>
</ul>
<h2 id="example-1"><a class="header" href="#example-1">Example</a></h2>
<p><a href="https://github.com/kubewarden/pod-runtime-class-policy">This GitHub repository</a>
contains a Kubewarden Policy written in Swift.</p>
<p>The policy's <code>Makefile</code> has a <code>release</code> target that takes care of the
optimizations outlined above.</p>
<p><strong>Worth of note:</strong> this repository has a series of GitHub Actions that automate
the following tasks:</p>
<ul>
<li>Run unit tests and code linting on pull requests and after code is merged
into the main branch</li>
<li>Build the policy in <code>release</code> mode and push it to a OCI registry as an
artifact</li>
</ul>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="typescript"><a class="header" href="#typescript">TypeScript</a></h1>
<p>As stated on the <a href="https://www.typescriptlang.org/">official website</a>:</p>
<blockquote>
<p>TypeScript extends JavaScript by adding types.</p>
<p>By understanding JavaScript, TypeScript saves you time catching errors and
providing fixes before you run code.</p>
</blockquote>
<p>TypeScript <strong>cannot</strong> be converted to WebAssembly, however
<a href="https://www.assemblyscript.org/">AssemblyScript</a> is a <strong>subset</strong> of TypeScript
designed explicitly for WebAssembly.</p>
<h2 id="current-state-1"><a class="header" href="#current-state-1">Current State</a></h2>
<p>Currently there's currently no Kubewarden SDK for AssemblyScript, we haven't
created it bacause of lack of time. We will do that in the near future.</p>
<p>In the meantime, there seem to be some limitatations affecting AssemblyScript:</p>
<ul>
<li>There's no built-in way to Serialize and Deserilize classed to
and from JSON. See <a href="https://github.com/AssemblyScript/assemblyscript/issues/292">this issue</a></li>
<li>It <em>seems</em> there's no JSON path library for AssemblyScript</li>
</ul>
<h2 id="example-2"><a class="header" href="#example-2">Example</a></h2>
<p><a href="https://github.com/kubewarden/pod-privileged-policy">This GitHub repository</a>
contains a Kubewarden Policy written in AssemblyScript.</p>
<p><strong>Worth of note:</strong> this repository has a series of GitHub Actions that automate
the following tasks:</p>
<ul>
<li>Run unit tests and code linting on pull requests and after code is merged
into the main branch</li>
<li>Build the policy in <code>release</code> mode and push it to a OCI registry as an
artifact</li>
</ul>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="distributing-policies"><a class="header" href="#distributing-policies">Distributing Policies</a></h1>
<p>Kubewarden policies are Wasm binaries that are evaluated by the
Kubewarden Policy Server.</p>
<p>The Kubewarden policy server can load policies from these
sources:</p>
<ul>
<li>Local filesystem</li>
<li>HTTP(s) server</li>
<li>OCI compliant registry like <a href="https://github.com/distribution/distribution">distribution</a>
and other container registries (GitHub container registry, Azure Container
Registry, Amazon ECR, Google Container Registry, ...)</li>
</ul>
<p>We think distributing Kubewarden policies via a regular OCI compliant
registry is the best choice. Container registries are basically a
mandatory requirement for any Kubernetes cluster. Having a single
place to store, and secure, all the artifacts required by a cluster
can be really handy.</p>
<h1 id="pushing-policies-to-an-oci-compliant-registry"><a class="header" href="#pushing-policies-to-an-oci-compliant-registry">Pushing policies to an OCI compliant registry</a></h1>
<p>The <a href="https://github.com/opencontainers/artifacts">OCI Artifacts</a>
specification allows to store any kind of binary blob inside of a
regular OCI compliant container registry.</p>
<p>The target OCI compliant registry <strong>must support artifacts</strong> in order
to successfully push a Kubewarden Policy to it.</p>
<p>The <a href="https://github.com/engineerd/wasm-to-oci"><code>wasm-to-oci</code></a> command line tool
can be used to push a Kubewarden Policy to an OCI compliant registry.</p>
<p>Pushing a policy can be done in this way:</p>
<pre><code class="language-bash">$ wasm-to-oci push pod-runtime-class-policy.wasm \
              &lt;oci-registry&gt;/kubewarden-policies/pod-runtime-class-policy:v0.0.2
</code></pre>
<p>The policy can then be referenced from the Kubewarden Policy Server as
<code>registry://&lt;oci-registry&gt;/kubewarden-policies/pod-runtime-class-policy:v0.0.2</code>.</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="testing-policies"><a class="header" href="#testing-policies">Testing Policies</a></h1>
<p>This section covers the topic of testing Kubewarden Policies. There are two possible
personas interested in testing policies:</p>
<ul>
<li>As a policy author: you're writing a Kubewarden Policy and you want to ensure
your code behaves the way you expect.</li>
<li>As an end user: you found a Kubewarden Policy and you want to tune/test the policy
settings before deploying it, maybe you want to keep testing these settings
inside of your CI/CD pipelines,...</li>
</ul>
<p>The next sections of the documentation will show how Kubewarden policies can
be tested by these two personas.</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="while-creating-a-policy"><a class="header" href="#while-creating-a-policy">While creating a policy</a></h1>
<p>Kubewarden Policies are regular programs compiled as WebAssembly. As with any kind
of program, it's important to have good test coverage.</p>
<p>Policy authors can leverage the testing frameworks and tools of their language
of choice to verify the behaviour of their policies.</p>
<p>As an example, you can take a look at these Kubewarden policies:</p>
<ul>
<li><a href="https://github.com/kubewarden/psp-apparmor">psp-apparmor</a>: this
is a Kubewarden Policy written using <a href="testing-policies//writing-policies/rust/01-intro.html">Rust</a>.</li>
<li><a href="https://github.com/kubewarden/ingress-policy">ingress-policy</a>: this is
a Kubewarden Policy written using <a href="testing-policies//writing-policies/go/01-intro.html">Go</a>.</li>
<li><a href="https://github.com/kubewarden/pod-privileged-policy">pod-privileged-policy</a>: this
is a Kubewarden Policy written using <a href="https://www.assemblyscript.org/">AssemblyScript</a>.</li>
</ul>
<p>All these policies have integrated test suites built using the regular testing libraries
of Rust, Go and AssemblyScript.</p>
<p>Finally, all these projects rely on GitHub Actions to implement their CI pipelines.</p>
<h2 id="end-to-end-tests"><a class="header" href="#end-to-end-tests">End-to-end tests</a></h2>
<p>As a policy author you can also write tests that are executed against the actual
WebAssembly binary containing your policy. This can be done without having
to deploy a Kubernetes cluster by using these tools:</p>
<ul>
<li><a href="https://github.com/bats-core/bats-core">bats</a>: used to write the
tests and automate their execution.</li>
<li><a href="https://github.com/kubewarden/policy-server/releases">policy-testdrive</a>:
cli tool provided by Kubewarden to run its policies outside of
Kubernetes.</li>
</ul>
<p><code>policy-testdrive</code> usage is quite simple, we just have to invoke it with the
following data as input:</p>
<ol>
<li>Path to the WebAssembly binary file of the policy to be run. This is
specified through the <code>--policy</code> argument. Currently, <code>policy-testdrive</code>
can only load policies from the local filesystem.</li>
<li>Path to the file containing the admission request object to be evaluated.
This is provided via the <code>--request-file</code> argument.</li>
<li>The policy settings to be used at evaluation time, they can be provided
via <code>--settings</code> flag. The flag takes a JSON blob as parameter.</li>
</ol>
<p>Once the policy evaluation is done, <code>policy-testdrive</code> prints to the standard
output the <code>SettingsValidationResponse</code>and the <code>ValidationResponse</code> objects.</p>
<p>For example, this is how <code>policy-testdrive</code> can be used to test the
WebAssembly binary of the <code>ingress-policy</code> linked above:</p>
<pre><code>$ policy-testdrive -p ingress-policy.wasm \
    -r test_data/ingress-wildcard.json \
    -s '{&quot;allowPorts&quot;: [80], &quot;denyPorts&quot;: [3000]}'
Settings validation result: SettingsValidationResponse { valid: true, message: None }
Policy evaluation results:
ValidationResponse { uid: &quot;&quot;, allowed: false, patch_type: None, patch: None, status: Some(ValidationResponseStatus { message: Some(&quot;These ports are not on the allowed list: Set{3000}&quot;), code: None }) }
</code></pre>
<p>Using <code>bats</code> we can can write a test that runs this command and looks for the
expected outputs:</p>
<pre><code class="language-bash">@test &quot;all is good&quot; {
  run policy-testdrive -p ingress-policy.wasm \
    -r test_data/ingress-wildcard.json \
    -s '{&quot;allowPorts&quot;: [80], &quot;denyPorts&quot;: [3000]}'

  # this prints the output when one the checks below fails
  echo &quot;output = ${output}&quot;

  # settings validation passed
  [[ &quot;$output&quot; == *&quot;valid: true&quot;* ]]

  # request accepted
  [[ &quot;$output&quot; == *&quot;allowed: true&quot;* ]]
}
</code></pre>
<p>We can copy the snippet from above inside of a file called <code>e2e.bats</code>,
and then invoke <code>bats</code> in this way:</p>
<pre><code>$ bats e2e.bats
  all is good

1 tests, 0 failures
</code></pre>
<p>Checkout <a href="testing-policies//writing-policies/go/05-e2e-tests.html">this section</a>
of the documentation to learn more about writing end-to-end
tests of your policies.</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="before-deployment"><a class="header" href="#before-deployment">Before deployment</a></h1>
<p>As a Kubernetes cluster operator you probably want to perform some tests
against a Kubewarden policy you just found.</p>
<p>You probably want to answer questions like:</p>
<ul>
<li>What are the correct policy settings to get the validation/mutation outcome
I desire?</li>
<li>How can I be sure everything will keep working as expected when I upgrade
the policy to a newer version, when I add/change some Kubernetes resources,
when I change the configuration parameters of the policy,...</li>
</ul>
<p>Kubewarden has a dedicated utility that allows testing of the policies
outside of Kubernetes. This utility is called
<a href="https://github.com/kubewarden/policy-server/tree/main/crates/policy-testdrive"><code>policy-testdrive</code></a>.</p>
<p><code>policy-testdrive</code> usage is quite simple, we just have to invoke it with the
following data as input:</p>
<ol>
<li>Path to the WebAssembly binary file of the policy to be run. This is
specified through the <code>--policy</code> argument. Currently, <code>policy-testdrive</code>
can only load policies from the local filesystem.</li>
<li>Path to the file containing the admission request object to be evaluated.
This is provided via the <code>--request-file</code> argument.</li>
<li>The policy settings to be used at evaluation time, they can be provided
via <code>--settings</code> flag. The flag takes a JSON blob as parameter.</li>
</ol>
<p>Once the policy evaluation is done, <code>policy-testdrive</code> prints to the standard
output the <code>SettingsValidationResponse</code>and the <code>ValidationResponse</code> objects.</p>
<h2 id="install-1"><a class="header" href="#install-1">Install</a></h2>
<p>You can download pre-built binaries of <code>policy-testdrive</code>
from <a href="https://github.com/kubewarden/policy-server/releases">here</a>.</p>
<p>Currently <code>policy-testdrive</code> isn't able to download policies from OCI
registries. This can be done using the
<a href="https://github.com/engineerd/wasm-to-oci"><code>wasm-to-oci</code></a> tool.</p>
<p>Pre-built binaries of <code>wasm-to-oci</code>can be downloaded from the project's
<a href="https://github.com/engineerd/wasm-to-oci/releases">GitHub Releases page</a>.</p>
<h2 id="quickstart"><a class="header" href="#quickstart">Quickstart</a></h2>
<p>This section describes how to test the
<a href="https://github.com/kubewarden/psp-apparmor">psp-apparmor</a> policy
with different configurations and validation request objects as input data.</p>
<p>We begin by downloading the WebAssembly binary of the policy, we will
do that using the <code>wasm-to-oci</code> tool:</p>
<pre><code class="language-shell">wasm-to-oci pull ghcr.io/kubewarden/policies/psp-apparmor:v0.1.2
</code></pre>
<p>This will produce the following output:</p>
<pre><code class="language-shell">INFO[0001] Pulled: ghcr.io/kubewarden/policies/psp-apparmor:v0.1.2 
INFO[0001] Size: 2682915
INFO[0001] Digest: sha256:5532a49834af8cc929994a65c0881190ef168295fffd2bed4e7325d2e91484b5 
</code></pre>
<p>This creates a <code>module.wasm</code> file in the current directory.</p>
<h3 id="create-admissionreview-requests"><a class="header" href="#create-admissionreview-requests">Create <code>AdmissionReview</code> requests</a></h3>
<p>We have to create some files holding the <code>AdmissionReview</code> objects that
will be evaluated by the policy.</p>
<p>Let's create a file named <code>pod-req-no-specific-apparmor-profile.json</code> with the following
contents:</p>
<pre><code class="language-json">{
  &quot;kind&quot;: {
    &quot;kind&quot;: &quot;Pod&quot;,
    &quot;version&quot;: &quot;v1&quot;
  },
  &quot;object&quot;: {
    &quot;metadata&quot;: {
      &quot;name&quot;: &quot;no-apparmor&quot;
    },
    &quot;spec&quot;: {
      &quot;containers&quot;: [
        {
          &quot;image&quot;: &quot;nginx&quot;,
          &quot;name&quot;: &quot;nginx&quot;
        }
      ]
    }
  },
  &quot;operation&quot;: &quot;CREATE&quot;,
  &quot;requestKind&quot;: {&quot;version&quot;: &quot;v1&quot;, &quot;kind&quot;: &quot;Pod&quot;},
  &quot;userInfo&quot;: {
    &quot;username&quot;: &quot;alice&quot;,
    &quot;uid&quot;: &quot;alice-uid&quot;,
    &quot;groups&quot;: [&quot;system:authenticated&quot;]
  }
}
</code></pre>
<p>This request tries to create a Pod that doesn't specify any AppArmor
profile to be used, that's because it doesn't have an <code>annotation</code> with the
<code>container.apparmor.security.beta.kubernetes.io/&lt;name of the container&gt;</code>
key.</p>
<p>Let's create a file named <code>pod-req-apparmor-unconfined.json</code> with the following
contents:</p>
<pre><code class="language-json">{
  &quot;kind&quot;: {
    &quot;kind&quot;: &quot;Pod&quot;,
    &quot;version&quot;: &quot;v1&quot;
  },
  &quot;object&quot;: {
    &quot;metadata&quot;: {
      &quot;name&quot;: &quot;privileged-pod&quot;,
      &quot;annotations&quot;: {
        &quot;container.apparmor.security.beta.kubernetes.io/nginx&quot;: &quot;unconfined&quot;
      }
    },
    &quot;spec&quot;: {
      &quot;containers&quot;: [
        {
          &quot;image&quot;: &quot;nginx&quot;,
          &quot;name&quot;: &quot;nginx&quot;
        }
      ]
    }
  },
  &quot;operation&quot;: &quot;CREATE&quot;,
  &quot;requestKind&quot;: {&quot;version&quot;: &quot;v1&quot;, &quot;kind&quot;: &quot;Pod&quot;},
  &quot;userInfo&quot;: {
    &quot;username&quot;: &quot;alice&quot;,
    &quot;uid&quot;: &quot;alice-uid&quot;,
    &quot;groups&quot;: [&quot;system:authenticated&quot;]
  }
}
</code></pre>
<p>This request tries to create a Pod with a container called <code>nginx</code> that runs
with the <code>unconfined</code> AppArmor profile. Note well, running in <code>unconfined</code> mode
is a bad security practice.</p>
<p>Finally, let's create a file named <code>pod-req-apparmor-custom.json</code> with the following
contents:</p>
<pre><code class="language-json">{
  &quot;kind&quot;: {
    &quot;kind&quot;: &quot;Pod&quot;,
    &quot;version&quot;: &quot;v1&quot;
  },
  &quot;object&quot;: {
    &quot;metadata&quot;: {
      &quot;name&quot;: &quot;privileged-pod&quot;,
      &quot;annotations&quot;: {
        &quot;container.apparmor.security.beta.kubernetes.io/nginx&quot;: &quot;localhost/nginx-custom&quot;
      }
    },
    &quot;spec&quot;: {
      &quot;containers&quot;: [
        {
          &quot;image&quot;: &quot;nginx&quot;,
          &quot;name&quot;: &quot;nginx&quot;
        }
      ]
    }
  },
  &quot;operation&quot;: &quot;CREATE&quot;,
  &quot;requestKind&quot;: {&quot;version&quot;: &quot;v1&quot;, &quot;kind&quot;: &quot;Pod&quot;},
  &quot;userInfo&quot;: {
    &quot;username&quot;: &quot;alice&quot;,
    &quot;uid&quot;: &quot;alice-uid&quot;,
    &quot;groups&quot;: [&quot;system:authenticated&quot;]
  }
}
</code></pre>
<p>This request tries to create a Pod with a container called <code>nginx</code> that uses the
<code>nginx-custom</code> profile provided by the administrators of the Kubernetes cluster.</p>
<blockquote>
<p><strong>Note well:</strong> these are stripped down <code>AdmissionReview</code> objects, we left
only the fields that are relevant to our policy.</p>
</blockquote>
<h3 id="test-the-policy"><a class="header" href="#test-the-policy">Test the policy</a></h3>
<p>Now we can use <code>policy-testdrive</code> to test the creation of a Pod that doesn't
specify an AppArmor profile:</p>
<pre><code class="language-console">policy-testdrive --policy module.wasm \
  --request-file pod-req-no-specific-apparmor-profile.json
</code></pre>
<p>The policy will accept the request and produce the following output:</p>
<pre><code class="language-console">Settings validation result: SettingsValidationResponse { valid: true, message: None }
Policy evaluation results:
ValidationResponse { uid: &quot;&quot;, allowed: true, patch_type: None, patch: None, status: None }
</code></pre>
<p>The policy will instead reject the creation of a Pod with an <code>unconfined</code> AppArmor
profile:</p>
<pre><code class="language-console">$ policy-testdrive --policy module.wasm \
  --request-file pod-req-apparmor-unconfined.json

Settings validation result: SettingsValidationResponse { valid: true, message: None }
Policy evaluation results:
ValidationResponse { uid: &quot;&quot;, allowed: false, patch_type: None, patch: None, status: Some(ValidationResponseStatus { message: Some(&quot;These AppArmor profiles are not allowed: [\&quot;unconfined\&quot;]&quot;), code: None }) }
</code></pre>
<p>Both times we did a test drive of the policy <strong>without</strong> providing any kind of
setting. As the <a href="https://github.com/kubewarden/psp-apparmor#configuration">policy's documentation</a>
states, this results in preventing the usage of non-default profiles.</p>
<p>As a matter of fact, the Pod using a custom <code>nginx</code> profile gets rejected by
the policy too:</p>
<pre><code class="language-console">$ policy-testdrive --policy module.wasm \
  --request-file pod-req-apparmor-custom.json

Settings validation result: SettingsValidationResponse { valid: true, message: None }
Policy evaluation results:
ValidationResponse { uid: &quot;&quot;, allowed: false, patch_type: None, patch: None, status: Some(ValidationResponseStatus { message: Some(&quot;These AppArmor profiles are not allowed: [\&quot;localhost/nginx-custom\&quot;]&quot;), code: None }) }
</code></pre>
<p>We can change the default behaviour and allow some chosen AppArmor to be used:</p>
<pre><code class="language-console">policy-testdrive --policy module.wasm \
  --request-file pod-req-apparmor-custom.json \
  --settings '{&quot;allowed_profiles&quot;: [&quot;runtime/default&quot;, &quot;localhost/nginx-custom&quot;]}'
</code></pre>
<p>This time the request is accepted:</p>
<pre><code class="language-console">Settings validation result: SettingsValidationResponse { valid: true, message: None }
Policy evaluation results:
ValidationResponse { uid: &quot;&quot;, allowed: true, patch_type: None, patch: None, status: None }
</code></pre>
<h2 id="automation"><a class="header" href="#automation">Automation</a></h2>
<p>All these steps shown above can be automated using
<a href="https://github.com/bats-core/bats-core">bats</a>.</p>
<p>We can write a series of tests and integrate their execution inside
of your existing CI and CD pipelines.</p>
<p>That would ensure changes to the policy version, policy configuration
parameters, Kubernetes resources,... won't break the outcome of the
validation/mutation operations.</p>
<p>The commands used above can be easily &quot;wrapped&quot; into a <code>bats</code> test:</p>
<pre><code class="language-bash">@test &quot;all is good&quot; {
  run policy-testdrive --policy module.wasm \
    --request-file pod-req-no-specific-apparmor-profile.json

  # this prints the output when one the checks below fails
  echo &quot;output = ${output}&quot;

  # settings validation passed
  [[ &quot;$output&quot; == *&quot;valid: true&quot;* ]]

  # request accepted
  [[ &quot;$output&quot; == *&quot;allowed: true&quot;* ]]
}

@test &quot;reject&quot; {
  run policy-testdrive --policy module.wasm \
    --request-file pod-req-apparmor-custom.json

  # this prints the output when one the checks below fails
  echo &quot;output = ${output}&quot;

  # settings validation passed
  [[ &quot;$output&quot; == *&quot;valid: true&quot;* ]]

  # request rejected
  [[ &quot;$output&quot; == *&quot;allowed: false&quot;* ]]
}
</code></pre>
<p>Assuming the snippet from above is inside of a file called <code>e2e.bats</code>,
we can run the test in this way:</p>
<pre><code>$ bats e2e.bats
  all is good
  reject

2 tests, 0 failures
</code></pre>
<p>Checkout <a href="testing-policies//writing-policies/go/05-e2e-tests.html">this section</a>
of the documentation to learn more about writing end-to-end
tests of your policies.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>
