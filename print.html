<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Kubewarden Kubernetes Policy Engine</title>
        
        <meta name="robots" content="noindex" />
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="Documentation of Kubewarden project">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        
        <link rel="icon" href="favicon.svg">
        
        
        <link rel="shortcut icon" href="favicon.png">
        
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="introduction.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="quick-start.html"><strong aria-hidden="true">2.</strong> Quick Start</a></li><li class="chapter-item expanded "><a href="testing-policies.html"><strong aria-hidden="true">3.</strong> Testing Policies</a></li><li class="chapter-item expanded "><a href="writing-policies/index.html"><strong aria-hidden="true">4.</strong> Writing Policies</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="writing-policies/rust.html"><strong aria-hidden="true">4.1.</strong> Rust</a></li><li class="chapter-item expanded "><a href="writing-policies/go/01-intro.html"><strong aria-hidden="true">4.2.</strong> Go</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="writing-policies/go/02-scaffold.html"><strong aria-hidden="true">4.2.1.</strong> Create a new policy</a></li><li class="chapter-item expanded "><a href="writing-policies/go/03-policy-settings.html"><strong aria-hidden="true">4.2.2.</strong> Define policy settings</a></li><li class="chapter-item expanded "><a href="writing-policies/go/04-validation.html"><strong aria-hidden="true">4.2.3.</strong> Write the validation logic</a></li><li class="chapter-item expanded "><a href="writing-policies/go/05-e2e-tests.html"><strong aria-hidden="true">4.2.4.</strong> End-to-end testing</a></li><li class="chapter-item expanded "><a href="writing-policies/go/06-automate.html"><strong aria-hidden="true">4.2.5.</strong> GitHub Action integration</a></li><li class="chapter-item expanded "><a href="writing-policies/go/07-distribute.html"><strong aria-hidden="true">4.2.6.</strong> Distribute policy</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="distributing-policies.html"><strong aria-hidden="true">5.</strong> Distributing Policies</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">Kubewarden Kubernetes Policy Engine</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                        <a href="https://github.com/kubewarden/docs" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <blockquote>
<p><strong>WARNING:</strong> Kubewarden is in early development stage, it's not production ready.</p>
<p>Feedback is highly appreciated.</p>
</blockquote>
<h1><a class="header" href="#introduction" id="introduction">Introduction</a></h1>
<p>Kubewarden is a <a href="https://kubernetes.io/docs/reference/access-authn-authz/extensible-admission-controllers/">Kubernetes Dynamic Admission
Controller</a>
that validates incoming requests using policies written in
WebAssembly.</p>
<h2><a class="header" href="#what-is-webassembly" id="what-is-webassembly">What is WebAssembly?</a></h2>
<p>As stated on <a href="https://webassembly.org/">WebAssembly's official
website</a>:</p>
<blockquote>
<p>WebAssembly (abbreviated Wasm) is a binary instruction format for a
stack-based virtual machine. Wasm is designed as a portable
compilation target for programming languages, enabling deployment on
the web for client and server applications.</p>
</blockquote>
<p>WebAssembly has been originally conceived as an &quot;extension&quot; of
browsers. However, recent efforts have been made by the WebAssembly
community to allow the execution of WebAssembly code outside of
browsers.</p>
<h2><a class="header" href="#why-use-webassembly" id="why-use-webassembly">Why use WebAssembly?</a></h2>
<p>By using WebAssembly, users can write Kubernetes policies using their
favorite programming language, as long as the language can produce
Wasm binaries.</p>
<p>Policy authors can reuse their skills, tools and best
practices. Policies are &quot;traditional&quot; programs that can have reusable
blocks (regular libraries), can be tested, can be linted, can be
plugged into their current CI and CD workflows,...</p>
<p>Wasm modules are portable, once built they can run on any kind of
processor architecture and Operating System. A policy built on a Apple
Silicon machine can be run on a x86_64 Linux server without any
conversion.</p>
<h2><a class="header" href="#policy-distribution" id="policy-distribution">Policy distribution</a></h2>
<p>Kubewarden Policies can be served by a regular web server or, even
better, can be published inside of an OCI compliant registry.</p>
<p>Kubewarden Policies can be stored inside of an OCI compliant registry as
<a href="https://github.com/opencontainers/artifacts">OCI artifacts</a>.</p>
<h1><a class="header" href="#quick-start" id="quick-start">Quick Start</a></h1>
<p>The Kubewarden stack is made of the following components:</p>
<ul>
<li>An arbitrary number of <code>ClusterAdmissionPolicy</code> resources: this is how policies
are defined inside of Kubernetes</li>
<li>A Deployment of Kubewarden <code>policy-server</code>: this component loads all the
policies defined by the administrators and evaluates them</li>
<li>A Deployment of <code>kubewarden-controller</code>: this is the controller that monitors
the <code>AdmissionPolicy</code> resources and interacts with the Kubewarden <code>policy-server</code></li>
</ul>
<h2><a class="header" href="#install" id="install">Install</a></h2>
<p>The Kubewarden stack can be deployed using a helm chart:</p>
<pre><code class="language-console">helm repo add kubewarden https://charts.kubewarden.io
helm install --namespace kubewarden --create-namespace kubewarden-controller kubewarden/kubewarden-controller
</code></pre>
<p>This will install <code>kubewarden-controller</code> on the Kubernetes cluster in the default
configuration and will register the <code>AdmissionPolicy</code> Custom Resource. The
components of the Kubewarden stack will be deployed inside of a Kubernetes
Namespace called <code>kubewarden</code>.</p>
<p>The default configuration values should be good enough for the majority of
deployments, all the options are documented <a href="https://charts.kubewarden.io/#configuration">here</a>.</p>
<p>The Kubewarden Policy Server is completely managed by the kubewarden-controller.</p>
<h2><a class="header" href="#kubewarden-policies" id="kubewarden-policies">Kubewarden Policies</a></h2>
<p>Enforcing policies is by far the most common operation a Kubernetes
administrator will perform. You can declare as many policies as you want,
targeting any kind of Kubernetes resource and type of operation that can be
done against them.</p>
<p>The <code>ClusterAdmissionPolicy</code> resource is the core of the Kubewarden stack: this is
how validating policies are defined.</p>
<pre><code class="language-yaml">apiVersion: policies.kubewarden.io/v1alpha1
kind: ClusterAdmissionPolicy
metadata:
  name: psp-capabilities
spec:
  module: registry://ghcr.io/kubewarden/policies/psp-capabilities:v0.1.1
  resources:
  - pods
  operations:
  - CREATE
  - UPDATE
  mutating: true
  settings:
    allowed_capabilities:
    - CHOWN
    required_drop_capabilities:
    - NET_ADMIN
</code></pre>
<p>This is a quick overview of the attributes of the <code>ClusterAdmissionPolicy</code> resource:</p>
<ul>
<li><code>module</code>: this is the location of the Kubewarden policy, several schemas are
supported.
<ul>
<li><code>registry</code>: download from an <a href="https://github.com/opencontainers/artifacts">OCI artifacts</a>
compliant container registry</li>
<li><code>http</code>, <code>https</code>: download from a regular HTTP(s) server</li>
<li><code>file</code>: load the module from the local filesystem</li>
</ul>
</li>
<li><code>resources</code>: types of resources evaluated by the policy</li>
<li><code>operations</code>: what operations for the previously given types should
be forwarded to this admission policy by the API server for
evaluation.</li>
<li><code>mutating</code>: a boolean value that must be set to <code>true</code> for policies that can
mutate incoming requests.</li>
<li><code>settings</code> (optional): a free-form object that contains the policy
configuration values.</li>
<li><code>failurePolicy</code> (optional): how unrecognized errors and timeout errors from
the policy are handled. Allowed values are <code>Ignore</code> or <code>Fail</code>. <code>Ignore</code> means
that an error calling the webhook is ignored and the API request is allowed
to continue. <code>Fail</code> means that an error calling the webhook causes the
admission to fail and the API request to be rejected.
The default behaviour is <code>Fail</code>.</li>
</ul>
<p>The complete documentation of this Custom Resource can be found
<a href="https://github.com/kubewarden/kubewarden-controller/blob/main/docs/crds/README.asciidoc">here</a>
or on
<a href="https://doc.crds.dev/github.com/kubewarden/kubewarden-controller">docs.crds.dev</a>.</p>
<blockquote>
<p><strong>NOTE:</strong> ClusterAdmissionPolicy resources are registered with a <code>*</code> webhook
<code>scope</code>, which means that registered webhooks will be forwarded all
requests matching the given <code>resources</code> and <code>operations</code> -- either
namespaced (in any namespace), or cluster-wide resources.</p>
</blockquote>
<blockquote>
<p><strong>NOTE:</strong> The <code>ClusterAdmissionPolicy</code> resource is cluster-wide. There are
plans to also provide a namespaced version that will only impact
registered namespaced resources on its own namespace.</p>
</blockquote>
<h2><a class="header" href="#enforce-your-first-policy" id="enforce-your-first-policy">Enforce your first policy</a></h2>
<p>We will use the <a href="https://github.com/kubewarden/pod-privileged-policy"><code>pod-privileged</code> policy</a>.
This policy prevents the creation of privileged containers inside of a Kubernetes cluster.</p>
<p>Let's define a <code>ClusterAdmissionPolicy</code> for that:</p>
<pre><code class="language-shell">kubectl apply -f - &lt;&lt;EOF
apiVersion: policies.kubewarden.io/v1alpha1
kind: ClusterAdmissionPolicy
metadata:
  name: privileged-pods
spec:
  module: registry://ghcr.io/kubewarden/policies/pod-privileged:v0.1.4
  resources:
  - pods
  operations:
  - CREATE
  - UPDATE
  mutating: false
EOF
</code></pre>
<p>This will produce the following output:
<code>clusteradmissionpolicy.policies.kubewarden.io/privileged-pods created</code></p>
<p>Defining the <code>ClusterAdmissionPolicy</code> will lead to a rollout of the Kubewarden Policy
Server Deployment. Once the new policy is ready to be served, the <code>kubewarden-controller</code>
will register a <a href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.20/#validatingwebhookconfiguration-v1-admissionregistration-k8s-io">ValidatingWebhookConfiguration</a>
object.</p>
<p>Once all the instances of <code>policy-server</code> are ready, the
<code>ValidatingWebhookConfiguration</code> can be shown with:</p>
<pre><code class="language-shell">kubectl get validatingwebhookconfigurations.admissionregistration.k8s.io -l kubewarden
</code></pre>
<p>Which will output something like</p>
<pre><code>NAME              WEBHOOKS   AGE
privileged-pods   1          9s
</code></pre>
<p>Let's try to create a Pod with no privileged containers:</p>
<pre><code class="language-shell">kubectl apply -f - &lt;&lt;EOF
apiVersion: v1
kind: Pod
metadata:
  name: unprivileged-pod
spec:
  containers:
    - name: nginx
      image: nginx:latest
EOF
</code></pre>
<p>This will produce the following output, which means the Pod was successfully
created:</p>
<p><code>pod/unprivileged-pod created</code></p>
<p>Now, let's try to create a pod with at least one privileged container:</p>
<pre><code class="language-shell">kubectl apply -f - &lt;&lt;EOF
apiVersion: v1
kind: Pod
metadata:
  name: privileged-pod
spec:
  containers:
    - name: nginx
      image: nginx:latest
      securityContext:
          privileged: true
EOF
</code></pre>
<p>This time the creation of the Pod will be blocked, with the following message:</p>
<pre><code>Error from server: error when creating &quot;STDIN&quot;: admission webhook &quot;privileged-pods.kubewarden.admission&quot; denied the request: User 'minikube-user' cannot schedule privileged containers
</code></pre>
<h2><a class="header" href="#uninstall" id="uninstall">Uninstall</a></h2>
<p>As a first step remove all the <code>ClusterAdmissionPolicy</code> resources you have created.
This can be done with the following command:</p>
<pre><code class="language-shell">kubectl delete --all clusteradmissionpolicies.policies.kubewarden.io
</code></pre>
<p>Then wait for the for the <code>kubewarden-controller</code> to remove all the
Kubernetes <code>ValidatingWebhookConfiguration</code> and the <code>MutatingWebhookConfiguration</code>
resources it created.</p>
<p>This can be monitored with the following command:</p>
<pre><code class="language-shell">kubectl get validatingwebhookconfigurations.admissionregistration.k8s.io -l &quot;kubewarden&quot; &amp;&amp; \
kubectl get mutatingwebhookconfigurations.admissionregistration.k8s.io -l &quot;kubewarden&quot;
</code></pre>
<p>If these resources are not automatically removed, you can do
remove them manually by using the following command:</p>
<pre><code class="language-shell">kubectl delete -l &quot;kubewarden&quot; validatingwebhookconfigurations.admissionregistration.k8s.io &amp;&amp; \
kubectl delete -l &quot;kubewarden&quot; mutatingwebhookconfigurations.admissionregistration.k8s.io
</code></pre>
<p>Finally you can uninstall the Helm chart:</p>
<pre><code class="language-shell">helm uninstall kubewarden-controller
</code></pre>
<p>Once this is done you can remove the Kubernetes namespace that was used to deploy
the Kubewarden stack:</p>
<pre><code class="language-shell">kubectl delete namespace kubewarden
</code></pre>
<p>This will delete all the resources that were created at runtime by the <code>kubewarden-controller</code>,
like the <code>policy-server</code> Deployment.</p>
<blockquote>
<p><strong>Note well:</strong> it's extremely important to remove the <code>ValidatingWebhookConfiguration</code>
and <code>MutatingWebhookConfiguration</code> resources <strong>before</strong> the
<code>policy-server</code> Deployment. Otherwise the Kubernetes
API server will continuously face timeout errors while trying to evaluate the
incoming requests.</p>
<p>By default the <code>ValidatingWebhookConfiguration</code> and <code>MutatingWebhookConfiguration</code>
resources created by Kubewarden have <code>policyFailure</code>
set to <code>Fail</code>, which will cause all these incoming requests to be rejected.</p>
<p><strong>This could bring havoc on your cluster.</strong></p>
</blockquote>
<h2><a class="header" href="#wrapping-up" id="wrapping-up">Wrapping up</a></h2>
<p>As we have seen, the <code>ClusterAdmissionPolicy</code> resource is the core type that
a cluster operator has to manage, the rest of the resources needed to
run the policies and configure them will be taken care of
automatically by the <code>kubewarden-controller</code> project.</p>
<h1><a class="header" href="#testing-policies" id="testing-policies">Testing Policies</a></h1>
<p>This section covers the topic of testing Kubewarden Policies. There are two possible
personas interested in testing policies:</p>
<ul>
<li>As a policy author: you're writing a Kubewarden Policy and you want to ensure
your code behaves the way you expect.</li>
<li>As an end user: you found a Kubewarden Policy and you want to tune/test the policy
settings before deploying it, maybe you want to keep testing these settings
inside of your CI/CD pipelines,...</li>
</ul>
<h1><a class="header" href="#kubewarden-policy-authors" id="kubewarden-policy-authors">Kubewarden Policy authors</a></h1>
<p>Kubewarden Policies are regular programs compiled as WebAssembly. As with any kind
of program, it's important to have a good test coverage.</p>
<p>Policy authors can leverage the testing frameworks and tools of their language
of choice to verify the behaviour of their policies.</p>
<p>As an example, you can take a look at these Kubewarden policies:</p>
<ul>
<li><a href="https://github.com/kubewarden/pod-privileged-policy">pod-privileged-policy</a>: this
is a Kubewarden Policy written using <a href="https://www.assemblyscript.org/">AssemblyScript</a>.</li>
<li><a href="https://github.com/kubewarden/psp-apparmor">psp-apparmor</a>: this
is a Kubewarden Policy written using <a href="https://www.rust-lang.org/">Rust</a>.</li>
</ul>
<p>Both policies have integrated test suites built using the regular testing libraries
of Rust and AssemblyScript.</p>
<p>Finally, both projects rely on GitHub actions to implement their CI pipelines.</p>
<h1><a class="header" href="#end-users" id="end-users">End users</a></h1>
<p>Aside from the approach of testing policy logic with the tools that
your language toolchain already provides, Kubewarden has a dedicated
project for testing policies:
<a href="https://github.com/kubewarden/policy-server/tree/main/crates/policy-testdrive"><code>policy-testdrive</code></a>.</p>
<p>The concept of <code>policy-testdrive</code> is quite simple from a user
point of view. You have to provide:</p>
<ol>
<li>The Wasm file providing the policy to be tested. The file is specified through
the <code>--policy</code> argument. At this  time you can only load files in the local
filesystem.</li>
<li>A file containing the admission request object to be evaluated by
the policy. This is provided via the <code>--request-file</code> argument.</li>
<li>The policy settings to be used at evaluation time, they can be provided
via <code>--settings</code> flag. The flag takes a JSON blob as parameter.</li>
</ol>
<h2><a class="header" href="#install-1" id="install-1">Install</a></h2>
<p>You can download pre-built binaries of <code>policy-testdrive</code>
from <a href="https://github.com/kubewarden/policy-server/releases">here</a>.</p>
<h2><a class="header" href="#quickstart" id="quickstart">Quickstart</a></h2>
<h3><a class="header" href="#prerequisites" id="prerequisites">Prerequisites</a></h3>
<p>We will use <a href="https://github.com/engineerd/wasm-to-oci"><code>wasm-to-oci</code></a>
to download a Kubewarden Policy published on a Container registry.</p>
<p>Pre-built binaries of <code>wasm-to-oci</code>can be downloaded from the project's
<a href="https://github.com/engineerd/wasm-to-oci/releases">GitHub Releases page</a>.</p>
<h3><a class="header" href="#obtain-a-kubewarden-policy" id="obtain-a-kubewarden-policy">Obtain a Kubewarden policy</a></h3>
<p>We will download the
<a href="https://github.com/kubewarden/psp-apparmor">psp-apparmor</a> policy:</p>
<pre><code class="language-console">wasm-to-oci pull ghcr.io/kubewarden/policies/psp-apparmor:v0.1.2
</code></pre>
<p>This will produce the following output:</p>
<pre><code class="language-console">INFO[0001] Pulled: ghcr.io/kubewarden/policies/psp-apparmor:v0.1.2 
INFO[0001] Size: 2682915
INFO[0001] Digest: sha256:5532a49834af8cc929994a65c0881190ef168295fffd2bed4e7325d2e91484b5 
</code></pre>
<p>This should have created a <code>module.wasm</code> file in the current directory.</p>
<h3><a class="header" href="#create-admissionreview-requests" id="create-admissionreview-requests">Create <code>AdmissionReview</code> requests</a></h3>
<p>We have to create some files holding the <code>AdmissionReview</code> objects that
will be evaluated by the policy.</p>
<p>Let's create a file named <code>pod-req-no-specific-apparmor-profile.json</code> with the following
contents:</p>
<pre><code class="language-json">{
  &quot;kind&quot;: {
    &quot;kind&quot;: &quot;Pod&quot;,
    &quot;version&quot;: &quot;v1&quot;
  },
  &quot;object&quot;: {
    &quot;metadata&quot;: {
      &quot;name&quot;: &quot;no-apparmor&quot;
    },
    &quot;spec&quot;: {
      &quot;containers&quot;: [
        {
          &quot;image&quot;: &quot;nginx&quot;,
          &quot;name&quot;: &quot;nginx&quot;
        }
      ]
    }
  },
  &quot;operation&quot;: &quot;CREATE&quot;,
  &quot;requestKind&quot;: {&quot;version&quot;: &quot;v1&quot;, &quot;kind&quot;: &quot;Pod&quot;},
  &quot;userInfo&quot;: {
    &quot;username&quot;: &quot;alice&quot;,
    &quot;uid&quot;: &quot;alice-uid&quot;,
    &quot;groups&quot;: [&quot;system:authenticated&quot;]
  }
}
</code></pre>
<p>This request tries to create a Pod that doesn't specify any AppArmor
profile to be used, that's because it doesn't have an <code>annotation</code> with the
<code>container.apparmor.security.beta.kubernetes.io/&lt;name of the container&gt;</code>
key.</p>
<p>Let's create a file named <code>pod-req-apparmor-unconfined.json</code> with the following
contents:</p>
<pre><code class="language-json">{
  &quot;kind&quot;: {
    &quot;kind&quot;: &quot;Pod&quot;,
    &quot;version&quot;: &quot;v1&quot;
  },
  &quot;object&quot;: {
    &quot;metadata&quot;: {
      &quot;name&quot;: &quot;privileged-pod&quot;,
      &quot;annotations&quot;: {
        &quot;container.apparmor.security.beta.kubernetes.io/nginx&quot;: &quot;unconfined&quot;
      }
    },
    &quot;spec&quot;: {
      &quot;containers&quot;: [
        {
          &quot;image&quot;: &quot;nginx&quot;,
          &quot;name&quot;: &quot;nginx&quot;
        }
      ]
    }
  },
  &quot;operation&quot;: &quot;CREATE&quot;,
  &quot;requestKind&quot;: {&quot;version&quot;: &quot;v1&quot;, &quot;kind&quot;: &quot;Pod&quot;},
  &quot;userInfo&quot;: {
    &quot;username&quot;: &quot;alice&quot;,
    &quot;uid&quot;: &quot;alice-uid&quot;,
    &quot;groups&quot;: [&quot;system:authenticated&quot;]
  }
}
</code></pre>
<p>This request tries to create a Pod with a container called <code>nginx</code> that is going
to be run with the <code>unconfined</code> AppArmor profile. This is considered a bad
security practice.</p>
<p>Finally, let's create a file named <code>pod-req-apparmor-custom.json</code> with the following
contents:</p>
<pre><code class="language-json">{
  &quot;kind&quot;: {
    &quot;kind&quot;: &quot;Pod&quot;,
    &quot;version&quot;: &quot;v1&quot;
  },
  &quot;object&quot;: {
    &quot;metadata&quot;: {
      &quot;name&quot;: &quot;privileged-pod&quot;,
      &quot;annotations&quot;: {
        &quot;container.apparmor.security.beta.kubernetes.io/nginx&quot;: &quot;localhost/nginx-custom&quot;
      }
    },
    &quot;spec&quot;: {
      &quot;containers&quot;: [
        {
          &quot;image&quot;: &quot;nginx&quot;,
          &quot;name&quot;: &quot;nginx&quot;
        }
      ]
    }
  },
  &quot;operation&quot;: &quot;CREATE&quot;,
  &quot;requestKind&quot;: {&quot;version&quot;: &quot;v1&quot;, &quot;kind&quot;: &quot;Pod&quot;},
  &quot;userInfo&quot;: {
    &quot;username&quot;: &quot;alice&quot;,
    &quot;uid&quot;: &quot;alice-uid&quot;,
    &quot;groups&quot;: [&quot;system:authenticated&quot;]
  }
}
</code></pre>
<p>This request tries to create a Pod with a container called <code>nginx</code> that is going
to be run with the profile provided by the administrators of the Kubernetes cluster.
This profile is called <code>nginx-custom</code>.</p>
<blockquote>
<p><strong>Note well:</strong> these are stripped down <code>AdmissionReview</code> objects, we left
only the fields that are relevant to our policy.</p>
</blockquote>
<h3><a class="header" href="#test-the-policy" id="test-the-policy">Test the policy</a></h3>
<p>Now we can use <code>policy-testdrive</code> to test the creation of a Pod that doesn't
specify an AppArmor profile:</p>
<pre><code class="language-console">policy-testdrive --policy module.wasm --request-file pod-req-no-specific-apparmor-profile.json
</code></pre>
<p>The policy will accept the request and produce the following output:</p>
<pre><code class="language-console">Settings validation result: SettingsValidationResponse { valid: true, message: None }
Policy evaluation results:
ValidationResponse { uid: &quot;&quot;, allowed: true, patch_type: None, patch: None, status: None }
</code></pre>
<p>The policy will instead reject the creation of a Pod with an <code>unconfined</code> AppArmor
profile:</p>
<pre><code class="language-console">$ policy-testdrive --policy module.wasm --request-file pod-req-apparmor-unconfined.json

Settings validation result: SettingsValidationResponse { valid: true, message: None }
Policy evaluation results:
ValidationResponse { uid: &quot;&quot;, allowed: false, patch_type: None, patch: None, status: Some(ValidationResponseStatus { message: Some(&quot;These AppArmor profiles are not allowed: [\&quot;unconfined\&quot;]&quot;), code: None }) }
</code></pre>
<p>Both times we did a test drive of the policy <strong>without</strong> providing any kind of
setting. As the <a href="https://github.com/kubewarden/psp-apparmor#configuration">policy's documentation</a>
states, this results in preventing the usage of non-default profiles.</p>
<p>As a matter of fact, the Pod using a custom <code>nginx</code> profile gets rejected by
the policy too:</p>
<pre><code class="language-console">$ policy-testdrive --policy module.wasm --request-file pod-req-apparmor-custom.json 

Settings validation result: SettingsValidationResponse { valid: true, message: None }
Policy evaluation results:
ValidationResponse { uid: &quot;&quot;, allowed: false, patch_type: None, patch: None, status: Some(ValidationResponseStatus { message: Some(&quot;These AppArmor profiles are not allowed: [\&quot;localhost/nginx-custom\&quot;]&quot;), code: None }) }
</code></pre>
<p>We can change the default behaviour and allow some chosen AppArmor to be used:</p>
<pre><code class="language-console">policy-testdrive --policy module.wasm \
  --request-file pod-req-apparmor-custom.json \
  --settings '{&quot;allowed_profiles&quot;: [&quot;runtime/default&quot;, &quot;localhost/nginx-custom&quot;]}'
</code></pre>
<p>This time the request is accepted:</p>
<pre><code class="language-console">Settings validation result: SettingsValidationResponse { valid: true, message: None }
Policy evaluation results:
ValidationResponse { uid: &quot;&quot;, allowed: true, patch_type: None, patch: None, status: None }
</code></pre>
<h2><a class="header" href="#wrapping-up-1" id="wrapping-up-1">Wrapping up</a></h2>
<p>Testing Kubewarden Policies is extremely important.</p>
<p>As a Kubewarden Policy author you can leverage the testing frameworks of your favorite
programming language and combine it with the CI systems of your choice to
ensure your code behaves as expected.</p>
<p>As a Kubewarden Policy end user you can use <code>policy-testdrive</code> to test
policies and their tuning outside of Kubernetes.</p>
<h1><a class="header" href="#what-is-a-kubewarden-policy" id="what-is-a-kubewarden-policy">What is a Kubewarden policy</a></h1>
<p>In this section we will explain what Kubewarden policies are by using some traditional computing
analogies.</p>
<p>A Kubewarden policy can be seen as a regular program that does one job: it receives
input data, performs some computation against that and it finally returns a response.</p>
<p>The input data are Kubernetes admission requests and the result of the computation
is a validation response, something that tells to Kubernetes whether to accept, reject or
mutate the original input data.</p>
<p>All these operations are performed by a component of Kubewarden that is called
<a href="https://github.com/kubewarden/policy-server">policy-server</a>.</p>
<p>The policy server doesn't bundle any data processing capability. All these capabilities are
added at runtime via add-ons: the Kubewarden policies.</p>
<p>As a consequence, a Kubewarden policy can be seen as a <a href="https://en.wikipedia.org/wiki/Plug-in_%28computing%29">traditional plug-in</a>
of the &quot;policy server&quot; program.</p>
<p>To recap:</p>
<ul>
<li>Kubewarden policies are plug-ins that expose a set of well-defined
functionalities (validate a Kubernetes request object, validate policy settings
provided by the user,...) using a well-defined API</li>
<li>Policy server is the &quot;main&quot; program that loads the plug-ins
(aka policies) and leverages their exposed functionalities to validate or mutate
Kubernetes requests</li>
</ul>
<p>Writing Kubewarden policies consists of writing the validation business logic
and then exposing it through a well-defined API.</p>
<h1><a class="header" href="#programming-language-requirements" id="programming-language-requirements">Programming language requirements</a></h1>
<p>Kubewarden policies are delivered as <a href="https://webassembly.org/">WebAssembly</a>
binaries.</p>
<p>Policy authors can write policies using any programming language that supports
WebAssembly as a compilation target. The list of supported language is constantly
evolving, <a href="https://github.com/appcypher/awesome-wasm-langs">this page</a>
provides a nice overview of the WebAssembly landscape.</p>
<p>Currently WebAssembly doesn't have an official way to share complex data types
between the host and a WebAssembly guest. To overcome this limitation
Kubewarden policies leverage the <a href="https://github.com/wapc">waPC</a> project, which
provides a bi-directional communication channel.</p>
<p>Because of that your programming language of choice must provide a waPC guest SDK.
If that's not the case, feel free to reach out. We can help you overcome this
limitation.</p>
<h1><a class="header" href="#policy-api" id="policy-api">Policy API</a></h1>
<p>The policy evaluator interacts with Kubewarden policies using a well defined API.
The purpose of this page is to document the API each policy must expose.</p>
<blockquote>
<p><strong>Note well:</strong> this section of the documentation is a bit low level, you can
jump straight to one of the &quot;language focused&quot; chapters and come back to this
page later.</p>
</blockquote>
<h2><a class="header" href="#the-validate-entry-point" id="the-validate-entry-point">The <code>validate</code> entry point</a></h2>
<p>The Kubewarden policy server receives
<a href="https://godoc.org/k8s.io/api/admission/v1#AdmissionReview"><code>AdmissionReview</code></a>
objects from the Kubernetes API server. It then forwards the value of
the <code>request</code> (of type
<a href="https://godoc.org/k8s.io/api/admission/v1#AdmissionRequest"><code>AdmissionRequest</code></a>
key to the policy to be evaluated.</p>
<p>The policy has to evaluate the <code>request</code> and state whether it should be
accepted or not. When the request is rejected, the policy must provide the
explanation message that is going to be shown to the end user.</p>
<p>By convention of the <code>policy-server</code> project, the guest has to expose
a function named <code>validate</code>, exposed through the waPC guest SDK, so
that the <code>policy-server</code> (waPC host) can invoke it.</p>
<p>The <code>validate</code> function receives a <code>ValidationRequest</code> object serialized as JSON and
returns a <code>ValidationResponse</code> object serialized as JSON.</p>
<h3><a class="header" href="#the-validationrequest-object" id="the-validationrequest-object">The <code>ValidationRequest</code> object</a></h3>
<p>The <code>ValidationRequest</code> is a simple JSON object that is received by the
<code>validate</code> function. It looks like this:</p>
<pre><code class="language-json">{
  &quot;request&quot;: &lt;AdmissionReview.request data&gt;,
  &quot;settings&quot;: {
     // your policy configuration
  }
}
</code></pre>
<p>The <code>settings</code> key points to a free-form JSON document that can hold the policy
specific settings.</p>
<h3><a class="header" href="#the-validationresponse-object" id="the-validationresponse-object">The <code>ValidationResponse</code> object</a></h3>
<p>The <code>validate</code> function returns the outcome of its validation using a <code>ValidationResponse</code>
object.</p>
<p>The <code>ValidationResponse</code> is structured in the following way:</p>
<pre><code class="language-json">{
  &quot;accepted&quot;: &lt;boolean&gt;,   // mandatory
  &quot;message&quot;: &lt;string&gt;,     // optional, ignored if accepted - recommended for rejections
  &quot;code&quot;: &lt;integer&gt;,        // optional, ignored if accepted
  &quot;mutated_object&quot;: &lt;dict&gt; // optional, used by mutation policies
}
</code></pre>
<p>The <code>message</code> and <code>code</code> attributes can be specified when the request
is not accepted. <code>message</code> is a free form textual error. <code>code</code>
represents an HTTP error code.</p>
<p>If the request is accepted, <code>message</code> and <code>code</code>
values will be ignored by the Kubernetes API server if they are
present.</p>
<p>If <code>message</code> and/or <code>code</code> are provided, and the request is not
accepted, the Kubernetes API server will forward this information as
part of the body of the error returned to the Kubernetes API server
client that issued the rejected request.</p>
<p>The <code>mutated_object</code> is an optional field used only by mutating policies.
This field contains the object the policy wants to be created inside of the
Kubernetes cluster.
For example, given a policy that mutates Pod objects, the <code>mutated_object</code> would
contain the full spec of a Pod.</p>
<h2><a class="header" href="#the-validate_settings-entry-point" id="the-validate_settings-entry-point">The <code>validate_settings</code> entry point</a></h2>
<p>Policy behaviour can be tuned using runtime configurations. As described above, the configuration
parameters are sent inside of each <code>validate</code> invocation via the <code>settings</code> dictionary.</p>
<p>Some policies might want to validate the settings a user provides to ensure they are correct.
This is done with the <code>validate_settings</code> function.</p>
<p>The <code>validate_settings</code> function receives as input a JSON representation of the settings
provided by the user. The function validates them and returns as a response a <code>SettingsValidationResponse</code>
object.</p>
<p>The structure of the object is the following one:</p>
<pre><code class="language-json">{
  &quot;valid&quot;: &lt;boolean&gt;,  // mandatory
  &quot;message&quot;: &lt;string&gt;, // optional, ignored if accepted - recommended for rejections
}
</code></pre>
<p>If the user provided settings are <code>valid</code>, the contents of <code>message</code> are ignored. Otherwise
the contents of <code>message</code> are shown to the user.</p>
<p>Kubewarden's policy server validates all the policy settings provided by users at start time.
It will exit immediately with an error if one or more of its policies received wrong configuration parameters.</p>
<h1><a class="header" href="#rust" id="rust">Rust</a></h1>
<p><a href="https://www.rust-lang.org/">Rust</a> is the most mature programming language that
can generate WebAssembly modules: WebAssembly is a first-class citizen
in the Rust world. That means many of the tools and crates of the Rust
ecosystem work out of the box.</p>
<p>Kubewarden provides a <a href="https://crates.io/crates/kubewarden-policy-sdk">Rust SDK</a>
that simplifies the process of writing policies, plus a
<a href="https://github.com/kubewarden/policy-rust-template">template project</a> to
quickly scaffold a policy project using the
<a href="https://github.com/cargo-generate/cargo-generate"><code>cargo-generate</code></a> utility.</p>
<p>This document illustrates how to take advantage of these projects to write
Kubewarden policies using the Rust programming language.</p>
<p>Note well, we won't cover the details of Kubewarden's Rust SDK inside of this
page. These can be found inside of the
<a href="https://docs.rs/kubewarden-policy-sdk/0.1.0">official crate documentation</a>.</p>
<h2><a class="header" href="#getting-rust-dependencies" id="getting-rust-dependencies">Getting Rust dependencies</a></h2>
<p>This section guides you through the process of installing the Rust compiler and
its dependencies.</p>
<p>As a first step install the Rust compiler and its tools, this can be easily done
using <a href="https://github.com/rust-lang/rustup">rustup</a>. Please follow
<a href="https://rust-lang.github.io/rustup/installation/index.html">rustup's install documentation</a>.</p>
<p>Once <code>rustup</code> is installed add the Wasm target:</p>
<pre><code class="language-shell">rustup target add wasm32-unknown-unknown
</code></pre>
<p>Finally, install the <a href="https://github.com/cargo-generate/cargo-generate">cargo-generate</a> utility:</p>
<pre><code class="language-shell">cargo install cargo-generate
</code></pre>
<h2><a class="header" href="#creating-a-new-validation-policy" id="creating-a-new-validation-policy">Creating a new validation policy</a></h2>
<p>We are going to create a simple validation policy that processes
Pod creation requests.</p>
<p>The policy will look at the <code>metadata.name</code> attribute of the Pod and reject
the pods that have an invalid name. We want the list of invalid names to be
configurable by the end users of the policy.</p>
<p>To summarize, the policy settings will look like that:</p>
<pre><code class="language-yaml">invalid_names:
- bad_name1
- bad_name2
</code></pre>
<p>The policy will accept the creation of a Pod like the following one:</p>
<pre><code class="language-yaml">apiVersion: v1
kind: Pod
metadata:
  name: nginx
spec:
  containers:
    - name: nginx
      image: nginx:latest
</code></pre>
<p>While it will reject the creation of a Pod like the following one:</p>
<pre><code class="language-yaml">apiVersion: v1
kind: Pod
metadata:
  name: bad_name1
spec:
  containers:
    - name: nginx
      image: nginx:latest
</code></pre>
<h3><a class="header" href="#scaffolding-new-policy-project" id="scaffolding-new-policy-project">Scaffolding new policy project</a></h3>
<p>The creation of a new policy project can be done by feeding this
<a href="https://github.com/kubewarden/policy-rust-template">template project</a>
into <code>cargo generate</code>:</p>
<pre><code class="language-shell">cargo generate --git https://github.com/kubewarden/policy-rust-template \
               --branch main \
               --name demo
</code></pre>
<p>The command will produce the following output:</p>
<pre><code>ðŸ”§   Creating project called `demo`...
âœ¨   Done! New project created /home/flavio/hacking/kubernetes/kubewarden/demo
</code></pre>
<p>The new policy project can now be found inside of the <code>demo</code> directory.</p>
<h3><a class="header" href="#defining-policy-settings" id="defining-policy-settings">Defining policy settings</a></h3>
<p>As a first step we will define the structure that holds the policy settings.</p>
<p>Open the <code>src/settings.rs</code> file and change the definition of the <code>Settings</code>
struct to look like that:</p>
<pre><code class="language-rust norun noplayground">use std::collections::HashSet;

#[derive(Deserialize, Default, Debug, Serialize)]
pub(crate) struct Settings {
    pub invalid_names: HashSet&lt;String&gt;,
}
</code></pre>
<p>This will automatically put the list of invalid names inside of
a Set collection.</p>
<p>Next we will write a settings validation function: we want to ensure
the policy is always run with at least one invalid name.</p>
<p>This can be done by changing the implementation of the <code>Validatable</code> trait.</p>
<p>Change the scaffolded implementation defined inside of <code>src/settings.rs</code>
to look like that:</p>
<pre><code class="language-rust norun noplayground">impl kubewarden::settings::Validatable for Settings {
    fn validate(&amp;self) -&gt; Result&lt;(), String&gt; {
        if self.invalid_names.is_empty() {
            Err(String::from(&quot;No invalid name specified. Specify at least one invalid name to match&quot;))
        } else {
            Ok(())
        }
    }
}
</code></pre>
<p>Now we can write a unit test to ensure the settings validation is actually working.
This can be done in the <a href="https://doc.rust-lang.org/stable/book/ch11-00-testing.html">usual Rust way</a>.</p>
<p>There are already some default tests at the bottom of the <code>src/settings.rs</code>
file. Replace the automatically generated code to look like that:</p>
<pre><code class="language-rust norun noplayground">#[cfg(test)]
mod tests {
    use super::*;

    use kubewarden_policy_sdk::settings::Validatable;

    #[test]
    fn accept_settings_with_a_list_of_invalid_names() -&gt; Result&lt;(), ()&gt; {
        let mut invalid_names = HashSet::new();
        invalid_names.insert(String::from(&quot;bad_name1&quot;));
        invalid_names.insert(String::from(&quot;bad_name2&quot;));

        let settings = Settings { invalid_names };

        assert!(settings.validate().is_ok());
        Ok(())
    }

    #[test]
    fn reject_settings_without_a_list_of_invalid_names() -&gt; Result&lt;(), ()&gt; {
        let invalid_names = HashSet::&lt;String&gt;::new();
        let settings = Settings { invalid_names };

        assert!(settings.validate().is_err());
        Ok(())
    }
}
</code></pre>
<p>We can now run the unit tests by doing:</p>
<pre><code class="language-shell">cargo test
</code></pre>
<p>This will produce an output similar to the following one:</p>
<pre><code class="language-shell">  Compiling demo v0.1.0 (/home/flavio/hacking/kubernetes/kubewarden/demo)
    Finished test [unoptimized + debuginfo] target(s) in 4.19s
     Running target/debug/deps/demo-24670dd6a538fd72

running 2 tests
test settings::tests::accept_settings_with_a_list_of_invalid_names ... ok
test settings::tests::reject_settings_without_a_list_of_invalid_names ... ok

test result: ok. 2 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s
</code></pre>
<h3><a class="header" href="#writing-the-validation-business-logic" id="writing-the-validation-business-logic">Writing the validation business logic</a></h3>
<p>It's time to write the actual validation code. This is defined inside of the
<code>src/lib.rs</code> file. Inside of this file you will find a function called <code>validate</code>.</p>
<p>The scaffolded function is already doing something:</p>
<pre><code class="language-rust norun noplayground">fn validate(payload: &amp;[u8]) -&gt; CallResult {
    // NOTE 1
    let validation_request: ValidationRequest&lt;Settings&gt; = ValidationRequest::new(payload)?;

    // NOTE 2
    match serde_json::from_value::&lt;apicore::Pod&gt;(validation_request.request.object) {
        Ok(pod) =&gt; {
            // NOTE 3
            if pod.metadata.name == Some(&quot;invalid-pod-name&quot;.to_string()) {
                kubewarden::reject_request(
                    Some(format!(&quot;pod name {:?} is not accepted&quot;, pod.metadata.name)),
                    None,
                )
            } else {
                kubewarden::accept_request()
            }
        }
        Err(_) =&gt; {
            // NOTE 4
            // We were forwarded a request we cannot unmarshal or
            // understand, just accept it
            kubewarden::accept_request()
        }
    }
}
</code></pre>
<p>This is a walk-through the code described above:</p>
<ol>
<li>Parse the incoming <code>payload</code> into a <code>ValidationRequest&lt;Setting&gt;</code> object. This
automatically populates the <code>Settings</code> instance inside of <code>ValidationRequest</code> with
the params provided by the user.</li>
<li>Convert the Kubernetes raw JSON object embedded into the request
into an instance of the <a href="https://arnavion.github.io/k8s-openapi/v0.11.x/k8s_openapi/api/core/v1/struct.Pod.html">Pod struct</a></li>
<li>The request contains a Pod object, the code approves only the requests
that do not have <code>metadata.name</code> equal to the hard-coded value <code>invalid-pod-name</code></li>
<li>The request doesn't contain a Pod object, hence the policy accepts the request</li>
</ol>
<p>As you can see the code is already doing a validation that resembles the one we
want to implement. We just have to get rid of the hard-coded value and use the
values provided by the user via the policy settings.</p>
<p>This can be done with the following code:</p>
<pre><code class="language-rust norun noplayground">fn validate(payload: &amp;[u8]) -&gt; CallResult {
    let validation_request: ValidationRequest&lt;Settings&gt; = ValidationRequest::new(payload)?;

    match serde_json::from_value::&lt;apicore::Pod&gt;(validation_request.request.object) {
        Ok(pod) =&gt; {
            let pod_name = pod.metadata.name.unwrap_or_default();
            if validation_request
                .settings
                .invalid_names
                .contains(&amp;pod_name)
            {
                kubewarden::reject_request(
                    Some(format!(&quot;pod name {:?} is not accepted&quot;, pod_name)),
                    None,
                )
            } else {
                kubewarden::accept_request()
            }
        }
        Err(_) =&gt; {
            // We were forwarded a request we cannot unmarshal or
            // understand, just accept it
            kubewarden::accept_request()
        }
    }
}
</code></pre>
<p>Finally, we will create some unit tests to ensure the validation code works as
expected.</p>
<p>The <code>lib.rs</code> file has already some tests defined at the bottom of the file, as
you can see Kubewarden's Rust SDK provides some test helpers too.</p>
<p>Moreover, the scaffolded project already ships with some default
<a href="https://en.wikipedia.org/wiki/Test_fixture#Software">test fixtures</a> inside of
the <code>test_data</code> directory. We are going to take advantage of these recorded
admission requests to write our unit tests.</p>
<p>Change the contents of the test section inside of <code>src/lib.rs</code> to look like that:</p>
<pre><code class="language-rust norun noplayground">#[cfg(test)]
mod tests {
    use super::*;

    use kubewarden_policy_sdk::test::Testcase;
    use std::collections::HashSet;

    #[test]
    fn accept_pod_with_valid_name() -&gt; Result&lt;(), ()&gt; {
        let mut invalid_names = HashSet::new();
        invalid_names.insert(String::from(&quot;bad_name1&quot;));
        let settings = Settings { invalid_names };

        let request_file = &quot;test_data/pod_creation.json&quot;;
        let tc = Testcase {
            name: String::from(&quot;Pod creation with valid name&quot;),
            fixture_file: String::from(request_file),
            expected_validation_result: true,
            settings,
        };

        let res = tc.eval(validate).unwrap();
        assert!(
            res.mutated_object.is_none(),
            &quot;Something mutated with test case: {}&quot;,
            tc.name,
        );

        Ok(())
    }

    #[test]
    fn reject_pod_with_invalid_name() -&gt; Result&lt;(), ()&gt; {
        let mut invalid_names = HashSet::new();
        invalid_names.insert(String::from(&quot;nginx&quot;));
        let settings = Settings { invalid_names };

        let request_file = &quot;test_data/pod_creation.json&quot;;
        let tc = Testcase {
            name: String::from(&quot;Pod creation with invalid name&quot;),
            fixture_file: String::from(request_file),
            expected_validation_result: false,
            settings,
        };

        let res = tc.eval(validate).unwrap();
        assert!(
            res.mutated_object.is_none(),
            &quot;Something mutated with test case: {}&quot;,
            tc.name,
        );

        Ok(())
    }

    #[test]
    fn accept_request_with_non_pod_resource() -&gt; Result&lt;(), ()&gt; {
        let mut invalid_names = HashSet::new();
        invalid_names.insert(String::from(&quot;prod&quot;));
        let settings = Settings { invalid_names };

        let request_file = &quot;test_data/ingress_creation.json&quot;;
        let tc = Testcase {
            name: String::from(&quot;Ingress creation&quot;),
            fixture_file: String::from(request_file),
            expected_validation_result: true,
            settings,
        };

        let res = tc.eval(validate).unwrap();
        assert!(
            res.mutated_object.is_none(),
            &quot;Something mutated with test case: {}&quot;,
            tc.name,
        );

        Ok(())
    }
}
</code></pre>
<p>We now have three unit tests defined inside of this file:</p>
<ul>
<li><code>accept_pod_with_valid_name</code>: ensures a Pod with a valid
name is accepted</li>
<li><code>reject_pod_with_invalid_name</code>: ensures a Pod with an invalid
name is rejected</li>
<li><code>accept_request_with_non_pod_resource</code>: ensure the policy accepts
request that do not have a <code>Pod</code> as object</li>
</ul>
<p>We can run the unit tests again:</p>
<pre><code class="language-shell">$ cargo test
   Compiling demo v0.1.0 (/home/flavio/hacking/kubernetes/kubewarden/demo)
    Finished test [unoptimized + debuginfo] target(s) in 3.45s
     Running target/debug/deps/demo-24670dd6a538fd72

running 5 tests
test settings::tests::accept_settings_with_a_list_of_invalid_names ... ok
test settings::tests::reject_settings_without_a_list_of_invalid_names ... ok
test tests::accept_request_with_non_pod_resource ... ok
test tests::accept_pod_with_valid_name ... ok
test tests::reject_pod_with_invalid_name ... ok

test result: ok. 5 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s
</code></pre>
<p>That's all if you want to write a simple validating policy.</p>
<h2><a class="header" href="#creating-a-new-mutation-policy" id="creating-a-new-mutation-policy">Creating a new mutation policy</a></h2>
<p>Mutating policies are similar to validating ones, but have also the ability to mutate an
incoming object.</p>
<p>They can:</p>
<ul>
<li>Reject a request</li>
<li>Accept a request without doing any change to the incoming object</li>
<li>Mutate the incoming object as they like and accept the request</li>
</ul>
<p>Writing a Kubewarden mutation policies is extremely simple. We will use the validating
policy created inside of the previous steps and, with very few changes, turn it into a
mutating one.</p>
<p>Our policy will use the same validation logic defined before, but it will also add
an annotation to all the Pods that have a valid name.</p>
<p>Attempting to create a Pod like that:</p>
<pre><code class="language-yaml">apiVersion: v1
kind: Pod
metadata:
  name: nginx
spec:
  containers:
    - name: nginx
      image: nginx:latest
</code></pre>
<p>Will lead to the creation of this Pod:</p>
<pre><code class="language-yaml">apiVersion: v1
kind: Pod
metadata:
  name: nginx
  annotations:
    kubewarden.policy.demo/inspected: true
spec:
  containers:
    - name: nginx
      image: nginx:latest
</code></pre>
<h3><a class="header" href="#write-the-mutation-code" id="write-the-mutation-code">Write the mutation code</a></h3>
<p>The mutation code is done inside of the <code>validate</code> function. The function should be changed
to approve the request via the <a href="https://docs.rs/kubewarden-policy-sdk/0.1.0/kubewarden_policy_sdk/fn.mutate_request.html"><code>mutate_request</code></a>
instead of the <a href="https://docs.rs/kubewarden-policy-sdk/0.1.0/kubewarden_policy_sdk/fn.accept_request.html"><code>accept_request</code></a>.</p>
<p>This is how the <code>validate</code> function has to look like:</p>
<pre><code class="language-rust norun noplayground">fn validate(payload: &amp;[u8]) -&gt; CallResult {
    let validation_request: ValidationRequest&lt;Settings&gt; = ValidationRequest::new(payload)?;

    match serde_json::from_value::&lt;apicore::Pod&gt;(validation_request.request.object) {
        // NOTE 1
        Ok(mut pod) =&gt; {
            let pod_name = pod.metadata.name.clone().unwrap_or_default();
            if validation_request
                .settings
                .invalid_names
                .contains(&amp;pod_name)
            {
                kubewarden::reject_request(
                    Some(format!(&quot;pod name {:?} is not accepted&quot;, pod_name)),
                    None,
                )
            } else {
                // NOTE 2
                let mut new_annotations = pod.metadata.annotations.clone().unwrap_or_default();
                new_annotations.insert(
                    String::from(&quot;kubewarden.policy.demo/inspected&quot;),
                    String::from(&quot;true&quot;),
                );
                pod.metadata.annotations = Some(new_annotations);

                // NOTE 3
                let mutated_object = serde_json::to_value(pod)?;
                kubewarden::mutate_request(&amp;mutated_object)
            }
        }
        Err(_) =&gt; {
            // We were forwarded a request we cannot unmarshal or
            // understand, just accept it
            kubewarden::accept_request()
        }
    }
}
</code></pre>
<p>Compared to the previous code, we made only three changes:</p>
<ol>
<li>We defined the <code>pod</code> object as mutable, see the <code>mut</code> keyword. This is
needed because we will extend its <code>metadata.annotations</code> attribute</li>
<li>This is the actual code that takes the existing <code>annotations</code>, adds the
new one, and finally puts the updated <code>annotations</code> object back into the original
<code>pod</code> instance</li>
<li>Serialize the <code>pod</code> object into a generic <code>serde_json::Value</code> and then return
a mutation response</li>
</ol>
<p>Having done these changes, it's time to run the unit tests again:</p>
<pre><code class="language-shell">$ cargo test
   Compiling demo v0.1.0 (/home/flavio/hacking/kubernetes/kubewarden/demo)
    Finished test [unoptimized + debuginfo] target(s) in 4.53s
     Running target/debug/deps/demo-24670dd6a538fd72

running 5 tests
test settings::tests::reject_settings_without_a_list_of_invalid_names ... ok
test settings::tests::accept_settings_with_a_list_of_invalid_names ... ok
test tests::reject_pod_with_invalid_name ... ok
test tests::accept_pod_with_valid_name ... FAILED
test tests::accept_request_with_non_pod_resource ... ok

failures:

---- tests::accept_pod_with_valid_name stdout ----
thread 'tests::accept_pod_with_valid_name' panicked at 'Something mutated with test case: Pod creation with valid name', src/lib.rs:74:9
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace


failures:
    tests::accept_pod_with_valid_name

test result: FAILED. 4 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s
</code></pre>
<p>As you can see, the <code>accept_pod_with_valid_name</code> fails because the response actually
contains a mutated object. It looks like our code is actually working!</p>
<p>Let's update the <code>accept_pod_with_valid_name</code> to look like that:</p>
<pre><code class="language-rust norun noplayground">#[test]
fn accept_pod_with_valid_name() -&gt; Result&lt;(), ()&gt; {
    let mut invalid_names = HashSet::new();
    invalid_names.insert(String::from(&quot;bad_name1&quot;));
    let settings = Settings { invalid_names };

    let request_file = &quot;test_data/pod_creation.json&quot;;
    let tc = Testcase {
        name: String::from(&quot;Pod creation with valid name&quot;),
        fixture_file: String::from(request_file),
        expected_validation_result: true,
        settings,
    };

    let res = tc.eval(validate).unwrap();
    // NOTE 1
    assert!(
        res.mutated_object.is_some(),
        &quot;Expected accepted object to be mutated&quot;,
    );

    // NOTE 2
    let final_pod =
        serde_json::from_str::&lt;apicore::Pod&gt;(res.mutated_object.unwrap().as_str()).unwrap();
    let final_annotations = final_pod.metadata.annotations.unwrap();
    assert_eq!(
        final_annotations.get_key_value(&quot;kubewarden.policy.demo/inspected&quot;),
        Some((
            &amp;String::from(&quot;kubewarden.policy.demo/inspected&quot;),
            &amp;String::from(&quot;true&quot;)
        )),
    );

    Ok(())
}
</code></pre>
<p>Compared to the initial test, we made only two changes:</p>
<ol>
<li>Change the <code>assert!</code> statement to ensure the request is still accepted,
but it also includes a mutated object</li>
<li>Created a <code>Pod</code> instance starting from the mutated object that is part of
the response. Assert the mutated Pod object contains the right
<code>metadata.annotations</code>.</li>
</ol>
<p>We can run the tests again, this time all of them will pass:</p>
<pre><code class="language-shell">$ cargo test
   Compiling demo v0.1.0 (/home/flavio/hacking/kubernetes/kubewarden/demo)
    Finished test [unoptimized + debuginfo] target(s) in 2.61s
     Running target/debug/deps/demo-24670dd6a538fd72

running 5 tests
test settings::tests::reject_settings_without_a_list_of_invalid_names ... ok
test settings::tests::accept_settings_with_a_list_of_invalid_names ... ok
test tests::accept_request_with_non_pod_resource ... ok
test tests::reject_pod_with_invalid_name ... ok
test tests::accept_pod_with_valid_name ... ok

test result: ok. 5 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s
</code></pre>
<p>As you can see the creation of a mutation policy is pretty straightforward.</p>
<h2><a class="header" href="#building-the-policy" id="building-the-policy">Building the policy</a></h2>
<p>So far we have built the policy using as a compilation target the same operating
system and architecture of our development machine.</p>
<p>It's now time to build the policy as a WebAssembly binary, also known as <code>.wasm</code>
file.</p>
<p>This can be done with a simple command:</p>
<pre><code class="language-shell">make build
</code></pre>
<p>This command will build the code in release mode, with WebAssembly as
compilation target.</p>
<p>The build will produce the following file:</p>
<pre><code class="language-shell">$ file target/wasm32-unknown-unknown/release/demo.wasm
target/wasm32-unknown-unknown/release/demo.wasm: WebAssembly (wasm) binary module version 0x1 (MVP)
</code></pre>
<h2><a class="header" href="#distributing-the-policy" id="distributing-the-policy">Distributing the policy</a></h2>
<p>This topic is covered inside of the <a href="writing-policies//distributing-policies.html">&quot;distributing policies&quot;</a>
section of Kubewarden's documentation.</p>
<h2><a class="header" href="#more-examples" id="more-examples">More examples</a></h2>
<p>You can find more Kubewarden policies written in Rust inside of Kubewarden's
GitHub space. <a href="https://github.com/search?l=Rust&amp;q=topic%3Apolicy-as-code+org%3Akubewarden&amp;type=Repositories">This query</a>
can help you find them.</p>
<p><strong>Worth of note:</strong> these repositories have a series of GitHub Actions that automate
the following tasks:</p>
<ul>
<li>Run unit tests and code linting on pull requests and after code is merged
into the main branch</li>
<li>Build the policy in <code>release</code> mode and push it to a OCI registry as an
artifact</li>
</ul>
<blockquote>
<p><strong>Note well:</strong> Go's support for WebAssembly is fast evolving. The contents
of this page have been written during April 2021, hence they could be outdated.</p>
</blockquote>
<h1><a class="header" href="#go" id="go">Go</a></h1>
<p>Currently the official Go compiler cannot produce WebAssembly binaries
that can be run <strong>outside</strong> of the browser.
<a href="https://github.com/golang/go/issues/31105">This upstream issue</a> is tracking
the evolution of this topic.
Due to that, it's not possible to use the Go compiler to write Kubewarden policies.</p>
<p>Luckily there's another Go compiler that is capable of building WebAssembly
binaries that can be used by Kubewarden. This compiler is called <a href="https://tinygo.org/">TinyGo</a>:</p>
<blockquote>
<p>TinyGo is a project to bring the Go programming language to microcontrollers
and modern web browsers by creating a new compiler based on LLVM.</p>
<p>You can compile and run TinyGo programs on many different microcontroller
boards such as the BBC micro:bit and the Arduino Uno.</p>
<p>TinyGo can also be used to produce WebAssembly (Wasm) code which is very
compact in size.</p>
</blockquote>
<h2><a class="header" href="#limitations" id="limitations">Limitations</a></h2>
<p>TinyGo doesn't yet support all the Go features (see <a href="https://tinygo.org/lang-support/">here</a>
to see the current project status). Currently its biggest limitation
is the lack of a fully supported <code>reflect</code> package. That leads to the inability to use
the <code>encoding/json</code> package against structures and user defined types.</p>
<p>Kubewarden policies need to process JSON data like the policy settings and
the actual request received by Kubernetes.</p>
<p>Despite TinyGo's current limitations, it's still easy and doable to write Kubewarden policies
with it.</p>
<h2><a class="header" href="#tooling" id="tooling">Tooling</a></h2>
<p>Writing Kubewarden policies requires a version of TinyGo greater than <code>0.17.0</code>.</p>
<p>These Go libraries are extremely useful when writing a Kubewarden policy:</p>
<ul>
<li><a href="https://github.com/kubewarden/policy-sdk-go">Kubewarden Go SDK</a>: provides a series of
structures and functions that reduce the amount of code to write. It also provides test helpers.</li>
<li><a href="https://github.com/tidwall/gjson">gjson</a>: provides a powerful query language that allows
quick navigation of JSON documents and data retrieval. This library doesn't use the
<code>encoding/json</code> package provided by Go's stdlib, hence it's usable with TinyGo.</li>
<li><a href="https://github.com/tidwall/sjson">sjson</a>: can be used to mutate JSON documents.
This library doesn't use the <code>encoding/json</code> package provided by Go's stdlib, hence it's usable with TinyGo.</li>
<li><a href="https://github.com/deckarep/golang-set">mapset</a>: provides a Go implementation of the
<a href="https://en.wikipedia.org/wiki/Set_(abstract_data_type)">Set</a>
data structure. This library significantly reduces the amount of code to be written,
that's because operations like Set <code>union</code>, <code>intersection</code>, <code>difference</code> are pretty frequent inside
of policies.</li>
</ul>
<p>Last but not least, the Kubewarden project provides a
<a href="https://github.com/kubewarden/go-policy-template">template Go policy project</a>
that can be used to quickly create Kubewarden policies written in Go.</p>
<h2><a class="header" href="#getting-tinygo-dependencies" id="getting-tinygo-dependencies">Getting TinyGo dependencies</a></h2>
<p>The easiest way to get TinyGo is by using the upstream container images.
Official releases can be found <a href="https://hub.docker.com/r/tinygo/tinygo">here</a>, while
builds from the development branch are automatically pushed
<a href="https://hub.docker.com/r/tinygo/tinygo-dev">here</a>.</p>
<p>If needed, checkout TinyGo's <a href="https://tinygo.org/getting-started/">getting started</a> page for
more information.</p>
<blockquote>
<p><strong>Note well:</strong> Kubewarden's requires code that is available only on the development branch. This will
be solved once TinyGo <code>0.17.0</code> is released. In the meantime we will use the container image
based on the development branch: <code>tinygo/tinygo-dev:latest</code>.</p>
</blockquote>
<h1><a class="header" href="#creating-a-new-validation-policy-1" id="creating-a-new-validation-policy-1">Creating a new validation policy</a></h1>
<p>We are going to create a validation policy that validates the labels of generic Kubernetes
objects.</p>
<p>The policy will reject all the resources that use one or more labels on the deny list.
The policy will also validate certain labels using a regular expression 
provided by the user.</p>
<p>To summarize, the policy settings will look like that:</p>
<pre><code class="language-yaml"># List of labels that cannot be used
denied_labels:
- foo
- bar

# Labels that are validated with user-defined regular expressions
constrained_labels:
  priority: &quot;[123]&quot;
  cost-center: &quot;^cc-\d+&quot;
</code></pre>
<p>The policy would reject the creation of this Pod:</p>
<pre><code class="language-yaml">apiVersion: v1
kind: Pod
metadata:
  name: nginx
  labels:
    foo: hello world
spec:
  containers:
    - name: nginx
      image: nginx:latest
</code></pre>
<p>The policy would also reject the creation of this Pod:</p>
<pre><code class="language-yaml">apiVersion: v1
kind: Pod
metadata:
  name: nginx
  labels:
    cost-center: cc-marketing
spec:
  containers:
    - name: nginx
      image: nginx:latest
</code></pre>
<p>Policy's settings can also be used to force certain labels to be specified,
regardless of their contents:</p>
<pre><code class="language-yaml"># Policy's settings

constrained_labels:
  mandatory-label: &quot;.*&quot; # &lt;- this label must be present, we don't care about its value
</code></pre>
<h2><a class="header" href="#scaffolding-new-policy-project-1" id="scaffolding-new-policy-project-1">Scaffolding new policy project</a></h2>
<p>The creation of a new policy project can be done by using this GitHub
template repository: <a href="https://github.com/kubewarden/go-policy-template">kubewarden/go-policy-template</a>.
Just press the &quot;Use  this template&quot; green button near the top of the page
and follow GitHub's wizard.</p>
<p>Clone the repository locally and then ensure the <code>module</code> directive inside
of the <code>go.mod</code> file looks like that:</p>
<pre><code class="language-go">module &lt;path to your repository&gt;
</code></pre>
<h1><a class="header" href="#defining-policy-settings-1" id="defining-policy-settings-1">Defining policy settings</a></h1>
<p>As a first step we will define the structure that holds the policy settings.</p>
<p>We will do that by adding this code inside of the <code>settings.go</code> file:</p>
<pre><code class="language-go">import (
	&quot;github.com/deckarep/golang-set&quot;
	&quot;github.com/kubewarden/gjson&quot;
	kubewarden &quot;github.com/kubewarden/policy-sdk-go&quot;

	&quot;fmt&quot;
	&quot;regexp&quot;
)

type Settings struct {
	DeniedLabels      mapset.Set                    `json:&quot;denied_labels&quot;`
	ConstrainedLabels map[string]*RegularExpression `json:&quot;constrained_labels&quot;`
}
</code></pre>
<p>As you can see we're using the <code>regexp</code> package to handle regular expression objects, plus
we use the <code>mapset.Set</code> structure to store the list of denied labels.</p>
<p>The <code>Settings</code> struct has json attributes, we will use them later when writing
our unit tests. The unit tests are going to be executed using Go official compiler, hence
we will be able to leverage the <code>encoding/json</code> package.</p>
<p>The <code>Settings</code> class is not using the official <code>regexp.RegExp</code> object to
represent regular expressions. That's because the <code>regexp.RegExp</code> struct doesn't
handle serialization and deserialization to JSON.</p>
<p>This is the implementation of the <code>RegularExpression</code> struct:</p>
<pre><code class="language-go">// A wrapper around the standard regexp.Regexp struct
// that implements marshalling and unmarshalling
type RegularExpression struct {
	*regexp.Regexp
}

// Convenience method to build a regular expression
func CompileRegularExpression(expr string) (*RegularExpression, error) {
	nativeRegExp, err := regexp.Compile(expr)
	if err != nil {
		return nil, err
	}
	return &amp;RegularExpression{nativeRegExp}, nil
}

// UnmarshalText satisfies the encoding.TextMarshaler interface,
// also used by json.Unmarshal.
func (r *RegularExpression) UnmarshalText(text []byte) error {
	nativeRegExp, err := regexp.Compile(string(text))
	if err != nil {
		return err
	}
	r.Regexp = nativeRegExp
	return nil
}

// MarshalText satisfies the encoding.TextMarshaler interface,
// also used by json.Marshal.
func (r *RegularExpression) MarshalText() ([]byte, error) {
	if r.Regexp != nil {
		return []byte(r.Regexp.String()), nil
	}

	return nil, nil
}
</code></pre>
<h2><a class="header" href="#building-settings-instances" id="building-settings-instances">Building <code>Settings</code> instances</a></h2>
<p>At runtime we can't rely on the automatic struct marshalling and unmarshalling
provided by the <code>encoding/json</code> package due to TinyGo current limitations.
Because of that we will create two initialization helpers:</p>
<ul>
<li><code>NewSettingsFromValidationReq</code>: this is used when building a <code>Settings</code>
instance starting from a <a href="writing-policies/go//writing-policies/index.html#the-validationrequest-object"><code>ValidationRequest</code></a>
object</li>
<li><code>NewSettingsFromValidateSettingsPayload</code>: this is used when building a
<code>Settings</code> instance inside of the <a href="writing-policies/go//writing-policies/index.html#the-validate_settings-entry-point"><code>validate_settings</code></a> entry point. This entry point receives the &quot;naked&quot; Settings JSON
dictionary</li>
</ul>
<p>This is the implementation of these functions:</p>
<pre><code class="language-go">// Builds a new Settings instance starting from a validation
// request payload:
// {
//    &quot;request&quot;: ...,
//    &quot;settings&quot;: {
//       &quot;denied_labels&quot;: [...],
//       &quot;constrained_labels&quot;: { ... }
//    }
// }
func NewSettingsFromValidationReq(payload []byte) (Settings, error) {
	// Note well: we don't validate the input JSON now, this has
	// already done inside of the `validate` function

	return newSettings(
		payload,
		&quot;settings.denied_labels&quot;,
		&quot;settings.constrained_labels&quot;)
}

// Builds a new Settings instance starting from a Settings
// payload:
// {
//    &quot;denied_names&quot;: [ ... ],
//    &quot;constrained_labels&quot;: { ... }
// }
func NewSettingsFromValidateSettingsPayload(payload []byte) (Settings, error) {
	if !gjson.ValidBytes(payload) {
		return Settings{}, fmt.Errorf(&quot;denied JSON payload&quot;)
	}

	return newSettings(
		payload,
		&quot;denied_labels&quot;,
		&quot;constrained_labels&quot;)
}
</code></pre>
<p>The heavy lifting of the setting is done inside of the <code>newSettings</code> function, which
is invoked by both <code>NewSettingsFromValidateSettingsPayload</code> and <code>NewSettingsFromValidationReq</code>.</p>
<p>The function takes the raw JSON payload and a list of <a href="https://github.com/tidwall/gjson">gjson</a>
queries. These queries are used to extract the values from the JSON data and
build the actual object:</p>
<pre><code class="language-go">func newSettings(payload []byte, paths ...string) (Settings, error) {
	if len(paths) != 2 {
		return Settings{}, fmt.Errorf(&quot;wrong number of json paths&quot;)
	}

	data := gjson.GetManyBytes(payload, paths...)

	deniedLabels := mapset.NewThreadUnsafeSet()
	data[0].ForEach(func(_, entry gjson.Result) bool {
		deniedLabels.Add(entry.String())
		return true
	})

	constrainedLabels := make(map[string]*RegularExpression)
	var err error
	data[1].ForEach(func(key, value gjson.Result) bool {
		var regExp *RegularExpression
		regExp, err = CompileRegularExpression(value.String())
		if err != nil {
			return false
		}

		constrainedLabels[key.String()] = regExp
		return true
	})
	if err != nil {
		return Settings{}, err
	}

	return Settings{
		DeniedLabels:      deniedLabels,
		ConstrainedLabels: constrainedLabels,
	}, nil
}
</code></pre>
<p>As you can see the code above is pretty straightforward. The <code>gjson</code> package
provides a convenient method to fetch multiple values from the JSON data.</p>
<p>The <code>newSettings</code> function also creates instances of <code>regexp.Regexp</code> objects
and ensures the regular expressions provided by the user are correct.</p>
<blockquote>
<p><strong>Note well:</strong> all the <code>mapset.Set</code> objects are deliberately created using
their <a href="https://pkg.go.dev/github.com/deckarep/golang-set?utm_source=godoc#NewThreadUnsafeSet">thread-unsafe variant</a>.
The WebAssembly code is executed in single thread, hence there are no
concurrency issues.</p>
<p>Moreover, the WebAssembly standard doesn't cover
threads yet. See <a href="https://github.com/WebAssembly/threads">the official proposal</a>
for more details.</p>
</blockquote>
<h2><a class="header" href="#implementing-settings-validation" id="implementing-settings-validation">Implementing <code>Settings</code> validation</a></h2>
<p>All Kubewarden policies have to implement
<a href="writing-policies/go//writing-policies/index.html#the-validate_settings-entry-point">settings validation</a>.</p>
<p>This can be easily done by adding a <code>Valid</code> method to the <code>Settings</code> instances:</p>
<pre><code class="language-go">func (s *Settings) Valid() (bool, error) {
	constrainedLabels := mapset.NewThreadUnsafeSet()

	for label := range s.ConstrainedLabels {
		constrainedLabels.Add(label)
	}

	constrainedAndDenied := constrainedLabels.Intersect(s.DeniedLabels)
	if constrainedAndDenied.Cardinality() != 0 {
		return false,
			fmt.Errorf(&quot;These labels cannot be constrained and denied at the same time: %v&quot;, constrainedAndDenied)
	}

	return true, nil
}
</code></pre>
<p>The <code>Valid</code> method ensures no &quot;denied&quot; label is also part of the &quot;constrained&quot; map. The check
is simplified by the usage of the <code>Intersect</code> method provided by <code>mapset.Set</code>.</p>
<blockquote>
<p><strong>Note well:</strong> the <code>Valid</code> method is invoked against an already instantiated <code>Setting</code> object. That means
the validation of the regular expression provided by the user already took place at
inside of the <code>Settings</code> constructor.</p>
</blockquote>
<p>Finally, we have to ensure the <code>validateSettings</code> function that was automatically generated
is changed to look like that:</p>
<pre><code class="language-go">func validateSettings(payload []byte) ([]byte, error) {
	settings, err := NewSettingsFromValidateSettingsPayload(payload)
	if err != nil {
		// this happens when one of the user-defined regular expressions are invalid
		return kubewarden.RejectSettings(
			kubewarden.Message(fmt.Sprintf(&quot;Provided settings are not valid: %v&quot;, err)))
	}

	valid, err := settings.Valid()
	if valid {
		return kubewarden.AcceptSettings()
	}
	return kubewarden.RejectSettings(
		kubewarden.Message(fmt.Sprintf(&quot;Provided settings are not valid: %v&quot;, err)))
}
</code></pre>
<p>As you can see, the function takes advantage of the helper functions provided
by <a href="https://github.com/kubewarden/policy-sdk-go">Kubewarden's SDK</a>.</p>
<h2><a class="header" href="#testing-the-settings-code" id="testing-the-settings-code">Testing the settings code</a></h2>
<p>As always, it's important to have good test coverage of the code we write.
The code we generated comes with a series of unit test defined inside of
the <code>settings_test.go</code> file.</p>
<p>We will have to change the contents of this file to reflect the new behaviour of the
<code>Settings</code> class.</p>
<p>We will start by including the Go packages we will use:</p>
<pre><code class="language-go">import (
	&quot;encoding/json&quot;
	&quot;testing&quot;

	kubewarden_testing &quot;github.com/kubewarden/policy-sdk-go/testing&quot;
)
</code></pre>
<p>As stated before, the unit tests are not part of the final WebAssembly binary, hence
we can build them using the official Go compiler. That means we can use the <code>encoding/json</code>
package to simplify our tests.</p>
<p>We will start by writing a unit test that ensures we can allocate a <code>Settings</code>
instance from a <a href="writing-policies/go//writing-policies/index.html#the-validationrequest-object"><code>ValidationRequest</code></a>
object:</p>
<pre><code class="language-go">func TestParseValidSettings(t *testing.T) {
	request := `
	{
		&quot;request&quot;: &quot;doesn't matter here&quot;,
		&quot;settings&quot;: {
			&quot;denied_labels&quot;: [ &quot;foo&quot;, &quot;bar&quot; ],
			&quot;constrained_labels&quot;: {
				&quot;cost-center&quot;: &quot;cc-\\d+&quot;
			}
		}
	}
	`
	rawRequest := []byte(request)

	settings, err := NewSettingsFromValidationReq(rawRequest)
	if err != nil {
		t.Errorf(&quot;Unexpected error %+v&quot;, err)
	}

	expected_denied_labels := []string{&quot;foo&quot;, &quot;bar&quot;}
	for _, exp := range expected_denied_labels {
		if !settings.DeniedLabels.Contains(exp) {
			t.Errorf(&quot;Missing value %s&quot;, exp)
		}
	}

	re, found := settings.ConstrainedLabels[&quot;cost-center&quot;]
	if !found {
		t.Error(&quot;Didn't find the expected constrained label&quot;)
	}

	expected_regexp := `cc-\d+`
	if re.String() != expected_regexp {
		t.Errorf(&quot;Execpted regexp to be %v - got %v instead&quot;,
			expected_regexp, re.String())
	}
</code></pre>
<p>Next we will define a test that ensures a <code>Settings</code> instance
cannot be generated when the user provides a broken regular
expression:</p>
<pre><code class="language-go">func TestParseSettingsWithInvalidRegexp(t *testing.T) {
	request := `
	{
		&quot;request&quot;: &quot;doesn't matter here&quot;,
		&quot;settings&quot;: {
			&quot;denied_labels&quot;: [ &quot;foo&quot;, &quot;bar&quot; ],
			&quot;constrained_labels&quot;: {
				&quot;cost-center&quot;: &quot;cc-[a+&quot;
			}
		}
	}
	`
	rawRequest := []byte(request)

	_, err := NewSettingsFromValidationReq(rawRequest)
	if err == nil {
		t.Errorf(&quot;Didn'g get expected error&quot;)
	}
}
</code></pre>
<p>Next we will define a test that checks the behaviour
of the <a href="writing-policies/go//writing-policies/index.html#the-validate_settings-entry-point"><code>validate_settings</code></a>
entry-point.</p>
<p>In this case we actually look at the <code>SettingsValidationResponse</code> objected
returned by our <code>validateSettings</code> function:</p>
<pre><code class="language-go">func TestDetectValidSettings(t *testing.T) {
	request := `
	{
		&quot;denied_labels&quot;: [ &quot;foo&quot;, &quot;bar&quot; ],
		&quot;constrained_labels&quot;: {
			&quot;cost-center&quot;: &quot;cc-\\d+&quot;
		}
	}
	`
	rawRequest := []byte(request)
	responsePayload, err := validateSettings(rawRequest)
	if err != nil {
		t.Errorf(&quot;Unexpected error %+v&quot;, err)
	}

	var response kubewarden_testing.SettingsValidationResponse
	if err := json.Unmarshal(responsePayload, &amp;response); err != nil {
		t.Errorf(&quot;Unexpected error: %+v&quot;, err)
	}

	if !response.Valid {
		t.Errorf(&quot;Expected settings to be valid: %s&quot;, response.Message)
	}
}
</code></pre>
<p>Finally, we write two more tests to ensure the <code>validateSettings</code> function
rejects invalid settings with the right messages:</p>
<pre><code class="language-go">func TestDetectNotValidSettingsDueToBrokenRegexp(t *testing.T) {
	request := `
	{
		&quot;denied_labels&quot;: [ &quot;foo&quot;, &quot;bar&quot; ],
		&quot;constrained_labels&quot;: {
			&quot;cost-center&quot;: &quot;cc-[a+&quot;
		}
	}
	`
	rawRequest := []byte(request)
	responsePayload, err := validateSettings(rawRequest)
	if err != nil {
		t.Errorf(&quot;Unexpected error %+v&quot;, err)
	}

	var response kubewarden_testing.SettingsValidationResponse
	if err := json.Unmarshal(responsePayload, &amp;response); err != nil {
		t.Errorf(&quot;Unexpected error: %+v&quot;, err)
	}

	if response.Valid {
		t.Error(&quot;Expected settings to not be valid&quot;)
	}

	if response.Message != &quot;Provided settings are not valid: error parsing regexp: missing closing ]: `[a+`&quot; {
		t.Errorf(&quot;Unexpected validation error message: %s&quot;, response.Message)
	}
}

func TestDetectNotValidSettingsDueToConflictingLabels(t *testing.T) {
	request := `
	{
		&quot;denied_labels&quot;: [ &quot;foo&quot;, &quot;bar&quot;, &quot;cost-center&quot; ],
		&quot;constrained_labels&quot;: {
			&quot;cost-center&quot;: &quot;.*&quot;
		}
	}
	`
	rawRequest := []byte(request)
	responsePayload, err := validateSettings(rawRequest)
	if err != nil {
		t.Errorf(&quot;Unexpected error %+v&quot;, err)
	}

	var response kubewarden_testing.SettingsValidationResponse
	if err := json.Unmarshal(responsePayload, &amp;response); err != nil {
		t.Errorf(&quot;Unexpected error: %+v&quot;, err)
	}

	if response.Valid {
		t.Error(&quot;Expected settings to not be valid&quot;)
	}

	if response.Message != &quot;Provided settings are not valid: These labels cannot be constrained and denied at the same time: Set{cost-center}&quot; {
		t.Errorf(&quot;Unexpected validation error message: %s&quot;, response.Message)
	}
}
</code></pre>
<p>Now we can run the test by using the following command:</p>
<pre><code class="language-shell">go test -v settings.go settings_test.go
</code></pre>
<p>All the tests will pass with the following output:</p>
<pre><code class="language-shell">=== RUN   TestParseValidSettings
--- PASS: TestParseValidSettings (0.00s)
=== RUN   TestParseSettingsWithInvalidRegexp
--- PASS: TestParseSettingsWithInvalidRegexp (0.00s)
=== RUN   TestDetectValidSettings
--- PASS: TestDetectValidSettings (0.00s)
=== RUN   TestDetectNotValidSettingsDueToBrokenRegexp
--- PASS: TestDetectNotValidSettingsDueToBrokenRegexp (0.00s)
=== RUN   TestDetectNotValidSettingsDueToConflictingLabels
--- PASS: TestDetectNotValidSettingsDueToConflictingLabels (0.00s)
PASS
ok  	command-line-arguments	0.001s
</code></pre>
<p>We can now move to implement the actual validation code.</p>
<h1><a class="header" href="#writing-the-validation-logic" id="writing-the-validation-logic">Writing the validation logic</a></h1>
<p>It's now time to write the actual validation logic. This is done
inside of the <code>validate.go</code> file.</p>
<p>The scaffolded policy has already a <code>validate</code> function, we will need to make
very few changes to it.</p>
<p>This is how the function has to look like:</p>
<pre><code class="language-go">func validate(payload []byte) ([]byte, error) {
	// NOTE 1
	if !gjson.ValidBytes(payload) {
		return kubewarden.RejectRequest(
			kubewarden.Message(&quot;Not a valid JSON document&quot;),
			kubewarden.Code(400))
	}

	// NOTE 2
	settings, err := NewSettingsFromValidationReq(payload)
	if err != nil {
		return kubewarden.RejectRequest(
			kubewarden.Message(err.Error()),
			kubewarden.Code(400))
	}

	// NOTE 3
	data := gjson.GetBytes(
		payload,
		&quot;request.object.metadata.labels&quot;)

	// NOTE 4
	data.ForEach(func(key, value gjson.Result) bool {
		label := key.String()

		// NOTE 5
		if settings.DeniedLabels.Contains(label) {
			err = fmt.Errorf(&quot;Label %s is on the deny list&quot;, label)
			// stop iterating over labels
			return false
		}

		// NOTE 6
		regExp, found := settings.ConstrainedLabels[label]
		if found {
			// This is a constrained label
			if !regExp.Match([]byte(value.String())) {
				err = fmt.Errorf(&quot;The value of %s doesn't pass user-defined constraint&quot;, label)
				// stop iterating over labels
				return false
			}
		}

		return true
	})

	// NOTE 7
	if err != nil {
		return kubewarden.RejectRequest(
			kubewarden.Message(err.Error()),
			kubewarden.NoCode)
	}

	return kubewarden.AcceptRequest()
</code></pre>
<p>The code has some <code>NOTE</code> section inside of it. Let's get through them:</p>
<ol>
<li>The function ensures the JSON payload is properly formatted. This
is done using a function provided by the <code>gjson</code> library</li>
<li>The <code>Settings</code> instance is created using one of the constructor
methods we defined inside of <code>settings.go</code></li>
<li>We use a <code>gjson</code> selector to get the <code>label</code> map provided by the object
embedded into the request</li>
<li>We use a <code>gjson</code> helper to iterate over the results of the query. If the query
has no results the loop will never take place.</li>
<li>We look for the <code>label</code> of the object inside of the list of denied labels
provided by the user via the policy settings. If the <code>label</code> is a denied
one, we set the value of the <code>err</code> variable and exit from the loop (that
happens by returning <code>false</code> instead of <code>true</code>).</li>
<li>We look for the <code>label</code> of the object inside of the list of constrained labels
provided by the user via the policy settings. When we have a match we use
the regular expression provided by the user to validate the value of the label.
If the validation fails, we set the value of the <code>err</code> variable and exit
from the loop (that happens by returning <code>false</code> instead of <code>true</code>).</li>
<li>If the <code>err</code> variable is not <code>nil</code>, we use the helper provided by Kubewarden's
SDK to reject the request. Otherwise we accept it.</li>
</ol>
<h2><a class="header" href="#testing-the-validation-code" id="testing-the-validation-code">Testing the validation code</a></h2>
<p>It's now time to write some unit tests to ensure the validation code is behaving
properly. These tests are going to be located inside of the <code>validate_test.go</code>
file.</p>
<p>The tests will rely on some <a href="https://en.wikipedia.org/wiki/Test_fixture#Software">test fixtures</a>
located inside of the <code>test_data</code> directory. This directory has already
been populated by the template repository.</p>
<p>We will start by including the following packages:</p>
<pre><code class="language-go">import (
	&quot;encoding/json&quot;
	&quot;testing&quot;

	&quot;github.com/deckarep/golang-set&quot;
	kubewarden_testing &quot;github.com/kubewarden/policy-sdk-go/testing&quot;
)
</code></pre>
<p>The first unit test will ensure that having no user settings leads
to the request to be accepted:</p>
<pre><code class="language-go">func TestEmptySettingsLeadsToRequestAccepted(t *testing.T) {
	settings := Settings{}

	payload, err := kubewarden_testing.BuildValidationRequest(
		&quot;test_data/ingress.json&quot;,
		&amp;settings)
	if err != nil {
		t.Errorf(&quot;Unexpected error: %+v&quot;, err)
	}

	responsePayload, err := validate(payload)
	if err != nil {
		t.Errorf(&quot;Unexpected error: %+v&quot;, err)
	}

	var response kubewarden_testing.ValidationResponse
	if err := json.Unmarshal(responsePayload, &amp;response); err != nil {
		t.Errorf(&quot;Unexpected error: %+v&quot;, err)
	}

	if response.Accepted != true {
		t.Error(&quot;Unexpected rejection&quot;)
	}
}
</code></pre>
<p>As you can see we are using some test helper functions and structures provided
by the Kubewarden SDK.</p>
<p>The next test ensures a request can be accepted when none of its labels
is relevant to the user:</p>
<pre><code class="language-go">func TestRequestAccepted(t *testing.T) {
	constrainedLabels := make(map[string]*RegularExpression)
	re, err := CompileRegularExpression(`^world-`)
	if err != nil {
		t.Errorf(&quot;Unexpected error: %+v&quot;, err)
	}
	constrainedLabels[&quot;hello&quot;] = re

	settings := Settings{
		DeniedLabels:      mapset.NewThreadUnsafeSetFromSlice([]interface{}{&quot;bad1&quot;, &quot;bad2&quot;}),
		ConstrainedLabels: constrainedLabels,
	}

	payload, err := kubewarden_testing.BuildValidationRequest(
		&quot;test_data/ingress.json&quot;,
		&amp;settings)
	if err != nil {
		t.Errorf(&quot;Unexpected error: %+v&quot;, err)
	}

	responsePayload, err := validate(payload)
	if err != nil {
		t.Errorf(&quot;Unexpected error: %+v&quot;, err)
	}

	var response kubewarden_testing.ValidationResponse
	if err := json.Unmarshal(responsePayload, &amp;response); err != nil {
		t.Errorf(&quot;Unexpected error: %+v&quot;, err)
	}

	if response.Accepted != true {
		t.Error(&quot;Unexpected rejection&quot;)
	}
}
</code></pre>
<p>Next we will ensure a request is accepted when one of its labels satisfies
the constraint provided by the user:</p>
<pre><code class="language-go">func TestAcceptRequestWithConstraintLabel(t *testing.T) {
	constrainedLabels := make(map[string]*RegularExpression)
	re, err := CompileRegularExpression(`^team-`)
	if err != nil {
		t.Errorf(&quot;Unexpected error: %s&quot;, err)
	}
	constrainedLabels[&quot;owner&quot;] = re
	settings := Settings{
		DeniedLabels:      mapset.NewThreadUnsafeSetFromSlice([]interface{}{&quot;bad1&quot;, &quot;bad2&quot;}),
		ConstrainedLabels: constrainedLabels,
	}

	payload, err := kubewarden_testing.BuildValidationRequest(
		&quot;test_data/ingress.json&quot;,
		&amp;settings)
	if err != nil {
		t.Errorf(&quot;Unexpected error: %+v&quot;, err)
	}

	responsePayload, err := validate(payload)
	if err != nil {
		t.Errorf(&quot;Unexpected error: %+v&quot;, err)
	}

	var response kubewarden_testing.ValidationResponse
	if err := json.Unmarshal(responsePayload, &amp;response); err != nil {
		t.Errorf(&quot;Unexpected error: %+v&quot;, err)
	}

	if response.Accepted != true {
		t.Error(&quot;Unexpected rejection&quot;)
	}
}
</code></pre>
<p>It's now time to test the rejection of requests.</p>
<p>This test verifies a request is rejected when one of the labels is
on the deny list:</p>
<pre><code class="language-go">func TestRejectionBecauseDeniedLabel(t *testing.T) {
	constrainedLabels := make(map[string]*RegularExpression)
	re, err := CompileRegularExpression(`^world-`)
	if err != nil {
		t.Errorf(&quot;Unexpected error: %+v&quot;, err)
	}
	constrainedLabels[&quot;hello&quot;] = re

	settings := Settings{
		DeniedLabels:      mapset.NewThreadUnsafeSetFromSlice([]interface{}{&quot;owner&quot;}),
		ConstrainedLabels: constrainedLabels,
	}

	payload, err := kubewarden_testing.BuildValidationRequest(
		&quot;test_data/ingress.json&quot;,
		&amp;settings)
	if err != nil {
		t.Errorf(&quot;Unexpected error: %+v&quot;, err)
	}

	responsePayload, err := validate(payload)
	if err != nil {
		t.Errorf(&quot;Unexpected error: %+v&quot;, err)
	}

	var response kubewarden_testing.ValidationResponse
	if err := json.Unmarshal(responsePayload, &amp;response); err != nil {
		t.Errorf(&quot;Unexpected error: %+v&quot;, err)
	}

	if response.Accepted != false {
		t.Error(&quot;Unexpected accept response&quot;)
	}

	expected_message := &quot;Label owner is on the deny list&quot;
	if response.Message != expected_message {
		t.Errorf(&quot;Got '%s' instead of '%s'&quot;, response.Message, expected_message)
	}
}
</code></pre>
<p>The next test ensures a request is rejected when one of the user defined
constraints is not satisfied:</p>
<pre><code class="language-go">func TestRejectionBecauseConstrainedLabelNotValid(t *testing.T) {
	constrainedLabels := make(map[string]*RegularExpression)
	re, err := CompileRegularExpression(`^cc-\d+$`)
	if err != nil {
		t.Errorf(&quot;Unexpected error: %+v&quot;, err)
	}
	constrainedLabels[&quot;cc-center&quot;] = re

	settings := Settings{
		DeniedLabels:      mapset.NewThreadUnsafeSetFromSlice([]interface{}{}),
		ConstrainedLabels: constrainedLabels,
	}

	payload, err := kubewarden_testing.BuildValidationRequest(
		&quot;test_data/ingress.json&quot;,
		&amp;settings)
	if err != nil {
		t.Errorf(&quot;Unexpected error: %+v&quot;, err)
	}

	responsePayload, err := validate(payload)
	if err != nil {
		t.Errorf(&quot;Unexpected error: %+v&quot;, err)
	}

	var response kubewarden_testing.ValidationResponse
	if err := json.Unmarshal(responsePayload, &amp;response); err != nil {
		t.Errorf(&quot;Unexpected error: %+v&quot;, err)
	}

	if response.Accepted != false {
		t.Error(&quot;Unexpected accept response&quot;)
	}

	expected_message := &quot;The value of cc-center doesn't pass user-defined constraint&quot;
	if response.Message != expected_message {
		t.Errorf(&quot;Got '%s' instead of '%s'&quot;, response.Message, expected_message)
	}
}
</code></pre>
<p>We can now run all the unit tests, including the one defined inside of <code>settings_test.go</code>,
by using this simple command:</p>
<pre><code class="language-shell">make test
</code></pre>
<p>This will produce the following output:</p>
<pre><code class="language-shell">go test -v
=== RUN   TestParseValidSettings
--- PASS: TestParseValidSettings (0.00s)
=== RUN   TestParseSettingsWithInvalidRegexp
--- PASS: TestParseSettingsWithInvalidRegexp (0.00s)
=== RUN   TestDetectValidSettings
--- PASS: TestDetectValidSettings (0.00s)
=== RUN   TestDetectNotValidSettingsDueToBrokenRegexp
--- PASS: TestDetectNotValidSettingsDueToBrokenRegexp (0.00s)
=== RUN   TestDetectNotValidSettingsDueToConflictingLabels
--- PASS: TestDetectNotValidSettingsDueToConflictingLabels (0.00s)
=== RUN   TestEmptySettingsLeadsToRequestAccepted
--- PASS: TestEmptySettingsLeadsToRequestAccepted (0.00s)
=== RUN   TestRequestAccepted
--- PASS: TestRequestAccepted (0.00s)
=== RUN   TestAcceptRequestWithConstraintLabel
--- PASS: TestAcceptRequestWithConstraintLabel (0.00s)
=== RUN   TestRejectionBecauseDeniedLabel
--- PASS: TestRejectionBecauseDeniedLabel (0.00s)
=== RUN   TestRejectionBecauseConstrainedLabelNotValid
--- PASS: TestRejectionBecauseConstrainedLabelNotValid (0.00s)
PASS
ok  	github.com/kubewarden/safe-labels-policy	0.001s
</code></pre>
<p>We can now move to the next step, write some end-to-end tests.</p>
<h1><a class="header" href="#end-to-end-testing" id="end-to-end-testing">End-to-end testing</a></h1>
<p>So far we have tested the policy using a set of Go unit tests. This section shows
how we can write end-to-end test that run tests against the actual WebAssembly
binary produced by TinyGo.</p>
<h2><a class="header" href="#prerequisites-1" id="prerequisites-1">Prerequisites</a></h2>
<p>These tools need to be installed on your development machine:</p>
<ul>
<li>docker or another container engine: used to build the WebAssembly
policy. We will rely on the compiler shipped within the official
TinyGo container image.</li>
<li><a href="https://github.com/sstephenson/bats">bats</a>: used to write the
tests and automate their execution.</li>
<li><a href="https://github.com/kubewarden/policy-server/releases">policy-testdrive</a>:
cli tool provided by Kubewarden to run its policies outside of
Kubernetes. This is covered in depth inside of <a href="writing-policies/go//testing-policies.html">this section</a>
of the documentation.</li>
</ul>
<h2><a class="header" href="#building-the-policy-1" id="building-the-policy-1">Building the policy</a></h2>
<p>As a first step we need to build the policy into a WebAssembly binary.</p>
<p>This can be done with this simple command:</p>
<pre><code class="language-shell">make wasm
</code></pre>
<p>This will pull the official TinyGo container image and run the build process
inside of an ephemeral container.</p>
<p>The compilation produces a file called <code>policy.wasm</code>.</p>
<h2><a class="header" href="#writing-tests" id="writing-tests">Writing tests</a></h2>
<p>We are going to use <a href="https://github.com/sstephenson/bats">bats</a> to write and
automate our tests. Each test will be composed by the following steps:</p>
<ol>
<li>Run the policy using <code>policy-testdrive</code>.</li>
<li>Perform some assertions against the output produced by the
<code>policy-testdrive</code>.</li>
</ol>
<p>All the end-to-end tests are located inside of a file called <code>e2e.bats</code>. The
scaffolded project already includes such a file. We will just change its
contents to reflect how our policy behaves.</p>
<p>As a final note, the end-to-end tests we will use the same test fixtures files
we previously used inside of the Go unit tests.</p>
<p>The first test ensures a request is approved when no settings are provided:</p>
<pre><code class="language-bash">@test &quot;accept when no settings are provided&quot; {
  run policy-testdrive -p policy.wasm -r test_data/ingress.json

  # this prints the output when one the checks below fails
  echo &quot;output = ${output}&quot;

  # settings validation passed
  [[ &quot;$output&quot; == *&quot;valid: true&quot;* ]]

  # request rejected
  [[ &quot;$output&quot; == *&quot;allowed: true&quot;* ]]
}
</code></pre>
<p>We can execute the end-to-end tests by using this command:</p>
<pre><code class="language-shell">make e2e-tests
</code></pre>
<p>This will produce the following output:</p>
<pre><code class="language-shell">bats e2e.bats
 âœ“ accept when no settings are provided

1 test, 0 failures
</code></pre>
<p>Let's write a test to ensure a request is approved when a user-defined constraint
is respected:</p>
<pre><code class="language-bash">@test &quot;accept user defined constraint is respected&quot; {
  run policy-testdrive -p policy.wasm \
    -r test_data/ingress.json \
    -s '{&quot;constrained_labels&quot;: {&quot;owner&quot;: &quot;^team-&quot;}}'
  # this prints the output when one the checks below fails
  echo &quot;output = ${output}&quot;

  # settings validation passed
  [[ &quot;$output&quot; == *&quot;valid: true&quot;* ]]

  # request accepted
  [[ &quot;$output&quot; == *&quot;allowed: true&quot;* ]]
}
</code></pre>
<p>Next, we can write a test to ensure a request is accepted when none of the
labels is on the deny list:</p>
<pre><code class="language-bash">@test &quot;accept labels are not on deny list&quot; {
  run policy-testdrive -p policy.wasm \
    -r test_data/ingress.json \
    -s '{&quot;denied_labels&quot;: [&quot;foo&quot;, &quot;bar&quot;]}'
  # this prints the output when one the checks below fails
  echo &quot;output = ${output}&quot;

  # settings validation passed
  [[ &quot;$output&quot; == *&quot;valid: true&quot;* ]]

  # request accepted
  [[ &quot;$output&quot; == *&quot;allowed: true&quot;* ]]
}
</code></pre>
<p>Let's improve the test coverage by adding a test that rejects a request
because one of the labels is on the deny list:</p>
<pre><code class="language-bash">@test &quot;reject because label is on deny list&quot; {
  run policy-testdrive -p policy.wasm \
    -r test_data/ingress.json \
    -s '{&quot;denied_labels&quot;: [&quot;foo&quot;, &quot;owner&quot;]}'

  # this prints the output when one the checks below fails
  echo &quot;output = ${output}&quot;

  # settings validation passed
  [[ &quot;$output&quot; == *&quot;valid: true&quot;* ]]

  # request rejected
  [[ &quot;$output&quot; == *&quot;allowed: false&quot;* ]]
  [[ &quot;$output&quot; == *&quot;Label owner is on the deny list&quot;* ]]
}
</code></pre>
<p>The following test ensures a request is rejected when one of its labels doesn't
satisfy the constraint provided by the user:</p>
<pre><code class="language-bash">@test &quot;reject because label doesn't pass validation constraint&quot; {
  run policy-testdrive -p policy.wasm \
    -r test_data/ingress.json \
    -s '{&quot;constrained_labels&quot;: {&quot;cc-center&quot;: &quot;^cc-\\d+$&quot;}}'

  # this prints the output when one the checks below fails
  echo &quot;output = ${output}&quot;

  # settings validation passed
  [[ &quot;$output&quot; == *&quot;valid: true&quot;* ]]

  # request rejected
  [[ &quot;$output&quot; == *&quot;allowed: false&quot;* ]]
  [[ &quot;$output&quot; == *&quot;The value of cc-center doesn\'t pass user-defined constraint&quot;* ]]
}
</code></pre>
<p>We want to ensure settings' validation is working properly. This can be done
with the following tests:</p>
<pre><code class="language-bash">@test &quot;fail settings validation because of conflicting labels&quot; {
  run policy-testdrive -p policy.wasm \
    -r test_data/ingress.json \
    -s '{&quot;denied_labels&quot;: [&quot;foo&quot;, &quot;cc-center&quot;], &quot;constrained_labels&quot;: {&quot;cc-center&quot;: &quot;^cc-\\d+$&quot;}}'

  # this prints the output when one the checks below fails
  echo &quot;output = ${output}&quot;

  # settings validation passed
  [[ &quot;$output&quot; == *&quot;valid: false&quot;* ]]
  [[ &quot;$output&quot; == *&quot;Provided settings are not valid: These labels cannot be constrained and denied at the same time: Set{cc-center}&quot;* ]]
}

@test &quot;fail settings validation because of invalid constraint&quot; {
  run policy-testdrive -p policy.wasm \
    -r test_data/ingress.json \
    -s '{&quot;constrained_labels&quot;: {&quot;cc-center&quot;: &quot;^cc-[12$&quot;}}'

  # this prints the output when one the checks below fails
  echo &quot;output = ${output}&quot;

  # settings validation passed
  [[ &quot;$output&quot; == *&quot;valid: false&quot;* ]]
  [[ &quot;$output&quot; == *&quot;Provided settings are not valid: error parsing regexp: missing closing ]: `[12$`&quot;* ]]
}
</code></pre>
<h2><a class="header" href="#conclusion" id="conclusion">Conclusion</a></h2>
<p>We have reached a pretty good level of coverage, let's run all the end-to-end
tests:</p>
<pre><code class="language-shell">$ make e2e-tests
bats e2e.bats
 âœ“ accept when no settings are provided
 âœ“ accept user defined constraint is respected
 âœ“ accept labels are not on deny list
 âœ“ reject because label is on deny list
 âœ“ reject because label doesn't pass validation constraint
 âœ“ fail settings validation because of conflicting labels
 âœ“ fail settings validation because of invalid constraint

7 tests, 0 failures
</code></pre>
<h1><a class="header" href="#automations" id="automations">Automations</a></h1>
<p>This section describes how we can use GitHub Actions to automate as many tasks
as possible.</p>
<p>The scaffolded project already includes all the GitHub actions you need.
These files can be found inside of the <code>.github/workflows</code> directory.</p>
<p>The same principles can be adapted to use a different CI system.</p>
<h2><a class="header" href="#testing" id="testing">Testing</a></h2>
<p>We can automate the execution of the unit tests and of the end-to-end tests.</p>
<p>This is working out of the box thanks to these files:</p>
<ul>
<li><code>.github/workflows/e2e-tests.yml</code></li>
<li><code>.github/workflows/unit-tests.yml</code></li>
</ul>
<h2><a class="header" href="#release" id="release">Release</a></h2>
<p>The scaffolded project created a <code>.github/workflows/release.yml.template</code>.</p>
<p>This file defines a pipeline that performs the following steps:</p>
<ul>
<li>Checkout code</li>
<li>Build the WebAssembly policy</li>
<li>Push the policy to an OCI registry</li>
<li>Eventually create a new GitHub Release</li>
</ul>
<p>To enable the pipeline you need to rename it to <code>release.yml</code> and change the
value of the <code>OCI_TARGET</code> to match your preferences.</p>
<p>The pipeline will act differently based on the commit that triggered its execution.</p>
<p>Regular commits will lead to the creation of an OCI artifact called <code>&lt;policy-name&gt;:latest</code>.
No GitHub Release will be created for this commits.</p>
<p>On the other hand, creating a tag that matches the <code>v*</code> pattern, will lead
to:</p>
<ol>
<li>Creation of an OCI artifact called <code>&lt;policy-name&gt;:&lt;tag&gt;</code>.</li>
<li>Creation of a GitHub Release named <code>Release &lt;full tag name&gt;</code>. The release
will include the following assets: the source code of the policy and the WebAssembly
binary.</li>
</ol>
<h3><a class="header" href="#a-concrete-example" id="a-concrete-example">A concrete example</a></h3>
<p>Let's assume we have a policy named named <code>safe-labels</code> and we want to publish
it as <code>ghcr.io/kubewarden/policies/safe-labels</code>.</p>
<p>The contents of the <code>jobs.env</code> section of <code>release.yml</code> should look like that:</p>
<pre><code class="language-yaml">jobs:
  build:
    name: Create new release with Wasm artifact
    runs-on: ubuntu-latest
    env:
      WASM_BINARY_NAME: policy.wasm
      OCI_TARGET: ghcr.io/kubewarden/policies/safe-labels
</code></pre>
<p>Pushing a tag named <code>v0.1.0</code> will lead to the creation and publishing of the
OCI artifact called <code>ghcr.io/kubewarden/policies/safe-labels:v0.1.0</code>.</p>
<p>A GitHub Release named <code>Release v0.1.0</code> will be created. The release will
include the following assets:</p>
<ul>
<li>Source code compressed as <code>zip</code> and <code>tar.gz</code></li>
<li>A file named <code>policy.wasm</code> that is the actual WebAssembly policy</li>
</ul>
<h1><a class="header" href="#distribute-policy" id="distribute-policy">Distribute policy</a></h1>
<p>Congratulations for having made this far ðŸŽ‰ðŸŽ‰ðŸŽ‰</p>
<p>We hope you enjoyed the journey!</p>
<p>In case you haven't realized, we actually created the
<a href="https://github.com/kubewarden/safe-labels-policy">safe-labels-policy</a>
together.</p>
<p>There's nothing special to be done when it comes to distributing the
policy. If you followed this guide you have already published
your policy using the GitHub <code>release.yml</code> Action defined in the previous
chapter.</p>
<p>The topic of distributing policies is covered in depth inside of the
<a href="writing-policies/go//distributing-policies.html">&quot;distributing policies&quot;</a>
section of Kubewarden's documentation.</p>
<h1><a class="header" href="#distributing-policies" id="distributing-policies">Distributing Policies</a></h1>
<p>Kubewarden policies are Wasm binaries that are evaluated by the
Kubewarden Policy Server.</p>
<p>The Kubewarden policy server can load policies from these
sources:</p>
<ul>
<li>Local filesystem</li>
<li>HTTP(s) server</li>
<li>OCI compliant registry like <a href="https://github.com/distribution/distribution">distribution</a>
and other container registries (GitHub container registry, Azure Container
Registry, Amazon ECR, Google Container Registry, ...)</li>
</ul>
<p>We think distributing Kubewarden policies via a regular OCI compliant
registry is the best choice. Container registries are basically a
mandatory requirement for any Kubernetes cluster. Having a single
place to store, and secure, all the artifacts required by a cluster
can be really handy.</p>
<h1><a class="header" href="#pushing-policies-to-an-oci-compliant-registry" id="pushing-policies-to-an-oci-compliant-registry">Pushing policies to an OCI compliant registry</a></h1>
<p>The <a href="https://github.com/opencontainers/artifacts">OCI Artifacts</a>
specification allows to store any kind of binary blob inside of a
regular OCI compliant container registry.</p>
<p>The target OCI compliant registry <strong>must support artifacts</strong> in order
to successfully push a Kubewarden Policy to it.</p>
<p>The <a href="https://github.com/engineerd/wasm-to-oci"><code>wasm-to-oci</code></a> command line tool
can be used to push a Kubewarden Policy to an OCI compliant registry.</p>
<p>Pushing a policy can be done in this way:</p>
<pre><code class="language-bash">$ wasm-to-oci push pod-runtime-class-policy.wasm \
              &lt;oci-registry&gt;/kubewarden-policies/pod-runtime-class-policy:v0.0.1
</code></pre>
<p>The policy can then be referenced from the Kubewarden Policy Server as
<code>registry://&lt;oci-registry&gt;/kubewarden-policies/pod-runtime-class-policy:v0.0.1</code>.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>
