include::partial$variables.adoc[]
= Verifying {project-name}
:revdate: 2025-11-06
:page-revdate: {revdate}
:description: Verifying {project-name}.
:doc-persona: ["kubewarden-operator", "kubewarden-policy-developer", "kubewarden-integrator"]
:doc-topic: ["security", "verifying-kubewarden"]
:doc-type: ["tutorial"]
:keywords: ["kubewarden", "kubernetes", "security", "verification"]
:current-version: {page-origin-branch}

The {project-name} stack provides different attestations and assurances:

- Provenance attestations: Inform of the build process, build dependencies, and aids in replicating the builds. Implement https://slsa.dev/spec/v1.0/[SLSA] Standard (level 3 in our case).
- SBOMs attestations: Contain the software dependencies. Help downstream consumers ascertain vulnerabilities of {short-project-name} and its dependencies.
- Signed artifacts: Indicate if an artifact is authentic or not, providing supply chain security. This includes the deliverables, but also the provenance and SBOM attestations.

{short-project-name} artifacts, provenance attestations and SBOMs are signed using https://docs.sigstore.dev[Sigstore],
with the keyless workflow. This means that the signing certificate contains the
following info, where `*` matches any following characters:

* issuer: `+https://token.actions.githubusercontent.com+`
* subject: `+https://github.com/kubewarden/*+`
* x509 certificate extension for GHA, "github_workflow_repository": `kubewarden/*`

[IMPORTANT]
====
The subject used in the `--certificate-identity-regexp` cosign CLI flag in this
tutorial utilizes the `+https://github.com/kubewarden/*+` values to simplify the
explanation. However, this allows artifacts from repositories with the same prefix to
bypass validation. For example: `github.com/kubewarden/policy-server1`.

If you want a more secure check, you need to use a full URL:

----
https://github.com/kubewarden/policy-server/.github/workflows/container-image.yml@refs/tags/v1.30.0
----

Note that the URL includes the full repository path, the workflow file path,
and the version tag. If you follow this best practice, you can use the cosign
CLI flag `--certificate-identity` with the full URL.
====

The {short-project-name} team is also making efforts to improve the secure supply chain
and to make the whole stack SLSA level 3 compliant. Therefore, the main
artifacts also include SBOM and provenance files. In the following sections, we
will show how to verify the different artifacts produced by the {short-project-name} team
and how to ensure the secure supply chain of the artifacts using SBOM and
provenance files.

[#container-images]
== Container images

To verify the keyless-signed container images produced by the {short-project-name} team,
you can use the `cosign` CLI tool. For example, to verify the
`kubewarden/policy-server` image, you can execute the following command:

[source, console]
----
cosign verify ghcr.io/kubewarden/policy-server:v1.30.0 \
  --certificate-identity-regexp 'https://github.com/kubewarden/*' \
  --certificate-oidc-issuer https://token.actions.githubusercontent.com

Verification for ghcr.io/kubewarden/policy-server:v1.30.0 --
The following checks were performed on each of these signatures:
  - The cosign claims were validated
  - Existence of the claims in the transparency log was verified offline
  - The code-signing certificate was verified using trusted certificate authority certificates

<snipped json>
----

You can then verify that the certificate in the returned JSON contains the
correct issuer, subject, and `github_workflow_repository` extensions.

You can also verify with link:https://github.com/rancherlabs/slsactl[`slsactl`].
For example, for version 1.30.0:

[source, console]
----
slsactl verify ghcr.io/kubewarden/policy-server:v1.30.0
----

The same applies to all other images produced by the {short-project-name} team,
such as `kubewarden/kubewarden-controller` and `kubewarden/audit-scanner`.

All container images also have SBOM and provenance files that can be used to
ensure the secure supply chain of the images. You can find attestation files on
the release page of the component or attached to the container image in the OCI
registry.

We use Docker to build the images and their attestations. However, the cosign
command https://github.com/sigstore/cosign/issues/2688[does not yet support]
the verification of the attestations generated by Docker from the OCI registry.
For this reason, you need to download the files from the release page or the
registry and verify them locally. If you want to download the attestation files
from the OCI registry, you can follow the
https://docs.docker.com/build/metadata/attestations/attestation-storage/[Docker
documentation] and use tools like `crane` or `docker` itself to download the
files from the registry.

When downloading the attestation files from the release page of
the {short-project-name} components, check them:

[,console]
----
$ cosign verify-blob --bundle audit-scanner-attestation-amd64-checksum-cosign.bundle \
    --certificate-oidc-issuer=https://token.actions.githubusercontent.com \
    --certificate-identity="https://github.com/kubewarden/audit-scanner/.github/workflows/attestation.yml@refs/tags/v1.30.0" \
    audit-scanner-attestation-amd64-checksum.txt
Verified OK
----

Now that the files integrity is verified, you can inspect the SBOM and Provenance files.
You can get these from the container image, using link:https://github.com/rancherlabs/slsactl[`slsactl].
For example, for version 1.30.0:

[,console]
----
slsactl download provenance ghcr.io/kubewarden/policy-server:v1.30.0
slsactl download sbom ghcr.io/kubewarden/policy-server:v1.30.0
----

== Helm charts

You can find {short-project-name} Helm charts in our `https://` traditional
Helm repository under https://charts.kubewarden.io.

The same Helm charts are signed via Sigstore's keyless signing, and pushed to an
OCI repository that holds both the Helm chart and its provenance attestation as OCI
artifacts.

The Helm charts are published alongside a https://hauler.dev[Hauler] manifest
that lists all needed artifacts.

=== Verifying with Hauler

Hauler automatically verifies the artifacts on download. For more information,
refer to xref:/howtos/airgap/03-hauler.adoc[our documentation].

=== Verifying manually

Since Helm 3.8.0, Helm has support for OCI registries, but because of
constraints in them, they can't be searched via `helm`. You can find the
https://github.com/orgs/kubewarden/packages?tab=packages&q=charts[list of charts in GitHub Container Registry].

To verify a Helm chart, you need `cosign` installed. Then execute the following
command, for example:

----
cosign verify ghcr.io/kubewarden/charts/kubewarden-defaults:1.5.4 \
  --certificate-identity-regexp 'https://github.com/kubewarden/*' \
  --certificate-oidc-issuer https://token.actions.githubusercontent.com

Verification for ghcr.io/kubewarden/charts/kubewarden-defaults:1.5.4 --
The following checks were performed on each of these signatures:
  - The cosign claims were validated
  - Existence of the claims in the transparency log was verified offline
  - The code-signing certificate was verified using trusted certificate authority certificates

<snipped json>
----

You can then verify that the cert in the returned json contains the correct
issuer, subject, and `github_workflow_repository` extensions.

The chart attestations are pushed to the OCI registry as an artifact layer. See the xref:#container-images[container images] section on how to verify them.

{short-project-name} charts ship `imagelist.txt` and (`policylist.txt` when relevant) inside
of the chart. Hence, if you already verified the chart, you can use those lists
to verify the consumed container images and policies.

{short-project-name} also follows the usual practices with regards to Helm charts. Hence, one
can also find all the images in the Helm charts with a plugin such as
https://github.com/cvila84/helm-image[helm-image], or with the following script:

[subs="+attributes",bash]
----
#!/usr/bin/env bash
helm pull --untar kubewarden/kubewarden-controller && \
helm pull --untar kubewarden/kubewarden-defaults && \
{ helm template ./kubewarden-controller; helm template ./kubewarden-defaults } \
    | yq '..|.image? | select(.)' \
    | sort -u | sed 's/"//g'
----

which gives us:

----
ghcr.io/kubewarden/kubewarden-controller:v0.5.5
ghcr.io/kubewarden/policy-server:v0.3.1
ghcr.io/kubewarden/kubectl:v1.21.4
----

Now, for each image in that list you can verify their Sigstore signatures following the instructions from the xref:#container-images[previous section].

== kwctl

kwctl binaries are signed using https://docs.sigstore.dev/cosign/signing/signing_with_blobs/[Sigstore's blob signing].

When you download a https://github.com/kubewarden/kwctl/releases/[`kwctl`
release] each zip file contains
a Sigstore bundle file that you can use for verification: `kwctl-*bundle.sigstore`.

In order to verify kwctl you need cosign installed, and then execute the
following command:

----
cosign verify-blob \
  --bundle kwctl-linux-x86_64.bundle.sigstore \
  --certificate-identity-regexp 'https://github.com/kubewarden/*' \
  --certificate-oidc-issuer https://token.actions.githubusercontent.com \
  kwctl-linux-x86_64

Verified OK
----

You can then verify that the cert in the returned json contains the correct
issuer, subject, and `github_workflow_repository` extensions.

The SBOMs are signed and published in the
https://github.com/kubewarden/kwctl/releases[GitHub Releases] of the project.

The provenance attestation for `kwctl` is verified by using
https://cli.github.com/manual/gh_attestation_verify[`gh attestation verify`]. For
example with `gh attestation verify kwctl-linux-x86_64 --repo kubewarden/kwctl`.

== Policies

Policies maintained by the {short-project-name} team are also signed using the Sigstore project. Similar to
usual container images, one can verify them using `cosign`:

----
cosign verify ghcr.io/kubewarden/policies/verify-image-signatures:v0.2.5 \
  --certificate-identity-regexp 'https://github.com/kubewarden/*' \
  --certificate-oidc-issuer https://token.actions.githubusercontent.com

Verification for ghcr.io/kubewarden/policies/verify-image-signatures:v0.2.5 --
The following checks were performed on each of these signatures:
  - The cosign claims were validated
  - Existence of the claims in the transparency log was verified offline
  - The code-signing certificate was verified using trusted certificate authority certificates

  <snipped json>
----

You can then verify that the cert in the returned json contains the correct
issuer, subject, and `github_workflow_repository` extensions.
