"use strict";(self.webpackChunkkubewarden_docusaurus=self.webpackChunkkubewarden_docusaurus||[]).push([[1290],{3905:function(e,t,n){n.d(t,{Zo:function(){return u},kt:function(){return h}});var s=n(7294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(e);t&&(s=s.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,s)}return n}function a(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function r(e,t){if(null==e)return{};var n,s,i=function(e,t){if(null==e)return{};var n,s,i={},o=Object.keys(e);for(s=0;s<o.length;s++)n=o[s],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(s=0;s<o.length;s++)n=o[s],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var l=s.createContext({}),c=function(e){var t=s.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):a(a({},t),e)),n},u=function(e){var t=c(e.components);return s.createElement(l.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return s.createElement(s.Fragment,{},t)}},d=s.forwardRef((function(e,t){var n=e.components,i=e.mdxType,o=e.originalType,l=e.parentName,u=r(e,["components","mdxType","originalType","parentName"]),d=c(n),h=i,g=d["".concat(l,".").concat(h)]||d[h]||p[h]||o;return n?s.createElement(g,a(a({ref:t},u),{},{components:n})):s.createElement(g,a({ref:t},u))}));function h(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var o=n.length,a=new Array(o);a[0]=d;var r={};for(var l in t)hasOwnProperty.call(t,l)&&(r[l]=t[l]);r.originalType=e,r.mdxType="string"==typeof e?e:i,a[1]=r;for(var c=2;c<o;c++)a[c]=n[c];return s.createElement.apply(null,a)}return s.createElement.apply(null,n)}d.displayName="MDXCreateElement"},2386:function(e,t,n){n.r(t),n.d(t,{assets:function(){return u},contentTitle:function(){return l},default:function(){return h},frontMatter:function(){return r},metadata:function(){return c},toc:function(){return p}});var s=n(3117),i=n(102),o=(n(7294),n(3905)),a=["components"],r={sidebar_label:"End-to-end testing",title:""},l="End-to-end testing",c={unversionedId:"writing-policies/go/e2e-tests",id:"writing-policies/go/e2e-tests",title:"",description:"So far we have tested the policy using a set of Go unit tests. This section shows",source:"@site/docs/writing-policies/go/05-e2e-tests.md",sourceDirName:"writing-policies/go",slug:"/writing-policies/go/e2e-tests",permalink:"/writing-policies/go/e2e-tests",editUrl:"https://github.com/kubewarden/docs/edit/main/docs/writing-policies/go/05-e2e-tests.md",tags:[],version:"current",lastUpdatedAt:1651836433,formattedLastUpdatedAt:"5/6/2022",sidebarPosition:5,frontMatter:{sidebar_label:"End-to-end testing",title:""},sidebar:"docs",previous:{title:"Write the Validation Logic",permalink:"/writing-policies/go/validation"},next:{title:"Logging",permalink:"/writing-policies/go/logging"}},u={},p=[{value:"Prerequisites",id:"prerequisites",level:2},{value:"Building the policy",id:"building-the-policy",level:2},{value:"Writing tests",id:"writing-tests",level:2},{value:"Conclusion",id:"conclusion",level:2}],d={toc:p};function h(e){var t=e.components,n=(0,i.Z)(e,a);return(0,o.kt)("wrapper",(0,s.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"end-to-end-testing"},"End-to-end testing"),(0,o.kt)("p",null,"So far we have tested the policy using a set of Go unit tests. This section shows\nhow we can write end-to-end test that run tests against the actual WebAssembly\nbinary produced by TinyGo."),(0,o.kt)("h2",{id:"prerequisites"},"Prerequisites"),(0,o.kt)("p",null,"These tools need to be installed on your development machine:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"docker or another container engine: used to build the WebAssembly\npolicy. We will rely on the compiler shipped within the official\nTinyGo container image."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"https://github.com/bats-core/bats-core"},"bats"),": used to write the\ntests and automate their execution."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"https://github.com/kubewarden/kwctl/releases"},"kwctl"),": CLI tool\nprovided by Kubewarden to run its policies outside of Kubernetes,\namong other actions. This is covered in depth inside of ",(0,o.kt)("a",{parentName:"li",href:"/testing-policies/intro"},"this\nsection")," of the documentation.")),(0,o.kt)("h2",{id:"building-the-policy"},"Building the policy"),(0,o.kt)("p",null,"As a first step we need to build the policy, producing a WebAssembly\nbinary."),(0,o.kt)("p",null,"This can be done with this simple command:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-shell"},"make wasm\n")),(0,o.kt)("p",null,"This will pull the official TinyGo container image and run the build process\ninside of an ephemeral container."),(0,o.kt)("p",null,"The compilation produces a file called ",(0,o.kt)("inlineCode",{parentName:"p"},"policy.wasm"),"."),(0,o.kt)("h2",{id:"writing-tests"},"Writing tests"),(0,o.kt)("p",null,"We are going to use ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/bats-core/bats-core"},"bats")," to write and\nautomate our tests. Each test will be composed by the following steps:"),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},"Run the policy using ",(0,o.kt)("inlineCode",{parentName:"li"},"kwctl"),"."),(0,o.kt)("li",{parentName:"ol"},"Perform some assertions against the output produced by the\n",(0,o.kt)("inlineCode",{parentName:"li"},"kwctl"),".")),(0,o.kt)("p",null,"All the end-to-end tests are located inside of a file called ",(0,o.kt)("inlineCode",{parentName:"p"},"e2e.bats"),". The\nscaffolded project already includes such a file. We will just change its\ncontents to reflect how our policy behaves."),(0,o.kt)("p",null,"As a final note, the end-to-end tests we will use the same test fixtures files\nwe previously used inside of the Go unit tests."),(0,o.kt)("p",null,"The first test ensures a request is approved when no settings are provided:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-bash"},'@test "accept when no settings are provided" {\n  run kwctl run -r test_data/ingress.json policy.wasm\n\n  # this prints the output when one the checks below fails\n  echo "output = ${output}"\n\n  # request is accepted\n  [ $(expr "$output" : \'.*"allowed":true.*\') -ne 0 ]\n}\n')),(0,o.kt)("p",null,"We can execute the end-to-end tests by using this command:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-shell"},"make e2e-tests\n")),(0,o.kt)("p",null,"This will produce the following output:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-shell"},"bats e2e.bats\n \u2713 accept when no settings are provided\n\n1 test, 0 failures\n")),(0,o.kt)("p",null,"Let's write a test to ensure a request is approved when a user-defined constraint\nis respected:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-bash"},'@test "accept user defined constraint is respected" {\n  run kwctl run  \\\n    -r test_data/ingress.json \\\n    --settings-json \'{"constrained_labels": {"owner": "^team-"}}\' \\\n    policy.wasm\n\n  # this prints the output when one the checks below fails\n  echo "output = ${output}"\n\n  # request is accepted\n  [ $(expr "$output" : \'.*"allowed":true.*\') -ne 0 ]\n}\n')),(0,o.kt)("p",null,"Next, we can write a test to ensure a request is accepted when none of the\nlabels is on the deny list:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-bash"},'@test "accept labels are not on deny list" {\n  run kwctl run \\\n    -r test_data/ingress.json \\\n    --settings-json \'{"denied_labels": ["foo", "bar"]}\' \\\n    policy.wasm\n\n  # this prints the output when one the checks below fails\n  echo "output = ${output}"\n\n  # request is accepted\n  [ $(expr "$output" : \'.*"allowed":true.*\') -ne 0 ]\n}\n')),(0,o.kt)("p",null,"Let's improve the test coverage by adding a test that rejects a request\nbecause one of the labels is on the deny list:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-bash"},'@test "reject because label is on deny list" {\n  run kwctl run \\\n    -r test_data/ingress.json \\\n    --settings-json \'{"denied_labels": ["foo", "owner"]}\' \\\n    policy.wasm\n\n  # this prints the output when one the checks below fails\n  echo "output = ${output}"\n\n  # request is rejected\n  [ $(expr "$output" : \'.*"allowed":false.*\') -ne 0 ]\n  [[ "$output" == *"Label owner is on the deny list"* ]]\n}\n')),(0,o.kt)("p",null,"The following test ensures a request is rejected when one of its labels doesn't\nsatisfy the constraint provided by the user."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-bash"},'@test "reject because label doesn\'t pass validation constraint" {\n  run kwctl run \\\n    -r test_data/ingress.json \\\n    --settings-json \'{"constrained_labels": {"cc-center": "^cc-\\\\d+$"}}\' \\\n    policy.wasm\n\n  # this prints the output when one the checks below fails\n  echo "output = ${output}"\n\n  # request is rejected\n  [ $(expr "$output" : \'.*"allowed":false.*\') -ne 0 ]\n  [[ "$output" == *"The value of cc-center doesn\'t pass user-defined constraint"* ]]\n}\n')),(0,o.kt)("p",null,"We want to ensure settings' validation is working properly. This can be done\nwith the following tests:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-bash"},'@test "fail settings validation because of conflicting labels" {\n  run kwctl run \\\n    -r test_data/ingress.json \\\n    --settings-json \'{"denied_labels": ["foo", "cc-center"], "constrained_labels": {"cc-center": "^cc-\\\\d+$"}}\' \\\n    policy.wasm\n\n  # this prints the output when one the checks below fails\n  echo "output = ${output}"\n\n  # settings validation failed\n  [ $(expr "$output" : \'.*"valid":false.*\') -ne 0 ]\n  [[ "$output" == *"Provided settings are not valid: These labels cannot be constrained and denied at the same time: Set{cc-center}"* ]]\n}\n\n@test "fail settings validation because of invalid constraint" {\n  run kwctl run \\\n    -r test_data/ingress.json \\\n    --settings-json \'{"constrained_labels": {"cc-center": "^cc-[12$"}}\' \\\n    policy.wasm\n\n  # this prints the output when one the checks below fails\n  echo "output = ${output}"\n\n  [[ "$output" == *"Provided settings are not valid: error parsing regexp: missing closing ]: `[12$`"* ]]\n}\n')),(0,o.kt)("h2",{id:"conclusion"},"Conclusion"),(0,o.kt)("p",null,"We have reached a pretty good level of coverage, let's run all the end-to-end\ntests:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-shell"},"$ make e2e-tests\nbats e2e.bats\n \u2713 accept when no settings are provided\n \u2713 accept user defined constraint is respected\n \u2713 accept labels are not on deny list\n \u2713 reject because label is on deny list\n \u2713 reject because label doesn't pass validation constraint\n \u2713 fail settings validation because of conflicting labels\n \u2713 fail settings validation because of invalid constraint\n\n7 tests, 0 failures\n")))}h.isMDXComponent=!0}}]);