"use strict";(self.webpackChunkkubewarden_docusaurus=self.webpackChunkkubewarden_docusaurus||[]).push([[789],{3905:(e,n,i)=>{i.d(n,{Zo:()=>u,kt:()=>g});var t=i(7294);function a(e,n,i){return n in e?Object.defineProperty(e,n,{value:i,enumerable:!0,configurable:!0,writable:!0}):e[n]=i,e}function o(e,n){var i=Object.keys(e);if(Object.getOwnPropertySymbols){var t=Object.getOwnPropertySymbols(e);n&&(t=t.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),i.push.apply(i,t)}return i}function s(e){for(var n=1;n<arguments.length;n++){var i=null!=arguments[n]?arguments[n]:{};n%2?o(Object(i),!0).forEach((function(n){a(e,n,i[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(i)):o(Object(i)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(i,n))}))}return e}function r(e,n){if(null==e)return{};var i,t,a=function(e,n){if(null==e)return{};var i,t,a={},o=Object.keys(e);for(t=0;t<o.length;t++)i=o[t],n.indexOf(i)>=0||(a[i]=e[i]);return a}(e,n);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(t=0;t<o.length;t++)i=o[t],n.indexOf(i)>=0||Object.prototype.propertyIsEnumerable.call(e,i)&&(a[i]=e[i])}return a}var l=t.createContext({}),c=function(e){var n=t.useContext(l),i=n;return e&&(i="function"==typeof e?e(n):s(s({},n),e)),i},u=function(e){var n=c(e.components);return t.createElement(l.Provider,{value:n},e.children)},p={inlineCode:"code",wrapper:function(e){var n=e.children;return t.createElement(t.Fragment,{},n)}},d=t.forwardRef((function(e,n){var i=e.components,a=e.mdxType,o=e.originalType,l=e.parentName,u=r(e,["components","mdxType","originalType","parentName"]),d=c(i),g=a,h=d["".concat(l,".").concat(g)]||d[g]||p[g]||o;return i?t.createElement(h,s(s({ref:n},u),{},{components:i})):t.createElement(h,s({ref:n},u))}));function g(e,n){var i=arguments,a=n&&n.mdxType;if("string"==typeof e||a){var o=i.length,s=new Array(o);s[0]=d;var r={};for(var l in n)hasOwnProperty.call(n,l)&&(r[l]=n[l]);r.originalType=e,r.mdxType="string"==typeof e?e:a,s[1]=r;for(var c=2;c<o;c++)s[c]=i[c];return t.createElement.apply(null,s)}return t.createElement.apply(null,i)}d.displayName="MDXCreateElement"},6807:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>l,contentTitle:()=>s,default:()=>p,frontMatter:()=>o,metadata:()=>r,toc:()=>c});var t=i(3117),a=(i(7294),i(3905));const o={sidebar_label:"Secure Supply Chain",title:""},s="Secure Supply Chain",r={unversionedId:"distributing-policies/secure-supply-chain",id:"distributing-policies/secure-supply-chain",title:"",description:"A Secure Supply Chain infrastructure allows software developers and users to ensure",source:"@site/docs/distributing-policies/secure-supply-chain.md",sourceDirName:"distributing-policies",slug:"/distributing-policies/secure-supply-chain",permalink:"/distributing-policies/secure-supply-chain",draft:!1,editUrl:"https://github.com/kubewarden/docs/edit/main/docs/distributing-policies/secure-supply-chain.md",tags:[],version:"current",lastUpdatedAt:1674225242,formattedLastUpdatedAt:"Jan 20, 2023",frontMatter:{sidebar_label:"Secure Supply Chain",title:""},sidebar:"docs",previous:{title:"Custom Certificate Authorities",permalink:"/distributing-policies/custom-certificate-authorities"},next:{title:"Testing Policies",permalink:"/testing-policies/intro"}},l={},c=[{value:"Prerequisites",id:"prerequisites",level:2},{value:"Signing policies",id:"signing-policies",level:2},{value:"Keyless signing",id:"keyless-signing",level:3},{value:"How to sign artefacts in GitHub workflows",id:"how-to-sign-artefacts-in-github-workflows",level:3},{value:"Listing policy signatures",id:"listing-policy-signatures",level:2},{value:"Verifying policies",id:"verifying-policies",level:2},{value:"Configuring the policy server to check policy signatures",id:"configuring-the-policy-server-to-check-policy-signatures",level:2},{value:"Signature Config Reference",id:"signature-config-reference",level:2},{value:"Signature validation",id:"signature-validation",level:3},{value:"Public key validation",id:"public-key-validation",level:4},{value:"Keyless signatures validation",id:"keyless-signatures-validation",level:4},{value:"GitHub actions signature verification",id:"github-actions-signature-verification",level:4},{value:"Signature annotations validation",id:"signature-annotations-validation",level:4},{value:"How to use signature verification config file to check a policy OCI artefact",id:"how-to-use-signature-verification-config-file-to-check-a-policy-oci-artefact",level:3}],u={toc:c};function p(e){let{components:n,...i}=e;return(0,a.kt)("wrapper",(0,t.Z)({},u,i,{components:n,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"secure-supply-chain"},"Secure Supply Chain"),(0,a.kt)("p",null,"A Secure Supply Chain infrastructure allows software developers and users to ensure\nthe validity of the artefacts' chain of custody, thus mitigating\nsecurity issues in their environments. The goal of the ",(0,a.kt)("a",{parentName:"p",href:"https://sigstore.dev/"},"Sigstore project"),"\nis to provide the tools and infrastructure for validating the integrity of the supply chain.\nKubewarden leverages the ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/sigstore/cosign"},(0,a.kt)("inlineCode",{parentName:"a"},"cosign"))," utility together\nwith the ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/SigStore/fulcio"},"fulcio")," and ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/sigstore/rekor"},"rekor"),"\ninfrastructure offered by the Sigstore project to bring these security measures to its users."),(0,a.kt)("p",null,"Therefore, cluster operators can configure Kubewarden to only run policies signed\nby entities that they trust while policy developers can sign their policies and\npublish them in a registry."),(0,a.kt)("h2",{id:"prerequisites"},"Prerequisites"),(0,a.kt)("p",null,"In the following sections, we will need a few tools to be installed so that\nusers can sign and verify OCI artefacts signatures. For key-based signing, the examples demonstrate\nthe use of ",(0,a.kt)("a",{parentName:"p",href:"https://docs.sigstore.dev/cosign/installation/"},(0,a.kt)("inlineCode",{parentName:"a"},"cosign"))," and ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/kubewarden/kwctl"},(0,a.kt)("inlineCode",{parentName:"a"},"kwctl"))," utilities for signing and inspecting policies."),(0,a.kt)("p",null,"Users may also want to leverage GitHub to sign their policies. In which case, they can choose to install and use\n",(0,a.kt)("a",{parentName:"p",href:"https://docs.sigstore.dev/cosign/installation/#github-action"},"Github actions")),(0,a.kt)("p",null,"Keyless signing has been demonstrated using the default ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/SigStore/fulcio"},"fulcio"),"\nand ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/sigstore/rekor"},"rekor")," instances provided by the\nSigstore project. Users may choose to utilise their own\ninfrastructure by checking the Sigstore project documentation for more details."),(0,a.kt)("h2",{id:"signing-policies"},"Signing policies"),(0,a.kt)("p",null,"Kubewarden recommends using Sigstore's ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/sigstore/cosign"},"cosign")," utility\nfor signing policies. This subsection details a key-based method of signing policies\nin which, users need to generate a private-public key pair. The generated keys help\nin verifying whether the signed artefacts came from the expected user i.e. the\nowner of the keys. Using the ",(0,a.kt)("inlineCode",{parentName:"p"},"cosign generate-key-pair")," command, as illustrated\nbelow, it is possible to generate the aforementioned keypair."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-bash"},"cosign generate-key-pair\nEnter password for private key:\nEnter password for private key again:\nPrivate key written to cosign.key\nPublic key written to cosign.pub\n")),(0,a.kt)("p",null,"Once the keys are generated, users can use it to sign policies."),(0,a.kt)("blockquote",null,(0,a.kt)("p",{parentName:"blockquote"},(0,a.kt)("strong",{parentName:"p"},"WARNING"),": The private key file, ",(0,a.kt)("inlineCode",{parentName:"p"},"cosign.key"),", should not be shared. This\nis a secret file that should be used only by the owner of the key for signing policies.")),(0,a.kt)("p",null,"To sign a policy users can execute the ",(0,a.kt)("inlineCode",{parentName:"p"},"cosign sign")," command passing the ",(0,a.kt)("inlineCode",{parentName:"p"},"--key"),"\ncommand line argument with their private key file:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-bash"},"cosign sign --key cosign.key ghcr.io/jvanz/policies/user-group-psp:latest\nan error occurred: no provider found for that key reference, will try to load key from disk...\nEnter password for private key:\nPushing signature to: ghcr.io/jvanz/policies/user-group-psp\n")),(0,a.kt)("p",null,"This command will sign the policy by creating a new signature object. The signature\nobject is then uploaded into the registry, next to the policy. Now the policy is ready to be used\nin a Kubewarden installation with signature verification enabled."),(0,a.kt)("p",null,"The same policy can be signed multiple times, either by the same user or by different ones. All these signatures are appended to the same signature object."),(0,a.kt)("blockquote",null,(0,a.kt)("p",{parentName:"blockquote"},(0,a.kt)("strong",{parentName:"p"},"NOTE"),": For more information about how the signing process works under the hood, check\nout the ",(0,a.kt)("a",{parentName:"p",href:"https://docs.sigstore.dev/"},"Sigstore project documentation"))),(0,a.kt)("h3",{id:"keyless-signing"},"Keyless signing"),(0,a.kt)("p",null,"Many times the policies are automatically built in CI/CD pipelines which complicates\nthe key generation process. The Sigstore keyless workflow described below is specifically designed for\nthese situations and others where key generation is not possible.\nInstead of using long-lived singing keys, the keyless workflow uses certificate authorities (CAs) and\ncertificate chains. A short-lived certificate key is generated, and linked into\na chain of trust by completing an identity challenge to confirm the signer's\nidentity. The life of the certificate key is just about enough for the signing\nto occur. The identity challenge is performed by authenticating against an\nOpenID Connect (OIDC) provider. Sigstore's Fulcio public infrastructure is used for the chain of trust."),(0,a.kt)("p",null,"For signing, we will again use Sigstore's cosign utility. However, as of this\nwriting, this feature is not enabled by default in cosign. So, it's necessary\nto enable this experimental feature before proceeding with keyless signing as shown below:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-console"},"$ COSIGN_EXPERIMENTAL=1 cosign sign ghcr.io/jvanz/policies/user-group-psp:latest\nGenerating ephemeral keys...\nRetrieving signed certificate...\nYour browser will now be opened to:\nhttps://oauth2.sigstore.dev/auth/auth?access_type=online&client_id=sigstore&code_challenge=<REDACTED>&code_challenge_method=S256&nonce=<REDACTED>&redirect_uri=http%3A%2F%2Flocalhost%3A34021%2Fauth%2Fcallback&response_type=code&scope=openid+email&state=<REDACTED>\nclient.go:196: root pinning is not supported in Spec 1.0.19\nSuccessfully verified SCT...\ntlog entry created with index: 1819248\nPushing signature to: ghcr.io/jvanz/policies/user-group-psp\n")),(0,a.kt)("p",null,"With that, the policy has been signed and pushed to the repository. Note that there are no keys generated as a byproduct."),(0,a.kt)("h3",{id:"how-to-sign-artefacts-in-github-workflows"},"How to sign artefacts in GitHub workflows"),(0,a.kt)("p",null,(0,a.kt)("inlineCode",{parentName:"p"},"cosign")," does not require the user to log on to an OIDC provider when using keyless signing\nin the context of a GitHub action environment. In this scenario,\nthe GitHub token available during the execution of the workflow will be used to\nauthenticate the user and generate the ephemeral keys. The signing process is\nthe same used in the ",(0,a.kt)("inlineCode",{parentName:"p"},"Keyless")," mode. This is an example of how Kubewarden project\nsigns its policies:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-yaml"},"# ... beginning of the workflow file ...\njobs:\n  build:\n    name: Build container image\n    runs-on: ubuntu-latest\n    steps:\n      # ... other steps building the container image ...\n      -\n      name: Login to GitHub Container Registry\n      uses: docker/login-action@v1\n      with:\n        registry: ghcr.io\n        username: ${{ github.repository_owner }}\n        password: ${{ inputs.GITHUB_TOKEN }}\n      -\n      name: Publish Wasm policy artifact to OCI registry with the 'latest' tag\n      shell: bash\n      if: ${{ startsWith(github.ref, 'refs/heads/') }}\n      env:\n        COSIGN_EXPERIMENTAL: 1\n      run: |\n        set -ex\n        echo Pushing policy to OCI container registry\n        IMMUTABLE_REF=$(kwctl push -o json ${{ PATH_TO_BUILT_WASM_FILE }} ghcr.io/myorg/policies/my-great-policy:latest | jq -r .immutable_ref)\n        echo Keyless signing of policy using cosign\n        cosign sign ${IMMUTABLE_REF}\n      # ... other build steps ...\n\n# ... remaining of the workflow file ...\n")),(0,a.kt)("blockquote",null,(0,a.kt)("p",{parentName:"blockquote"},(0,a.kt)("strong",{parentName:"p"},"NOTE"),": The policy templates repositories provided by the Kubewarden team\nalready have Github actions to build, test, sign and publish policies. It's\nhighly recommended that policy developers use those templates.")),(0,a.kt)("p",null,"In the example above, we demonstrate using ",(0,a.kt)("inlineCode",{parentName:"p"},"kwctl")," to publish the container image and find\nthe reference to it. This is not mandatory. You can call ",(0,a.kt)("inlineCode",{parentName:"p"},"cosign")," with the image\nreference generated elsewhere."),(0,a.kt)("h2",{id:"listing-policy-signatures"},"Listing policy signatures"),(0,a.kt)("p",null,(0,a.kt)("inlineCode",{parentName:"p"},"kwctl")," also allows users to check the signatures in a published\npolicy. The ",(0,a.kt)("inlineCode",{parentName:"p"},"kwctl inspect")," command shows all the relevant information about the\npolicy and its signatures as illustrated in an example below:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-console"},'$ kwctl inspect registry://ghcr.io/kubewarden/policies/user-group-psp:v0.2.0\nDetails\ntitle:              psp-user-group\ndescription:        Short description\nauthor:             Jos\xe9 Guilherme Vanz <jguilhermevanz@suse.com>\nurl:                https://github.com/kubewarden/user-group-psp-policy\nsource:             https://github.com/kubewarden/user-group-psp-policy\nlicense:            Apache-2.0\nmutating:           true\ncontext aware:      false\nexecution mode:     kubewarden-wapc\nprotocol version:   1\n\nAnnotations\nio.kubewarden.kwctl 0.2.5-rc2\n\nRules\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n---\n- apiGroups:\n    - ""\n  apiVersions:\n    - v1\n  resources:\n    - pods\n  operations:\n    - CREATE\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n\nUsage\nThis policy enforce the user and group used in the container.\n\nSigstore signatures\n\nDigest:                            sha256:026af67682a85d424e7d95db460171635f5c3957d67b53499bece912cc0413cc\nMedia type:                        application/vnd.dev.cosign.simplesigning.v1+json\nSize:                              258\nAnnotations\ndev.sigstore.cosign/certificate    -----BEGIN CERTIFICATE-----\n                                   MIIDRzCCAsygAwIBAgITbPUZlUFkkAHtbzc3rzC/3zXj1DAKBggqhkjOPQQDAzAq\n                                   MRUwEwYDVQQKEwxzaWdzdG9yZS5kZXYxETAPBgNVBAMTCHNpZ3N0b3JlMB4XDTIy\n                                   MDIyNTE2MzAwMloXDTIyMDIyNTE2NDAwMVowEzERMA8GA1UEChMIc2lnc3RvcmUw\n                                   WTATBgcqhkjOPQIBBggqhkjOPQMBBwNCAAR/O5c6ZI5BzBweoEIam4uWu5fqzHx0\n                                   3PTCgfXyyvIjorz9wX08bsndkHdWfFObU+PztbxX78An43Yw9/fHtO93o4IB5jCC\n                                   AeIwDgYDVR0PAQH/BAQDAgeAMBMGA1UdJQQMMAoGCCsGAQUFBwMDMAwGA1UdEwEB\n                                   /wQCMAAwHQYDVR0OBBYEFCP/v7NEJQglbDmyC5VMgnvhiuBUMB8GA1UdIwQYMBaA\n                                   FFjAHl+RRaVmqXrMkKGTItAqxcX6MHgGA1UdEQRxMG+GbWh0dHBzOi8vZ2l0aHVi\n                                   LmNvbS9rdWJld2FyZGVuL2dpdGh1Yi1hY3Rpb25zLy5naXRodWIvd29ya2Zsb3dz\n                                   L3JldXNhYmxlLXJlbGVhc2UtcG9saWN5LXJ1c3QueW1sQHJlZnMvaGVhZHMvdjEw\n                                   NgYKKwYBBAGDvzABAwQoMmJiMGQ4NjZjMzFmOGMyZTQ3NDMxMDI4M2ExNmFkMWFi\n                                   NjBlZjA1YjAuBgorBgEEAYO/MAEFBCBrdWJld2FyZGVuL3VzZXItZ3JvdXAtcHNw\n                                   LXBvbGljeTAcBgorBgEEAYO/MAEEBA5SZWxlYXNlIHBvbGljeTASBgorBgEEAYO/\n                                   MAECBARwdXNoMDkGCisGAQQBg78wAQEEK2h0dHBzOi8vdG9rZW4uYWN0aW9ucy5n\n                                   aXRodWJ1c2VyY29udGVudC5jb20wHgYKKwYBBAGDvzABBgQQcmVmcy90YWdzL3Yw\n                                   LjIuMDAKBggqhkjOPQQDAwNpADBmAjEAyGQbNCkOifStO7yCCfF8yXyc144ANn2x\n                                   Ty92WYC0pTaVhviOED47fgD6TncKf+92AjEAjBfjLmCG/Mwrh8t+gfHJEAWWEc9Q\n                                   +j9NR4wF66uABS/TTh5CYlrnIuqSD+GBHGwV\n                                   -----END CERTIFICATE-----\ndev.sigstore.cosign/timestamp      {"signatures":[{"keyid":"b6710623a30c010738e64c5209d367df1c0a18cf90e6ab5292fb01680f83453d","sig":"3046022100f666a7f4b3d85d8003f2c166e27827dfa0c4ab9282e9dab19485f4e702c61700022100dfe826e0edab5f80a40f08cc87b87777a4db30775d85684fe4950e797f2f565c"}],"signed":{"_type":"timestamp","spec_version":"1.0","version":15,"expires":"2022-03-08T19:14:05Z","meta":{"snapshot.json":{"length":1655,"hashes":{"sha256":"36cf063d0717f6dc03e23027721adcd69b684d293956d3a1a7db7b0848f711d7","sha512":"f90946d0a2dc58dae4505cfb91517a40299adf9e8719f52af187e2025aad69fcdeaeded271ec25db24869841c16fbe24f3fc56f56af8fdbb8808dccec4636b64"},"version":15}}}}\ndev.sigstore.cosign/bundle         {"SignedEntryTimestamp":"MEUCIEfu4qR+HsexSDk5h2QXMduvoRCX10J+4CLQWtYw5VD6AiEAyYCEjvJdv2Sr5tZ4LApnddH/4v+CoV1QkuvbCQ3iIUM=","Payload":{"body":"eyJhcGlWZXJzaW9uIjoiMC4wLjEiLCJraW5kIjoiaGFzaGVkcmVrb3JkIiwic3BlYyI6eyJkYXRhIjp7Imhhc2giOnsiYWxnb3JpdGhtIjoic2hhMjU2IiwidmFsdWUiOiIwMjZhZjY3NjgyYTg1ZDQyNGU3ZDk1ZGI0NjAxNzE2MzVmNWMzOTU3ZDY3YjUzNDk5YmVjZTkxMmNjMDQxM2NjIn19LCJzaWduYXR1cmUiOnsiY29udGVudCI6Ik1FWUNJUUNXNWZRZ1BUUTdaTlNuRkhzbHJOTlFrS2dTSVFpOGNSMTU5UEExc0s4VGlRSWhBSndMOWJPcUJKbVduN1lLZG9Tem80c2xPZ2s4SkJCanFYZHNydDNyeVF0QiIsInB1YmxpY0tleSI6eyJjb250ZW50IjoiTFMwdExTMUNSVWRKVGlCRFJWSlVTVVpKUTBGVVJTMHRMUzB0Q2sxSlNVUlNla05EUVhONVowRjNTVUpCWjBsVVlsQlZXbXhWUm10clFVaDBZbnBqTTNKNlF5OHplbGhxTVVSQlMwSm5aM0ZvYTJwUFVGRlJSRUY2UVhFS1RWSlZkMFYzV1VSV1VWRkxSWGQ0ZW1GWFpIcGtSemw1V2xNMWExcFlXWGhGVkVGUVFtZE9Wa0pCVFZSRFNFNXdXak5PTUdJelNteE5RalJZUkZSSmVRcE5SRWw1VGxSRk1rMTZRWGROYkc5WVJGUkplVTFFU1hsT1ZFVXlUa1JCZDAxV2IzZEZla1ZTVFVFNFIwRXhWVVZEYUUxSll6SnNibU16VW5aamJWVjNDbGRVUVZSQ1oyTnhhR3RxVDFCUlNVSkNaMmR4YUd0cVQxQlJUVUpDZDA1RFFVRlNMMDgxWXpaYVNUVkNla0ozWlc5RlNXRnROSFZYZFRWbWNYcEllREFLTTFCVVEyZG1XSGw1ZGtscWIzSjZPWGRZTURoaWMyNWthMGhrVjJaR1QySlZLMUI2ZEdKNFdEYzRRVzQwTTFsM09TOW1TSFJQT1ROdk5FbENOV3BEUXdwQlpVbDNSR2RaUkZaU01GQkJVVWd2UWtGUlJFRm5aVUZOUWsxSFFURlZaRXBSVVUxTlFXOUhRME56UjBGUlZVWkNkMDFFVFVGM1IwRXhWV1JGZDBWQ0NpOTNVVU5OUVVGM1NGRlpSRlpTTUU5Q1FsbEZSa05RTDNZM1RrVktVV2RzWWtSdGVVTTFWazFuYm5ab2FYVkNWVTFDT0VkQk1WVmtTWGRSV1UxQ1lVRUtSa1pxUVVoc0sxSlNZVlp0Y1ZoeVRXdExSMVJKZEVGeGVHTllOazFJWjBkQk1WVmtSVkZTZUUxSEswZGlWMmd3WkVoQ2VrOXBPSFphTW13d1lVaFdhUXBNYlU1MllsTTVjbVJYU214a01rWjVXa2RXZFV3eVpIQmtSMmd4V1dreGFGa3pVbkJpTWpWNlRIazFibUZZVW05a1YwbDJaREk1ZVdFeVduTmlNMlI2Q2t3elNteGtXRTVvV1cxNGJFeFlTbXhpUjFab1l6SlZkR05IT1hOaFYwNDFURmhLTVdNelVYVmxWekZ6VVVoS2JGcHVUWFpoUjFab1draE5kbVJxUlhjS1RtZFpTMHQzV1VKQ1FVZEVkbnBCUWtGM1VXOU5iVXBwVFVkUk5FNXFXbXBOZWtadFQwZE5lVnBVVVROT1JFMTRUVVJKTkUweVJYaE9iVVpyVFZkR2FRcE9ha0pzV21wQk1WbHFRWFZDWjI5eVFtZEZSVUZaVHk5TlFVVkdRa05DY21SWFNteGtNa1o1V2tkV2RVd3pWbnBhV0VsMFdqTktkbVJZUVhSalNFNTNDa3hZUW5aaVIyeHFaVlJCWTBKbmIzSkNaMFZGUVZsUEwwMUJSVVZDUVRWVFdsZDRiRmxZVG14SlNFSjJZa2RzYW1WVVFWTkNaMjl5UW1kRlJVRlpUeThLVFVGRlEwSkJVbmRrV0U1dlRVUnJSME5wYzBkQlVWRkNaemM0ZDBGUlJVVkxNbWd3WkVoQ2VrOXBPSFprUnpseVdsYzBkVmxYVGpCaFZ6bDFZM2sxYmdwaFdGSnZaRmRLTVdNeVZubFpNamwxWkVkV2RXUkROV3BpTWpCM1NHZFpTMHQzV1VKQ1FVZEVkbnBCUWtKblVWRmpiVlp0WTNrNU1GbFhaSHBNTTFsM0NreHFTWFZOUkVGTFFtZG5jV2hyYWs5UVVWRkVRWGRPY0VGRVFtMUJha1ZCZVVkUllrNURhMDlwWmxOMFR6ZDVRME5tUmpoNVdIbGpNVFEwUVU1dU1uZ0tWSGs1TWxkWlF6QndWR0ZXYUhacFQwVkVORGRtWjBRMlZHNWpTMllyT1RKQmFrVkJha0ptYWt4dFEwY3ZUWGR5YURoMEsyZG1TRXBGUVZkWFJXTTVVUW9yYWpsT1VqUjNSalkyZFVGQ1V5OVVWR2cxUTFsc2NtNUpkWEZUUkN0SFFraEhkMVlLTFMwdExTMUZUa1FnUTBWU1ZFbEdTVU5CVkVVdExTMHRMUW89In19fX0=","integratedTime":1645806604,"logIndex":1506651,"logID":"c0d23d6ad406973f9559f3ba2d1ca01f84147d8ffc5b8445c224f98b9591801d"}}\ndev.sigstore.cosign/chain          -----BEGIN CERTIFICATE-----\n                                   MIIB9zCCAXygAwIBAgIUALZNAPFdxHPwjeDloDwyYChAO/4wCgYIKoZIzj0EAwMw\n                                   KjEVMBMGA1UEChMMc2lnc3RvcmUuZGV2MREwDwYDVQQDEwhzaWdzdG9yZTAeFw0y\n                                   MTEwMDcxMzU2NTlaFw0zMTEwMDUxMzU2NThaMCoxFTATBgNVBAoTDHNpZ3N0b3Jl\n                                   LmRldjERMA8GA1UEAxMIc2lnc3RvcmUwdjAQBgcqhkjOPQIBBgUrgQQAIgNiAAT7\n                                   XeFT4rb3PQGwS4IajtLk3/OlnpgangaBclYpsYBr5i+4ynB07ceb3LP0OIOZdxex\n                                   X69c5iVuyJRQ+Hz05yi+UF3uBWAlHpiS5sh0+H2GHE7SXrk1EC5m1Tr19L9gg92j\n                                   YzBhMA4GA1UdDwEB/wQEAwIBBjAPBgNVHRMBAf8EBTADAQH/MB0GA1UdDgQWBBRY\n                                   wB5fkUWlZql6zJChkyLQKsXF+jAfBgNVHSMEGDAWgBRYwB5fkUWlZql6zJChkyLQ\n                                   KsXF+jAKBggqhkjOPQQDAwNpADBmAjEAj1nHeXZp+13NWBNa+EDsDP8G1WWg1tCM\n                                   WP/WHPqpaVo0jhsweNFZgSs0eE7wYI4qAjEA2WB9ot98sIkoF3vZYdd3/VtWB5b9\n                                   TNMea7Ix/stJ5TfcLLeABLE4BNJOsQ4vnBHJ\n                                   -----END CERTIFICATE-----\ndev.cosignproject.cosign/signature MEYCIQCW5fQgPTQ7ZNSnFHslrNNQkKgSIQi8cR159PA1sK8TiQIhAJwL9bOqBJmWn7YKdoSzo4slOgk8JBBjqXdsrt3ryQtB\n')),(0,a.kt)("h2",{id:"verifying-policies"},"Verifying policies"),(0,a.kt)("p",null,"Users can check if a policy is properly signed with  ",(0,a.kt)("inlineCode",{parentName:"p"},"cosign")," or ",(0,a.kt)("inlineCode",{parentName:"p"},"kwctl"),".\nBoth have similar command line flags which allow users to check the policy\nsignatures. To check if the binary is signed with a key, the users can use ",(0,a.kt)("inlineCode",{parentName:"p"},"kwctl"),"\nlike this:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-console"},"$ kwctl verify -k cosign.pub ghcr.io/jvanz/policies/user-group-psp:latest\n2022-03-29T14:49:31.878180Z  INFO kwctl::verify: Policy successfully verified\n")),(0,a.kt)("p",null,"Or ",(0,a.kt)("inlineCode",{parentName:"p"},"cosign")," :"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-console"},'$ cosign verify --key cosign.pub ghcr.io/jvanz/policies/user-group-psp:latest\n\nVerification for ghcr.io/jvanz/policies/user-group-psp:latest --\nThe following checks were performed on each of these signatures:\n  - The cosign claims were validated\n  - The signatures were verified against the specified public key\n  - Any certificates were verified against the Fulcio roots.\n\n[{"critical":{"identity":{"docker-reference":"ghcr.io/jvanz/policies/user-group-psp"},"image":{"docker-manifest-digest":"sha256:af520a8ccee03811d426c48634b7007f1220c121cc23e14962bb64510585ce97"},"type":"cosign container image signature"},"optional":null}]\n')),(0,a.kt)("h2",{id:"configuring-the-policy-server-to-check-policy-signatures"},"Configuring the policy server to check policy signatures"),(0,a.kt)("p",null,"To configure Kubewarden to run only trusted policies, the users must create\na ",(0,a.kt)("inlineCode",{parentName:"p"},"ConfigMap")," with the minimum signature requirements needed for policies to be\nexecuted in the environment. The ",(0,a.kt)("inlineCode",{parentName:"p"},"ConfigMap")," follows the same structure of the\nfile described in the ",(0,a.kt)("a",{parentName:"p",href:"#signature-config-reference"},"Signature Config Reference")," section used to verify policy\nin the ",(0,a.kt)("inlineCode",{parentName:"p"},"kwctl")," utility. The only difference in this case would be that the\n",(0,a.kt)("inlineCode",{parentName:"p"},"ConfigMap")," should define all the configurations under the ",(0,a.kt)("inlineCode",{parentName:"p"},"verification-config"),"\nfield.  For example, let's consider that the users want to run policies signed\nby the Kubewarden GitHub organization. A sample ",(0,a.kt)("inlineCode",{parentName:"p"},"ConfigMap")," for this scenario would be:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-console"},'$ cat kubewarden_signatures.yaml\napiVersion: v1\nallOf:\n  - kind: githubAction\n    owner: kubewarden\n\n# note that the data is stored under verification-config field\n$ kubectl  create configmap my-signatures-configuration --from-file=verification-config=kubewarden_signatures.yaml\n\n$ kubectl get configmap -o yaml my-signatures-configuration\napiVersion: v1\ndata:\n  verification-config: |\n    apiVersion: v1\n    allOf:\n      - kind: githubAction\n        owner: kubewarden\nkind: ConfigMap\nmetadata:\n  creationTimestamp: "2022-03-29T18:27:20Z"\n  name: my-signatures-configuration\n  namespace: default\n  resourceVersion: "10279"\n  uid: d53e1c56-1fee-45de-92f5-9bd73b8cead4\n')),(0,a.kt)("p",null,"It is also possible to use the ",(0,a.kt)("inlineCode",{parentName:"p"},"kwctl scaffold verification-config")," to generate\na default verification config file to be used in the ",(0,a.kt)("inlineCode",{parentName:"p"},"ConfigMap"),":"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-console"},'$ kwctl scaffold verification-config > verification_config.yaml\n$ cat verification_config.yaml\n# Default Kubewarden verification config\n#\n# With this config, the only valid policies are those signed by Kubewarden\n# infrastructure.\n#\n# This config can be saved to its default location (for this OS) with:\n#   kwctl scaffold verification-config > /home/jvanz/.config/kubewarden/verification-config.yml\n#\n# Providing a config in the default location enables Sigstore verification.\n# See https://docs.kubewarden.io for more Sigstore verification options.\n---\napiVersion: v1\nallOf:\n  - kind: githubAction\n    owner: kubewarden\n    repo: ~\n    annotations: ~\nanyOf: ~\n\n$ kubectl create configmap my-signatures-configuration --from-file=verification-config=verification_config.yaml\nconfigmap/my-signatures-configuration created\n$ kubectl get configmap -o yaml my-signatures-configuration\napiVersion: v1\ndata:\n  verification-config: |+\n    # Default Kubewarden verification config\n    #\n    # With this config, the only valid policies are those signed by Kubewarden\n    # infrastructure.\n    #\n    # This config can be saved to its default location (for this OS) with:\n    #   kwctl scaffold verification-config > /home/jvanz/.config/kubewarden/verification-config.yml\n    #\n    # Providing a config in the default location enables Sigstore verification.\n    # See https://docs.kubewarden.io for more Sigstore verification options.\n    ---\n    apiVersion: v1\n    allOf:\n      - kind: githubAction\n        owner: kubewarden\n        repo: ~\n        annotations: ~\n    anyOf: ~\n\nkind: ConfigMap\nmetadata:\n  creationTimestamp: "2022-04-07T11:54:27Z"\n  name: my-signatures-configuration\n  namespace: default\n  resourceVersion: "1317"\n  uid: 74dec846-7fcd-4b4b-8184-700c816f685a\n')),(0,a.kt)("p",null,"After creating the ",(0,a.kt)("inlineCode",{parentName:"p"},"ConfigMap")," to store the signature requirements, the users\ncan configure a Policy Server to start validating policy signatures by setting the\n",(0,a.kt)("inlineCode",{parentName:"p"},"ConfigMap")," name in the field ",(0,a.kt)("inlineCode",{parentName:"p"},"verificationConfig"),"."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-yaml"},'apiVersion: policies.kubewarden.io/v1alpha2\nkind: PolicyServer\nmetadata:\n  name: default\n  finalizers:\n    - kubewarden\nspec:\n  image: ghcr.io/kubewarden/policy-server:v0.2.7\n  serviceAccountName: policy-server\n  replicas: 1\n  verificationConfig: your_configmap   #name of the confimap with the signatures requirements\n  env:\n    - name: KUBEWARDEN_ENABLE_METRICS\n      value: "1"\n    - name: KUBEWARDEN_LOG_FMT\n      value: otlp\n    - name: "KUBEWARDEN_LOG_LEVEL"\n      value: "info"\n')),(0,a.kt)("p",null,"If you deploy the default Policy Server using the ",(0,a.kt)("inlineCode",{parentName:"p"},"kubewarden-defaults"),"\nHelm chart, you can configure this field by setting the ",(0,a.kt)("inlineCode",{parentName:"p"},"ConfigMap")," name in the\n",(0,a.kt)("inlineCode",{parentName:"p"},"policyServer.verificationConfig")," value."),(0,a.kt)("p",null,"Now, the PolicyServer will reject untrusted AdmissionPolicies and ClusterAdmissionPolicies,\nby refusing to start. The user must remove the untrusted policy or fix the\nsignatures requirements in order to get the PolicyServer running again."),(0,a.kt)("h2",{id:"signature-config-reference"},"Signature Config Reference"),(0,a.kt)("p",null,"Users can also provide a file with all the signature requirements they want to validate. A sample file is shown below:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-yaml"},"apiVersion: v1\n\nallOf:\n  - kind: githubAction\n    owner: kubewarden   # mandatory\n    annotations:\n      env: prod\n\nanyOf: # at least `anyOf.minimumMatches` are required to match\n  minimumMatches: 2 # default is 1\n  signatures:\n  - kind: pubKey\n    owner: flavio # optional\n    key: .... # mandatory\n    annotations:  # optional\n      env: prod\n      foo: bar\n  - kind: pubKey\n    owner: victor # optional\n    key: .... # mandatory\n  - kind: genericIssuer\n    issuer: https://github.com/login/oauth\n    subject:\n      equal: alice@example.com\n  - kind: genericIssuer\n    issuer: https://token.actions.githubusercontent.com\n    subject:\n      equal: https://github.com/flavio/policy-secure-pod-images/.github/workflows/release.yml@refs/heads/main\n  - kind: genericIssuer\n    issuer: https://token.actions.githubusercontent.com\n    subject:\n      urlPrefix: https://github.com/flavio/\n  - kind: genericIssuer\n    issuer: https://token.actions.githubusercontent.com\n    subject:\n      urlPrefix: https://github.com/kubewarden # <- it will be post-fixed with `/` for security reasons\n  - kind: githubAction\n    owner: flavio   # mandatory\n    repo: policy1 # optional\n  - kind: pubKey\n    owner: alice # optional\n    key: .... # mandatory\n")),(0,a.kt)("p",null,"The configuration is composed of two sections:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"anyOf"),":  The policy will be trusted if the ",(0,a.kt)("inlineCode",{parentName:"li"},"minimumMatches")," criterion is fulfilled.\nIn the above example, the ",(0,a.kt)("inlineCode",{parentName:"li"},"minimumMatches")," field has been assigned a value 2.\nThis means that at least two of the signature requirements listed ",(0,a.kt)("strong",{parentName:"li"},"need to be fulfilled"),"\nfor the policy to be trusted. The default value that the ",(0,a.kt)("inlineCode",{parentName:"li"},"minimumMatches")," field assumes is ",(0,a.kt)("inlineCode",{parentName:"li"},"1"),"."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"allOf"),": All the signature requirements defined in this section must be valid\nso that the policy can be trusted.")),(0,a.kt)("p",null,"Each of these sections can contain one or more signature requirements.\nUsers can also define both sections in one file as shown above. In this situations, all\nthe signatures requirements from the ",(0,a.kt)("inlineCode",{parentName:"p"},"allOf")," ",(0,a.kt)("strong",{parentName:"p"},"AND")," a minimum number of matches\nfrom the ",(0,a.kt)("inlineCode",{parentName:"p"},"anyOf")," section as described in the ",(0,a.kt)("inlineCode",{parentName:"p"},"minimumMatches")," field must be satisfied."),(0,a.kt)("h3",{id:"signature-validation"},"Signature validation"),(0,a.kt)("p",null,"The users can validate different signatures in the ",(0,a.kt)("inlineCode",{parentName:"p"},"anyOf")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"allOf")," sections.\nIt's possible to validate the public key and the keyless data used to sign the policy."),(0,a.kt)("h4",{id:"public-key-validation"},"Public key validation"),(0,a.kt)("p",null,"To ensure a policy is signed with the given public key, the users can\ndefine the key data and the owner of the key used to sign the policy. As illustrated\nbellow, it is necessary to define the kind as ",(0,a.kt)("inlineCode",{parentName:"p"},"pubKey")," and insert the public\nkey data in the ",(0,a.kt)("inlineCode",{parentName:"p"},"key")," field. The owner field is optional, but can be useful to clarify who owns the key."),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Example")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-yaml"},"  - kind: pubKey\n    owner: bob # optional\n    key: |\n      -----BEGIN PUBLIC KEY-----\n      MBFKHFDGHKIJH0CAQYIKoZIzj0DAQcDQgAEX0HFTtCfTtPmkx5p1RbDE6HJSGAVD\n      BVDF6SKFSF87AASUspkQsN3FO4iyWodCy5j3o0CdIJD/KJHDJFHDFIu6sA==\n      -----END PUBLIC KEY-----\n")),(0,a.kt)("h4",{id:"keyless-signatures-validation"},"Keyless signatures validation"),(0,a.kt)("p",null,"When signed in keyless mode, we do not have the public key to verify. In this\nsituation, the users can verify the field filled with the OIDC data used during\nthe signing process. For that, it's necessary to define the kind of the signature\nvalidation as ",(0,a.kt)("inlineCode",{parentName:"p"},"genericIssuer"),". Therefore, it's possible to verify three pieces\nof information from the signature:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"issuer"),"(mandatory): matches the ",(0,a.kt)("inlineCode",{parentName:"li"},"Issuer")," attribute in the certificate\ngenerated by Fulcio. This shows the OIDC used to sign the policy"),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"subject"),": field used to match the ",(0,a.kt)("inlineCode",{parentName:"li"},"Subject")," attribute in Fulcio's\ncertificate. The ",(0,a.kt)("inlineCode",{parentName:"li"},"Subject")," field contains the information of the user used to\nauthenticate again the OIDC provider. The verification field, ",(0,a.kt)("inlineCode",{parentName:"li"},"subject"),", can have\ntwo children fields: ",(0,a.kt)("inlineCode",{parentName:"li"},"equal")," forces the ",(0,a.kt)("inlineCode",{parentName:"li"},"Subject")," from the certificate to be\nequal to the value defined in the signature validation; ",(0,a.kt)("inlineCode",{parentName:"li"},"urlPrefix")," forces the\nvalue of the certificate's ",(0,a.kt)("inlineCode",{parentName:"li"},"Subject")," field value to be prefixed by the value\ndefined in the signature requirement.")),(0,a.kt)("blockquote",null,(0,a.kt)("p",{parentName:"blockquote"},"Note well: both the ",(0,a.kt)("inlineCode",{parentName:"p"},"cosign verify")," and the ",(0,a.kt)("inlineCode",{parentName:"p"},"kwctl inspect")," commands can be used to show the information about keyless signatures.\n",(0,a.kt)("strong",{parentName:"p"},"Examples"))),(0,a.kt)("p",null,"The following configuration requires the policy to be signed by Alice in a keyless manner\nusing the GitHub OIDC:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-yaml"},"- kind: genericIssuer\n  issuer: https://github.com/login/oauth\n  subject:\n    equal: alice@example.com\n")),(0,a.kt)("p",null,"While the next configuration enforces the policy to be signed in the context of a GitHub actions environment\nfrom a repository owned by the GitHub user ",(0,a.kt)("inlineCode",{parentName:"p"},"flavio"),":"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-yaml"},"- kind: genericIssuer\n  issuer: https://token.actions.githubusercontent.com\n  subject:\n    urlPrefix: https://github.com/flavio\n")),(0,a.kt)("h4",{id:"github-actions-signature-verification"},"GitHub actions signature verification"),(0,a.kt)("p",null,"The signature validation kind, ",(0,a.kt)("inlineCode",{parentName:"p"},"githubAction")," is used to validate policies signed in a GitHub\nActions environment. It can be achieved with the ",(0,a.kt)("inlineCode",{parentName:"p"},"genericIssuer")," kind as well. But\n",(0,a.kt)("inlineCode",{parentName:"p"},"githubAction"),"simplifies the signature requirement creation process by defining two additional fields:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"owner")," (mandatory): GitHub ID of the user or organization to be trusted"),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"repo"),": the name of the repository to be trusted")),(0,a.kt)("p",null,"For example, the last configuration snippet shown above that leveraged a ",(0,a.kt)("inlineCode",{parentName:"p"},"genericIssuer"),", could be rewritten in this way:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-yaml"},"- kind: githubAction\n  owner: flavio\n")),(0,a.kt)("h4",{id:"signature-annotations-validation"},"Signature annotations validation"),(0,a.kt)("p",null,"All the signature types can have one additional optional validation field, ",(0,a.kt)("inlineCode",{parentName:"p"},"annotations"),".\nThese fields are key/value data added by the users during the signing process. Kubewarden\nmakes possible to ensure that policies are signed by trusted users ",(0,a.kt)("strong",{parentName:"p"},"and")," have specific annotations."),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Examples")),(0,a.kt)("p",null,"If the users want to trust only policies which have been signed with a specific key\nand the annotation ",(0,a.kt)("inlineCode",{parentName:"p"},"environment")," with the value ",(0,a.kt)("inlineCode",{parentName:"p"},"production"),", they can define the\nfollowing validation:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-yaml"},"- kind: pubKey\n  key: |\n    -----BEGIN PUBLIC KEY-----\n    MBFKHFDGHKIJH0CAQYIKoZIzj0DAQcDQgAEX0HFTtCfTtPmkx5p1RbDE6HJSGAVD\n    BVDF6SKFSF87AASUspkQsN3FO4iyWodCy5j3o0CdIJD/KJHDJFHDFIu6sA==\n    -----END PUBLIC KEY-----\n  annotations:\n    environment: production\n")),(0,a.kt)("h3",{id:"how-to-use-signature-verification-config-file-to-check-a-policy-oci-artefact"},"How to use signature verification config file to check a policy OCI artefact"),(0,a.kt)("p",null,"To test if a given policy passes signature verification using the\nverification config file, use the ",(0,a.kt)("inlineCode",{parentName:"p"},"--verification-config-path"),"  flag of the ",(0,a.kt)("inlineCode",{parentName:"p"},"kwctl verify")," command"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-console"},"$ cat signatures_requirements.yaml\napiVersion: v1\nallOf:\n  - kind: pubKey\n    key: |\n      -----BEGIN PUBLIC KEY-----\n      MFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAE5Q+cN1Jj2S7N05J4AXnqwP2DyzSg\n      Mc+raYce2Wthrd30MSgFtoh5ADAkCd/nML2Nx8UD9KBuASRb0gG5jXqgMQ==\n      -----END PUBLIC KEY-----\n\n$ kwctl verify --verification-config-path signatures_requirements.yaml ghcr.io/jvanz/policies/user-group-psp:latest\n2022-03-29T17:34:37.847169Z  INFO kwctl::verify: Policy successfully verified\n")),(0,a.kt)("p",null,"While the previous example tests if the policy is signed by the given key,\nthe next one checks if a given policy came from the Kubewarden organization:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-console"},"$ cat kubewarden_signatures.yaml\napiVersion: v1\nallOf:\n  - kind: githubAction\n    owner: kubewarden\n\n$ kwctl verify --verification-config-path kubewarden_signatures.yaml ghcr.io/kubewarden/policies/user-group-psp:latest\n2022-03-29T18:07:39.062292Z  INFO kwctl::verify: Policy successfully verified\n")))}p.isMDXComponent=!0}}]);